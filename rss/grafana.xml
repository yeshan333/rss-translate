<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Grafana Labs 上的 Grafana Labs 博客</title><link>https://grafana.com/blog/</link><description>Grafana Labs 上的 Grafana Labs 博客中的最​​新内容</description><lastBuildDate>Tue, 02 Apr 2024 16:04:15 GMT</lastBuildDate><generator>rfeed v1.1.1</generator><docs>https://github.com/svpino/rfeed/blob/master/README.md</docs><item><title>Grafana 警报中的简化路由：简单、安全且功能强大</title><link>https://grafana.com/blog/2024/04/02/simplified-routing-in-grafana-alerting-easy-secure-and-powerful/</link><description>&lt;p&gt;能力越大，复杂性就越大？&lt;/p&gt;&lt;p&gt;几年前，当我们推出&lt;a href="https://grafana.com/docs/grafana/latest/alerting/"&gt;Grafana Alerting&lt;/a&gt;时，它包含了强大的路由功能，团队可以使用该功能向各个联系点发送警报。不幸的是，这个功能也带来了相当大的复杂性和不熟悉的用户体验。这阻止了许多用户采用它，但我们仍然坚信它可以如何帮助用户。这就是为什么我们很高兴地告诉您一种新的&lt;strong&gt;简化路由&lt;/strong&gt;功能，该功能保留了所有功能，同时抽象了相应的复杂性。&lt;/p&gt;&lt;p&gt;在本博客中，我们将介绍我们是如何走到这一步的，并向您展示今天开始使用简化路由是多么容易。&lt;/p&gt;&lt;h2 id="notification-policies-the-power-and-the-problems"&gt;通报政策：权力与问题&lt;/h2&gt;&lt;p&gt;在我们进入新的简化路由之前，让我们首先看看幕后的内容（以及多年来一直存在的内容）。正如我们之前提到的，Grafana Alerting 引入了基于&lt;a href="https://grafana.com/docs/grafana-cloud/alerting-and-irm/alerting/fundamentals/notifications/notification-policies/"&gt;通知策略&lt;/a&gt;和标签的树形结构路由方法。您可以使用这些策略将警报路由到不同的接收者（电子邮件、Slack、Grafana OnCall 等），并且当您向通知策略添加标签时，您可以修改警报的发送位置。&lt;/p&gt;&lt;p&gt;与其他 IRM 解决方案相比，这提供了很多优势。例如，假设您想要更改发送通知的位置。使用其他工具，您必须为依赖该警报规则的每个服务器更改警报规则，这可能会增加多达数千个更改。但通过通知策略，您只需添加一个标签，Grafana Alerting 就会处理剩下的事情。&lt;/p&gt;&lt;div class="shortcode youtube"&gt;&lt;/div&gt;&lt;p&gt;我们有非常喜欢这个功能的用户（尤其是那些精通 Prometheus 的用户）。例如，如果您想为大客户提供白手套支持，您只需为该特定客户添加嵌套标签，以便当警报触发时，它会直接路由到礼宾服务或更高级别的团队。这种动态路由功能非常强大，而且也让维护变得更加容易。&lt;/p&gt;&lt;p&gt;然而，这种方法让很多用户感到困惑。他们中的许多人干脆完全绕过了它，而其他人则发现自己错误地标记了警报规则，并且不知道这些警报的去向。这显然不是我们希望看到的，因此我们决定让动态警报路由更简单、更直观。&lt;/p&gt;&lt;h2 id="why-you-should-use-simplified-routing-instead"&gt;为什么应该使用简化路由&lt;/h2&gt;&lt;p&gt;好消息是我们刚才讨论的所有能量都不会消失；它只是被抽象出来，所以你不必担心它。现在，您只需在 Grafana Alerting 中选择联系点，我们就会在后台自动生成策略。您仍然可以修改策略、静音计时、更改分组等等 - 您唯一失去的就是复杂性。&lt;/p&gt;&lt;p&gt;简化路由的另一个巨大好处是它继承了警报规则 RBAC，这使您可以增强对路由的控制。这还可以帮助您避免其他团队的某人意外删除错误的策略或添加竞争策略，然后您突然停止收到通知的情况。您可以限制团队或个人的访问权限，并且只有具有管理员身份的人员才能修改这些设置。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;em&gt;注意：简化路由目前仅适用于 Grafana 托管警报和 Grafana Alertmanager。对于其他Alertmanagers，您可以继续使用通知策略。&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id="how-to-use-simplified-routing"&gt;如何使用简化路由&lt;/h2&gt;&lt;p&gt;今天，所有 Grafana Cloud 用户都可以使用简化路由，并且在&lt;a href="https://grafana.com/docs/grafana/latest/whatsnew/whats-new-in-v10-4/"&gt;Grafana 10.4&lt;/a&gt;中默认启用它（尽管功能切换仍然存在，以防您想禁用它）。&lt;/p&gt;&lt;p&gt;首先，转到在新警报表单中&lt;strong&gt;配置标签和通知&lt;/strong&gt;，然后单击&lt;strong&gt;选择联系点&lt;/strong&gt;。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/simplified-routing/select-contact-point.png"&gt;&lt;img alt="显示如何选择接触点的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="显示如何选择接触点的屏幕截图。" src="https://grafana.com/media/blog/simplified-routing/select-contact-point.png" /&gt;&lt;/noscript&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;接下来，从现有选项中选择联系点。您可以直接从此表单配置路由，所有通知将直接路由到该联系点。您不需要做任何其他事情。&lt;/p&gt;&lt;p&gt;如果您想添加新端点，请单击下拉菜单旁边的&lt;strong&gt;查看或创建联系点&lt;/strong&gt;链接。如果您具有适当的 RBAC 权限，您可以直接在那里创建新的联系点。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt;&lt;a class="lightbox-link" href="https://grafana.com/media/blog/simplified-routing/contact-point.png"&gt;&lt;img alt="显示如何创建新联系点的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="显示如何创建新联系点的屏幕截图。" src="https://grafana.com/media/blog/simplified-routing/contact-point.png" /&gt;&lt;/noscript&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;还可以选择配置路线设置，例如静音计时、覆盖组或覆盖计时。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/simplified-routing/override-grouping.png"&gt;&lt;img alt="显示静音、分组和计时选项的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="显示静音、分组和计时选项的屏幕截图。" src="https://grafana.com/media/blog/simplified-routing/override-grouping.png" /&gt;&lt;/noscript&gt;&lt;/a&gt;&lt;/figure&gt;&lt;h2 id="auto-generated-policies-only-visible-to-admin-users"&gt;自动生成的策略：仅对管理员用户可见&lt;/h2&gt;&lt;p&gt;在简化路由中，警报会在策略树中的新节点下自动生成特殊策略。默认情况下，这个新节点是折叠的，只有管理员才能看到它。&lt;/p&gt;&lt;p&gt;在这个新节点下，我们为每个联系点生成一个策略。如果警报规则使用与默认值不同的路由设置保存，我们会使用警报规则的路由设置的哈希值为联系点生成一个新的嵌套策略。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/simplified-routing/notification-policies.png"&gt;&lt;img alt="显示通知策略的更多选项的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="显示通知策略的更多选项的屏幕截图。" src="https://grafana.com/media/blog/simplified-routing/notification-policies.png" /&gt;&lt;/noscript&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;正如您在下面看到的，有一个实例通过&lt;strong&gt;cp1&lt;/strong&gt;&lt;strong&gt;路由到紫色节点&lt;/strong&gt;，还有另一个实例已发送到&lt;strong&gt;蓝色节点&lt;/strong&gt;- 对于这个实例，我们使用哈希。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/simplified-routing/notification-policies-2.png"&gt;&lt;img alt="显示嵌套通知策略的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="显示嵌套通知策略的屏幕截图。" src="https://grafana.com/media/blog/simplified-routing/notification-policies-2.png" /&gt;&lt;/noscript&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;同样，这仅对管理员用户显示。&lt;/p&gt;&lt;p&gt;请务必注意，所有这些自动生成的策略都是只读的。如果管理员想要更新某些内容，他们将必须转到警报规则表单并更新其中的路由字段。&lt;/p&gt;&lt;p&gt;要了解有关 Grafana Alerting 的更多信息，您可以查看我们的&lt;a href="https://grafana.com/docs/grafana/latest/alerting/"&gt;技术文档&lt;/a&gt;和其他&lt;a href="https://grafana.com/tags/alerting/"&gt;最近的博客文章&lt;/a&gt;。&lt;/p&gt;</description><pubDate>Tue, 02 Apr 2024 09:12:00 GMT</pubDate><guid isPermaLink="true">https://grafana.com/blog/2024/04/02/simplified-routing-in-grafana-alerting-easy-secure-and-powerful/</guid></item><item><title>如何监控孩子的家务活：Grafana 支持的育儿简介</title><link>https://grafana.com/blog/2024/04/01/how-to-monitor-your-kids-chores-an-introduction-to-grafana-powered-parenting/</link><description>&lt;p&gt;我是两个男孩本杰明和伊森的骄傲的父亲，他们每天都试图收拾他们的房间，但并不总是成功。我也是 Grafana Labs 的高级解决方案工程师，这自然让我想知道是否可以使用 Grafana 来应对这一持续的挑战。&lt;/p&gt;&lt;p&gt;特别是，我开始在&lt;a href="https://grafana.com/docs/grafana-cloud/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana Cloud&lt;/a&gt;中监控孩子的清洁进度，并在他们未能清洁房间时自动通知他们。这项任务的结果就是我和我的妻子伊丽莎白（亲切地）所说的&lt;em&gt;“机器人育儿”&lt;/em&gt; 。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link captioned" href="https://grafana.com/media/blog/roboparenting_grafana_cloud/brian-family-photo.jpg"&gt;&lt;img alt="A family photo from the author." class="lazyload mb-0" title="*布莱恩与妻子伊丽莎白以及儿子本杰明 (8 岁) 和伊森 (12 岁) 的照片。*" /&gt; &lt;noscript&gt;&lt;img alt="A family photo from the author." src="https://grafana.com/media/blog/roboparenting_grafana_cloud/brian-family-photo.jpg" title="*布莱恩与妻子伊丽莎白以及儿子本杰明 (8 岁) 和伊森 (12 岁) 的照片。*" /&gt;&lt;/noscript&gt;&lt;figcaption class="w-100p caption mb-1 text-gray-13 "&gt;&lt;em&gt;布莱恩 (Brian) 与妻子伊丽莎白 (Elizabeth) 以及儿子本杰明 (Benjamin) (8) 和伊森 (Ethan) (12) 的照片。&lt;/em&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;在这篇博文中，我们将详细介绍我如何设置这个 Roboparenting 解决方案，包括：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;如何使用调用用 Python 编写的自定义端点的动态元素创建 Slack 消息。&lt;/li&gt;&lt;li&gt;如何在 MySQL 数据库中记录端点交互的事件数据。&lt;/li&gt;&lt;li&gt;如何使用 Python 为 Prometheus 编写自定义导出器，并使用 Grafana Agent 将指标和日志发送到 Grafana Cloud。&lt;/li&gt;&lt;li&gt;如何生成警报并将这些警报路由到 Slack &lt;a href="https://grafana.com/docs/grafana-cloud/alerting-and-irm/irm-intro/?pg=blog&amp;amp;plcmt=body-txt"&gt;&lt;/a&gt; Grafana IRM，包括&lt;a href="https://grafana.com/docs/oncall/latest/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana OnCall&lt;/a&gt;和&lt;a href="https://grafana.com/docs/grafana-cloud/alerting-and-irm/incident/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana Incident&lt;/a&gt; 。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;em&gt;注意：我使用免费的 Grafana Cloud 完成了所有这一切。如果您还没有免费的 Grafana Cloud 帐户，您可以&lt;a href="https://grafana.com/auth/sign-up/create-user/?pg=blog&amp;amp;plcmt=body-txt"&gt;立即注册&lt;/a&gt;。&lt;/em&gt;&lt;/p&gt;&lt;p&gt;我还将谈谈我如何说服我的孩子们参与这个项目（幸运的是，考虑到他们对技术的天然兴趣，这并不太难）。让我们开始吧。&lt;/p&gt;&lt;h2 id="setting-up-alerts-to-record-the-room-state"&gt;设置警报以记录房间状态&lt;/h2&gt;&lt;p&gt;我需要一个用户界面来发送警报并记录孩子房间的状态。我使用 Slack 进行公司沟通，并且我有一个个人工作空间，我已经将其用于其他一些家庭自动化。我认为这可以很好地用作通知和设置状态的主要 UI，因为我一天中的大部分时间都在笔记本电脑上打开它。&lt;/p&gt;&lt;p&gt;我做了一些早期研究，发现使用&lt;a href="https://api.slack.com/block-kit" rel="noopener noreferrer" target="_blank"&gt;Block Kit&lt;/a&gt;构建交互式 Slack 消息并不太困难。后来，我添加了一些&lt;a href="https://api.slack.com/interactivity/slash-commands" rel="noopener noreferrer" target="_blank"&gt;斜线命令&lt;/a&gt;，这些命令调用我的端点来发送事件和检索状态（更多内容见下文）。&lt;/p&gt;&lt;p&gt;我完成的消息如下所示：&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/roboparenting_grafana_cloud/roboparenting_grafana_cloud_alerting_slack_notification.png"&gt;&lt;img alt="Slack 通知的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="Slack 通知的屏幕截图。" src="https://grafana.com/media/blog/roboparenting_grafana_cloud/roboparenting_grafana_cloud_alerting_slack_notification.png" /&gt;&lt;/noscript&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;当然，我要在这里暂停一下，承认这样的机器人育儿解决方案要想发挥作用，你必须真正&lt;em&gt;得到孩子的回应&lt;/em&gt;。就我而言，本杰明和伊森都非常热衷于技术。他们总是问我的工作以及 Grafana 能做什么。这个项目是一个有趣的方式来展示这一点，老实说，男孩们并不介意每天早上在上学前收到这些通知（不过，全面披露：我经常不得不从另一个房间提示他们做出回应）。更重要的是，我和我的妻子一直期望每个人都能在家务中发挥作用。我们很幸运能够为孩子们提供每周零用钱以及滑雪、山地自行车和旅行等体验。对于我们来说，这个 Roboparenting 解决方案是跟踪他们的表现并简化我们的日常提醒的好方法。&lt;/p&gt;&lt;p&gt;好的，现在回到技术细节。&lt;/p&gt;&lt;p&gt;当孩子们单击 Slack 消息中的按钮时，这会调用我的 Webhook，我将在下面介绍它。&lt;/p&gt;&lt;p&gt;该消息存储在 JSON 对象中，可以从许多不同的本机 SDK 发送。您必须加入付费 Slack 计划才能使用其中一些，但带有 JSON 对象的基本curl 命令是免费的。我喜欢家庭自动化的免费服务，所以这就是我选择发送消息的方法。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/roboparenting_grafana_cloud/roboparenting_grafana_cloud_activate_incoming_webhooks.png"&gt;&lt;img alt="从 Slack 传入的 Webhooks 文档的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="从 Slack 传入的 Webhooks 文档的屏幕截图。" src="https://grafana.com/media/blog/roboparenting_grafana_cloud/roboparenting_grafana_cloud_activate_incoming_webhooks.png" /&gt;&lt;/noscript&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;我编写了一个 bash 脚本并将其添加到我的 Linux 服务器上的 crontab 中。本杰明和伊森每天都会在自己的频道中收到自己的 Slack 消息。您可以在此&lt;a href="https://github.com/uvmskier/roboparent_bash" rel="noopener noreferrer" target="_blank"&gt;GitHub 存储库&lt;/a&gt;中找到 bash 脚本。&lt;/p&gt;&lt;h2 id="webhook-for-receiving-events-from-slack"&gt;用于从 Slack 接收事件的 Webhook&lt;/h2&gt;&lt;p&gt;我首先使用 Python 中的 Flask 编写了一个 Webhook，它接收来自 Slack 的事件并将它们写入日志文件。您可以在此&lt;a href="https://github.com/uvmskier/roboparent_webhook" rel="noopener noreferrer" target="_blank"&gt;GitHub 存储库&lt;/a&gt;中查看最终版本。&lt;/p&gt;&lt;p&gt;我认为这会满足我的要求，因为我跟踪的事件是一种状态而不是指标。我最初的计划是通过创建日志的记录查询将日志转换为指标。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/roboparenting_grafana_cloud/roboparenting_grafana_cloud_recorded_query_of_the_logs.png"&gt;&lt;img alt="记录的日志查询的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="记录的日志查询的屏幕截图。" src="https://grafana.com/media/blog/roboparenting_grafana_cloud/roboparenting_grafana_cloud_recorded_query_of_the_logs.png" /&gt;&lt;/noscript&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;我遇到的问题是，最后一个状态（“已接听”或“未接听”）没有考虑基于一天中时间的所需状态。例如，我不在乎孩子们的房间在午夜和早上上学前的某个时间是否没有被收拾。我还想在工作日和周末的早上有不同的所需时间。我需要能够将这些日志事件与一些条件逻辑结合起来。&lt;/p&gt;&lt;p&gt;最好的解决方案是创建我自己的自定义导出器，我也是用 Python 编写的。 （稍后我将详细介绍导出器。）我将事件和一些配置存储在 MySQL 数据库中。&lt;/p&gt;&lt;p&gt;我用于从 Slack 接收事件的主要 Python 函数是&lt;code&gt;roboparentEvent&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;该函数写入 MySQL 中名为&lt;strong&gt;roboparentevent&lt;/strong&gt;的表。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/roboparenting_grafana_cloud/roboparenting_grafana_cloud_mysql-table.png"&gt;&lt;img alt="roboparentevent MySQL 表的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="roboparentevent MySQL 表的屏幕截图。" src="https://grafana.com/media/blog/roboparenting_grafana_cloud/roboparenting_grafana_cloud_mysql-table.png" /&gt;&lt;/noscript&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;该表每天由调用方法&lt;code&gt;resetEventTableAndSnooze&lt;/code&gt;的 crontab 执行的 bash 脚本清除并填充&lt;code&gt;NewDay&lt;/code&gt;事件。&lt;/p&gt;&lt;p&gt;我还注意到机器人正在抓取我的端点，因此我决定防止未经授权的使用。我安装了&lt;a href="https://slack.dev/python-slack-sdk/" rel="noopener noreferrer" target="_blank"&gt;Python Slack SDK&lt;/a&gt;库，并将以下标头添加到每个端点。&lt;/p&gt;&lt;div class="code-snippet "&gt;&lt;div class="lang-toolbar"&gt; &lt;span class="lang-toolbar__item"&gt;Python&lt;/span&gt; &lt;span class="code-clipboard"&gt;&lt;button&gt;&lt;img alt="将代码复制到剪贴板" class="code-clipboard__icon" height="13" src="https://grafana.com/media/images/icons/icon-copy-small-2.svg" width="14" /&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;div class="lang-toolbar__border"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="code-snippet "&gt;&lt;pre&gt; &lt;code class="language-python"&gt;##slack_signing_secret is loaded from a secrets file #########authorize the request############ timestamp = request.headers[&amp;#39;X-Slack-Request-Timestamp&amp;#39;] slack_payload = request.form signatureVerifier = signature.SignatureVerifier(slack_signing_secret,signature.Clock()) calculated_signature = signatureVerifier.generate_signature(timestamp=timestamp,body=slack_payload) isValid = signatureVerifier.is_valid(slack_payload,timestamp,calculated_signature) if (isValid == False): return &amp;#39;Unauthorized&amp;#39;, 400 #########end authorize the request########&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;上面的代码使用 Slack 提供的标准技术，使用我的应用程序特有的签名密钥对消息正文进行哈希处理，以验证请求是否已获得授权。该技术甚至使用当前时间来防止重复消息攻击。&lt;/p&gt;&lt;p&gt;&lt;em&gt;注意：我的导出器和 webhook 在 Debian Linux 上的 systemd 下运行。有关如何创建自定义服务的说明请参见&lt;a href="https://www.tecmint.com/create-systemd-service-linux/" rel="noopener noreferrer" target="_blank"&gt;此处&lt;/a&gt;。&lt;/em&gt;&lt;/p&gt;&lt;h2 id="querying-the-room-status"&gt;查询房间状态&lt;/h2&gt;&lt;p&gt;我编写了一个名为&lt;code&gt;getRoomStatus&lt;/code&gt;的方法，该方法查询&lt;strong&gt;roboparentevent&lt;/strong&gt;表，以根据&lt;code&gt;eventname&lt;/code&gt;按创建日期升序评估事件。一些基本逻辑根据最后一个事件（ &lt;code&gt;NewDay&lt;/code&gt; 、 &lt;code&gt;SuccessfulCleanup&lt;/code&gt; 、 &lt;code&gt;FailedCleanup&lt;/code&gt;或&lt;code&gt;Snoozed&lt;/code&gt; ）确定房间是否被拾取。&lt;/p&gt;&lt;p&gt;我在导出器中使用&lt;code&gt;getRoomStatus&lt;/code&gt;方法（稍后我将对此进行解释），以及在斜杠命令中使用该方法（稍后我也会对此进行解释）。&lt;/p&gt;&lt;h2 id="snooze-functionality"&gt;贪睡功能&lt;/h2&gt;&lt;p&gt;我很快决定，当我们度假或其中一个孩子外出过夜时，我需要暂停通知。我创建了一个名为&lt;strong&gt;“贪睡”&lt;/strong&gt;的表，其中包含一个字段来跟踪孩子和贪睡日期。我编写了一个名为&lt;code&gt;setSnooze&lt;/code&gt;的方法，它删除任何现有的贪睡记录，将新的贪睡记录插入&lt;strong&gt;贪睡&lt;/strong&gt;表，并将事件插入&lt;strong&gt;roboparentevent&lt;/strong&gt;表。&lt;/p&gt;&lt;h2 id="slash-commands-in-slack"&gt; Slack 中的斜杠命令&lt;/h2&gt;&lt;p&gt;如前所述，我希望能够在 Slack 中通过斜线命令设置状态和检查状态。这相当简单。您只需在 API 工具中定义斜杠命令并使用 URL、参数和使用建议对其进行配置即可。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/roboparenting_grafana_cloud/roboparenting_grafana_cloud_slash_commands_screenshots.png"&gt;&lt;img alt="Slack 的 Slash 命令文档的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="Slack 的 Slash 命令文档的屏幕截图。" src="https://grafana.com/media/blog/roboparenting_grafana_cloud/roboparenting_grafana_cloud_slash_commands_screenshots.png" /&gt;&lt;/noscript&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt; Slack SDK 提供了通过 Webhook 的响应将消息返回到通道的功能。&lt;/p&gt;&lt;h2 id="custom-metrics-exporter"&gt;自定义指标导出器&lt;/h2&gt;&lt;p&gt;我根据&lt;a href="https://prometheus.github.io/client_python/collector/custom/" rel="noopener noreferrer" target="_blank"&gt;这些说明&lt;/a&gt;，使用 prometheus_client Python 库编写了一个自定义导出器。&lt;/p&gt;&lt;p&gt;我的指标如下：&lt;/p&gt;&lt;ul&gt;&lt;li&gt; &lt;code&gt;ROBOPARENT_NUMBER_OF_KIDS&lt;/code&gt; ：这个主要是为了好玩，是我在开始时写的第一个。&lt;/li&gt;&lt;li&gt; &lt;code&gt;ROBOPARENT_REQUIRED_ROOM_STATUS&lt;/code&gt; ：这是每个孩子所需的房间状态，基于星期几和他们去学校的时间。我用一个叫&lt;code&gt;kid&lt;/code&gt;的标签来区分本杰明和伊森。&lt;/li&gt;&lt;li&gt; &lt;code&gt;ROBOPARENT_ROOM_STATUS&lt;/code&gt; ：这是每个孩子房间的实际状态。我再次使用了一个名为&lt;code&gt;kid&lt;/code&gt;的标签来区分两者。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我创建了一个记录查询来组合&lt;code&gt;ROBOPARENT_REQUIRED_ROOM_STATUS&lt;/code&gt;和&lt;code&gt;ROBOPARENT_ROOM_STATUS&lt;/code&gt; 。我能够提取我想要的数据。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/roboparenting_grafana_cloud/roboparenting_grafana_cloud_recorded_query.png"&gt;&lt;img alt="机器人育儿指标的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="机器人育儿指标的屏幕截图。" src="https://grafana.com/media/blog/roboparenting_grafana_cloud/roboparenting_grafana_cloud_recorded_query.png" /&gt;&lt;/noscript&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;房间状态（或所需房间状态）为 0 = 未拾取，房间状态（或所需房间状态）为 1 = 已拾取。我确定，如果我从实际房间状态中减去所需的房间状态，任何值 &amp;gt;= 0 都意味着房间符合要求。&lt;/p&gt;&lt;p&gt;这里有些例子：&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;实际房况(A)&lt;/th&gt;&lt;th&gt;所需房型 (B)&lt;/th&gt;&lt;th&gt;合规状态 (AB)&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt; 1&lt;/td&gt;&lt;td&gt; 1&lt;/td&gt;&lt;td&gt; 0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; 0&lt;/td&gt;&lt;td&gt; 0&lt;/td&gt;&lt;td&gt; 0&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; 0&lt;/td&gt;&lt;td&gt; 1&lt;/td&gt;&lt;td&gt; -1&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这是一种&lt;strong&gt;有效的技术&lt;/strong&gt;，当客户需要在 Grafana 中组合指标并执行计算时，我会使用该技术。如果数据来自两个不同的来源，这会特别有用。然而，我的数据来自一个来源，我可以自由地定制正在生成的指标。结果，我发现这个设计存在以下我不想接受的权衡：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;与将其构建到 Python 方法或函数中相比，将其存储在 Grafana Cloud 中有点复杂。我能够自定义我的应用程序，因此我决定将此逻辑移至导出器。&lt;/li&gt;&lt;li&gt; Grafana Cloud 的当前版本不允许您在创建记录查询后对其进行编辑。您必须删除它并重新创建它。您也无法查看正在生成指标的查询。&lt;/li&gt;&lt;li&gt;记录的查询还会为每个孩子生成一个唯一的指标名称（例如&lt;code&gt;ROBOPARENT_ROOM_COMPLIANCE_[kid]&lt;/code&gt; ），而不是使用一个带标签的指标名称，例如&lt;code&gt;ROBOPARENT_ROOM_COMPLIANCE{kid=[kid]}&lt;/code&gt; 。我能够通过自定义代码创建更具可扩展性的解决方案，因此我认为这对我的应用程序来说是更好的设计。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我的最终设计添加了一个名为&lt;code&gt;ROBOPARENT_ROOM_COMPLIANCE&lt;/code&gt;指标，该指标为每个孩子使用一个标签。&lt;/p&gt;&lt;p&gt;导出器的完整代码在这里：&lt;/p&gt;&lt;div class="code-snippet "&gt;&lt;div class="lang-toolbar"&gt; &lt;span class="lang-toolbar__item"&gt;Python&lt;/span&gt; &lt;span class="code-clipboard"&gt;&lt;button&gt;&lt;img alt="将代码复制到剪贴板" class="code-clipboard__icon" height="13" src="https://grafana.com/media/images/icons/icon-copy-small-2.svg" width="14" /&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;div class="lang-toolbar__border"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="code-snippet "&gt;&lt;pre&gt; &lt;code class="language-python"&gt;import time from prometheus_client import start_http_server from prometheus_client.core import GaugeMetricFamily, REGISTRY from prometheus_client.registry import Collector import pythonmysql class CustomCollector(Collector): def collect(self): self.myDBObject = pythonmysql.PythonMySQL() kids = self.myDBObject.getNumKids() ROBOPARENT_NUMBER_OF_KIDS_GAUGE = GaugeMetricFamily(&amp;quot;ROBOPARENT_NUMBER_OF_KIDS&amp;quot;, &amp;#39;Roboparent Number of Kids&amp;#39;, value=kids) yield ROBOPARENT_NUMBER_OF_KIDS_GAUGE ROBOPARENT_REQUIRED_ROOM_STATUS = GaugeMetricFamily(&amp;quot;ROBOPARENT_REQUIRED_ROOM_STATUS&amp;quot;, &amp;#39;Roboparent required room status&amp;#39;, labels=[&amp;#39;kid&amp;#39;]) ROBOPARENT_ROOM_STATUS_GAUGE = GaugeMetricFamily(&amp;quot;ROBOPARENT_ROOM_STATUS&amp;quot;, &amp;#39;Roboparent room status for each kid&amp;#39;,labels=[&amp;#39;kid&amp;#39;]) ROBOPARENT_ROOM_COMPLIANCE_GAUGE = GaugeMetricFamily(&amp;quot;ROBOPARENT_ROOM_COMPLIANCE&amp;quot;, &amp;#39;Roboparent room compliance for each kid&amp;#39;,labels=[&amp;#39;kid&amp;#39;]) #get all kid records so we know what room statuses to query and what metrics to publish kidRecords = self.myDBObject.getAllKidRecords() for (name) in kidRecords: #set room status and required room status in the guage roomStatus = self.myDBObject.getRoomStatus(name[0]) ROBOPARENT_ROOM_STATUS_GAUGE.add_metric([name[0]],roomStatus) requiredRoomStatus = self.myDBObject.getCurrentRequiredRoomStatus(name[0]) ROBOPARENT_REQUIRED_ROOM_STATUS.add_metric([name[0]],requiredRoomStatus) #if the room status is greater than or equal to the required room status, set compliance to 1, if not, set it to 0 if(roomStatus &amp;gt;= requiredRoomStatus): ROBOPARENT_ROOM_COMPLIANCE_GAUGE.add_metric([name[0]],1) else: ROBOPARENT_ROOM_COMPLIANCE_GAUGE.add_metric([name[0]],0) yield ROBOPARENT_ROOM_STATUS_GAUGE yield ROBOPARENT_ROOM_COMPLIANCE_GAUGE yield ROBOPARENT_REQUIRED_ROOM_STATUS if __name__ == &amp;#39;__main__&amp;#39;: start_http_server(5002) REGISTRY.register(CustomCollector()) while True: time.sleep(30)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;h2 id="visualizing-the-data-in-grafana-cloud"&gt;可视化 Grafana Cloud 中的数据&lt;/h2&gt;&lt;p&gt;我的仪表板非常简单，因为我的数据来自一个来源，并且我不必对指标执行任何计算。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/roboparenting_grafana_cloud/roboparenting_grafana_cloud_main_dashboard.png"&gt;&lt;img alt="用于监控杂务的 Grafana Cloud 仪表板。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="用于监控杂务的 Grafana Cloud 仪表板。" src="https://grafana.com/media/blog/roboparenting_grafana_cloud/roboparenting_grafana_cloud_main_dashboard.png" /&gt;&lt;/noscript&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;所有统计面板都使用值映射来根据指标值显示彩色文本。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/roboparenting_grafana_cloud/roboparenting_grafana_cloud_pickedup_dashboard.png"&gt;&lt;img alt="显示统计面板值映射的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="显示统计面板值映射的屏幕截图。" src="https://grafana.com/media/blog/roboparenting_grafana_cloud/roboparenting_grafana_cloud_pickedup_dashboard.png" /&gt;&lt;/noscript&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;我使用状态图来可视化房间状态、所需房间状态和房间合规性状态。&lt;/p&gt;&lt;h2 id="generating-alert-notifications"&gt;生成警报通知&lt;/h2&gt;&lt;p&gt;我为每个孩子制定了警报规则。此警报规则使用&lt;code&gt;Benjamin&lt;/code&gt;作为标签对&lt;code&gt;ROBOPARENT_ROOM_COMPLIANCE&lt;/code&gt;指标运行基本查询，以便我们仅返回 Benjamin 的合规性指标。如果阈值低于 1，则意味着他的房间不合规，因此我会生成警报。以下是 Benjamin 的警报规则示例：&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/roboparenting_grafana_cloud/roboparenting_grafana_cloud_edit_rule.png"&gt;&lt;img alt="设置警报规则的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="设置警报规则的屏幕截图。" src="https://grafana.com/media/blog/roboparenting_grafana_cloud/roboparenting_grafana_cloud_edit_rule.png" /&gt;&lt;/noscript&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;我添加了警报摘要中包含的基本注释。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/roboparenting_grafana_cloud/roboparenting_grafana_cloud_add_annotations.png"&gt;&lt;img alt="显示如何添加注释的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="显示如何添加注释的屏幕截图。" src="https://grafana.com/media/blog/roboparenting_grafana_cloud/roboparenting_grafana_cloud_add_annotations.png" /&gt;&lt;/noscript&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;默认通知策略将 Grafana Cloud 实例上的所有警报路由到&lt;a href="https://grafana.com/docs/oncall/latest/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana OnCall&lt;/a&gt; 。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/roboparenting_grafana_cloud/roboparenting_grafana_cloud_alerting_notification_policies.png"&gt;&lt;img alt="默认通知策略的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="默认通知策略的屏幕截图。" src="https://grafana.com/media/blog/roboparenting_grafana_cloud/roboparenting_grafana_cloud_alerting_notification_policies.png" /&gt;&lt;/noscript&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;我还为每个孩子创建了单独的路线，因此他们的警报位于单独的 Slack 频道中。下面的屏幕截图显示了我如何查看警报有效负载以确定哪个孩子正在生成警报并路由到适当的频道。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/roboparenting_grafana_cloud/roboparents_grafana_cloud_oncall_alerts.png"&gt;&lt;img alt="警报负载的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="警报负载的屏幕截图。" src="https://grafana.com/media/blog/roboparenting_grafana_cloud/roboparents_grafana_cloud_oncall_alerts.png" /&gt;&lt;/noscript&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;当警报触发时，升级链&lt;strong&gt;Roboparent Notifications&lt;/strong&gt;会在 15 分钟内向整个 Slack 通道发出 3 次通知。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/roboparenting_grafana_cloud/roboparenting_grafana_cloud_escalation_chains.png"&gt;&lt;img alt="升级链的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="升级链的屏幕截图。" src="https://grafana.com/media/blog/roboparenting_grafana_cloud/roboparenting_grafana_cloud_escalation_chains.png" /&gt;&lt;/noscript&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;我们仍处于采用的早期阶段，因此您可以看到 Benjamin 和 Ethan 错过了所有三个警报，我必须手动设置状态。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/roboparenting_grafana_cloud/roboparents_grafana_cloud_benjamin_oncall_notifications.png"&gt;&lt;img alt="Slack 中 OnCall 警报的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="Slack 中 OnCall 警报的屏幕截图。" src="https://grafana.com/media/blog/roboparenting_grafana_cloud/roboparents_grafana_cloud_benjamin_oncall_notifications.png" /&gt;&lt;/noscript&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;展望未来，一旦我们收集更多数据，我想使用&lt;a href="https://grafana.com/docs/grafana-cloud/alerting-and-irm/slo/introduction/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana SLO&lt;/a&gt;创建一个 SLO 仪表板。同样，我们正处于采用的早期阶段，仍在研究最佳的提醒方法和时间，以确保每个人每天早上都能做出回应。谁知道呢——一旦我们达成了双方都能接受的服务水平协议，我什至可能会施加绩效处罚或奖金。&lt;/p&gt;&lt;p&gt; &lt;em&gt;&lt;a href="https://grafana.com/products/cloud/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana Cloud&lt;/a&gt;是开始使用指标、日志、跟踪、仪表板等的最简单方法。我们为每个用例提供慷慨的永久免费套餐和计划。&lt;a href="https://grafana.com/auth/sign-up/create-user/?pg=blog&amp;amp;plcmt=body-txt"&gt;现在免费注册&lt;/a&gt;！&lt;/em&gt;&lt;/p&gt;</description><pubDate>Mon, 01 Apr 2024 14:20:00 GMT</pubDate><guid isPermaLink="true">https://grafana.com/blog/2024/04/01/how-to-monitor-your-kids-chores-an-introduction-to-grafana-powered-parenting/</guid></item><item><title>更好的 Grafana OnCall：与 Grafana Cloud 的其余部分无缝工作流程</title><link>https://grafana.com/blog/2024/03/29/a-better-grafana-oncall-seamless-workflows-with-the-rest-of-grafana-cloud/</link><description>&lt;p&gt;事件响应和管理 (IRM) 并不是凭空发生的。您及时响应问题的能力在很大程度上取决于您的待命工程师能否很好地结合使用 IRM 工具和可观察性工具来了解发生了什么变化以及原因。&lt;/p&gt;&lt;p&gt;这就是为什么我们对 Grafana OnCall 更强大的优势之一感到兴奋：我们的待命管理工具与 Grafana LGTM Stack 的所有其他部分集成（ &lt;a href="https://grafana.com/oss/loki/?pg=blog&amp;amp;plcmt=body-txt"&gt;Loki&lt;/a&gt;用于日志、 &lt;a href="https://grafana.com/oss/grafana?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana&lt;/a&gt;用于可视化、 &lt;a href="https://grafana.com/oss/tempo/?pg=blog&amp;amp;plcmt=body-txt"&gt;Tempo&lt;/a&gt;用于跟踪， &lt;a href="https://grafana.com/oss/mimir/?pg=blog&amp;amp;plcmt=body-txt"&gt;Mimir&lt;/a&gt;用于跟踪）指标），你已经喜欢了。最近几个月，我们一直致力于在 Grafana OnCall、 &lt;a href="https://grafana.com/products/cloud/irm/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana IRM&lt;/a&gt;套件的其余部分以及整个&lt;a href="https://grafana.com/products/cloud/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana Cloud&lt;/a&gt;之间创建无缝工作流程。&lt;/p&gt;&lt;p&gt;在这篇博客中，我们将重点介绍我们所做的一些工作&lt;a href="https://grafana.com/blog/2023/09/18/a-better-grafana-oncall-delivering-on-features-for-users-at-scale/?pg=blog&amp;amp;plcmt=body-txt"&gt;流程更改&lt;/a&gt;&lt;a href="https://grafana.com/blog/2023/08/31/a-better-grafana-oncall-web-based-scheduling-mobile-app-email-support/?pg=blog&amp;amp;plcmt=body-txt"&gt;，&lt;/a&gt;这些更改可以减少冗余和上下文切换，以便您可以识别和响应事件发生得更快。&lt;/p&gt;&lt;h2 id="run-sift-automatically-from-grafana-oncall-alert-groups"&gt;从 Grafana OnCall 警报组自动运行 Sift&lt;/h2&gt;&lt;p&gt;现在，您可以配置&lt;a href="https://grafana.com/blog/2024/02/21/ai-powered-diagnostics-for-incident-response-new-sift-features-in-grafana-irm/"&gt;Sift&lt;/a&gt; （Grafana Cloud 中由机器学习驱动的诊断功能），以便在每次创建新的&lt;a href="https://grafana.com/docs/oncall/latest/manage/mobile-app/alert-groups-feed/"&gt;Grafana OnCall 警报组&lt;/a&gt;时运行。换句话说，自动诊断会附加到每个新页面。 Sift 将通过筛选与警报组关联的日志、指标和跟踪来检查常见的故障模式，从而减少您的团队了解他们为何被寻呼的时间。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt;&lt;a class="lightbox-link" href="https://grafana.com/media/blog/on-call-recap-3/outgoing-webhook.png"&gt;&lt;img alt="新的传出 Webhook 选项，包括 Sift" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="新的传出 Webhook 选项，包括 Sift" src="https://grafana.com/media/blog/on-call-recap-3/outgoing-webhook.png" /&gt;&lt;/noscript&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;您可以通过 Grafana OnCall 中新的 Sift 传出 Webhook 获得此优势。此 Webhook 允许您触发 Sift 调查，作为待命升级链的一部分，以便您可以对每个警报组进行自动调查。 Sift 甚至会将结果发布回警报组的解决说明中，以便您在确认警报之前就可以从 Slack 或 Grafana OnCall 中查看它们！&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/on-call-recap-3/incident-resolved.png"&gt;&lt;img alt="Grafana OnCall 的解决通知" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="Grafana OnCall 的解决通知" src="https://grafana.com/media/blog/on-call-recap-3/incident-resolved.png" /&gt;&lt;/noscript&gt;&lt;/a&gt;&lt;/figure&gt;&lt;blockquote&gt;&lt;p&gt;&lt;em&gt;注意：我们使从仪表板运行 Sift 变得更加容易，并扩展了它运行的检查类型。 &lt;a href="https://grafana.com/blog/2024/02/21/ai-powered-diagnostics-for-incident-response-new-sift-features-in-grafana-irm/"&gt;在这里了解更多信息&lt;/a&gt;。&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id="add-grafana-oncall-as-a-contact-point-to-grafana-alerting"&gt;添加 Grafana OnCall 作为 Grafana 警报的联系点&lt;/h2&gt;&lt;p&gt;通过改进 Grafana Alerting 中的联系点体验，我们使 Grafana OnCall 与&lt;a href="https://grafana.com/products/cloud/alerting/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana Alerting&lt;/a&gt;的连接变得更加容易。现在，您可以在联系点 UI 中看到各种 Grafana OnCall 集成，从而使您的团队更快地进行设置。如下图所示，只需转到 Grafana Alerting 左侧导航中的&lt;strong&gt;联系点&lt;/strong&gt;，然后单击&lt;strong&gt;+ 添加联系点，&lt;/strong&gt;为联系点创建名称，然后在令人兴奋的新 Grafana OnCall 集成之间进行选择。如果您选择现有的联系点，下拉菜单将自动填充可供选择的选项。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/on-call-recap-3/create-contact-point.png"&gt;&lt;img alt="创建联系点菜单" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="创建联系点菜单" src="https://grafana.com/media/blog/on-call-recap-3/create-contact-point.png" /&gt;&lt;/noscript&gt;&lt;/a&gt;&lt;/figure&gt;&lt;h2 id="easily-declare-an-incident-from-grafana-oncall"&gt;从 Grafana OnCall 轻松声明事件&lt;/h2&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt;&lt;a class="lightbox-link" href="https://grafana.com/media/blog/on-call-recap-3/incident-resolved-2.png"&gt;&lt;img alt="自动解决事件的解决通知" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="自动解决事件的解决通知" src="https://grafana.com/media/blog/on-call-recap-3/incident-resolved-2.png" /&gt;&lt;/noscript&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;您现在可以使用 Grafana OnCall 在 Grafana Incident 中声明事件，包括通过 Grafana OnCall 发出的 Slack 通知。 Grafana OnCall 警报组名称将自动用作事件名称。&lt;/p&gt;&lt;p&gt;我们继续投资，使从通知到声明、从仪表板和查询到事件协调的快速转变变得更加容易，以减少上下文切换。例如，您现在还可以轻松地从 Grafana 内的任何面板声明事件，从而缩短从调查到声明的时间。&lt;/p&gt;&lt;p&gt;大多数时候，工程师会查看多个仪表板，在某些情况下，在宣布事件之前会运行一些查询。现在，通过跨面板和 Grafana 可用的“声明事件”工作流程，您和您的团队可以更轻松地标准化事件响应工作流程。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/on-call-recap-3/request-rate.png"&gt;&lt;img alt="在 Grafana OnCall 中声明事件下拉选择" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="在 Grafana OnCall 中声明事件下拉选择" src="https://grafana.com/media/blog/on-call-recap-3/request-rate.png" /&gt;&lt;/noscript&gt;&lt;/a&gt;&lt;/figure&gt;&lt;h2 id="easily-add-responders-to-an-incident-via-grafana-oncall"&gt;通过 Grafana OnCall 轻松添加事件响应者&lt;/h2&gt;&lt;p&gt;您还可以&lt;a href="https://grafana.com/blog/2023/12/13/easily-page-participants-to-accelerate-incident-response-in-grafana-irm/?pg=blog&amp;amp;plcmt=body-txt"&gt;通过 Grafana OnCall 直接从活动事件中寻呼用户或团队&lt;/a&gt;。借助这一新功能，参与者可以访问他们在 Grafana 中看到的相同用户和团队列表，并通过结合使用 Grafana Incident 和 Grafana OnCall 更轻松地跨团队进行协调。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/on-call-recap-3/new-incident.png"&gt;&lt;img alt="新事件菜单" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="新事件菜单" src="https://grafana.com/media/blog/on-call-recap-3/new-incident.png" /&gt;&lt;/noscript&gt;&lt;/a&gt;&lt;/figure&gt;&lt;h2 id="learn-more-about-grafana-oncall"&gt;了解有关 Grafana OnCall 的更多信息&lt;/h2&gt;&lt;p&gt;这些只是 Grafana OnCall 最近的一些改进。如果您想了解更多信息，请查看我们的配套文章，了解我们为解决&lt;a href="https://grafana.com/blog/2023/08/31/a-better-grafana-oncall-web-based-scheduling-mobile-app-email-support/?pg=blog&amp;amp;plcmt=body-txt"&gt;用户体验&lt;/a&gt;和&lt;a href="https://grafana.com/blog/2023/09/18/a-better-grafana-oncall-delivering-on-features-for-users-at-scale/?pg=blog&amp;amp;plcmt=body-txt"&gt;大规模运营&lt;/a&gt;所做的更改。&lt;/p&gt;&lt;p&gt;您还可以查看我们的文档以获取更多信息，并观看我们&lt;a href="https://grafana.com/go/webinar/getting-started-with-grafana-incident-response-and-management-irm-and-slo/?pg=blog&amp;amp;plcmt=body-txt"&gt;在 Grafana Cloud 中使用 Grafana IRM 和 SLOS 进行事件管理的&lt;/a&gt;网络研讨会，以了解有关 Grafana OnCall 和更广泛的 Grafana IRM 产品的更多信息。&lt;/p&gt;&lt;p&gt; &lt;em&gt;&lt;a href="https://grafana.com/products/cloud/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana Cloud&lt;/a&gt;是开始使用指标、日志、跟踪和仪表板的最简单方法。我们最近在慷慨的永久免费套餐中添加了新功能，包括允许三个用户访问所有企业插件。另外，每个用例都有相应的计划。现在免费&lt;a href="https://grafana.com/auth/sign-up/create-user/?pg=blog&amp;amp;plcmt=body-txt"&gt;注册&lt;/a&gt;！&lt;/em&gt;&lt;/p&gt;</description><pubDate>Fri, 29 Mar 2024 00:00:00 GMT</pubDate><guid isPermaLink="true">https://grafana.com/blog/2024/03/29/a-better-grafana-oncall-seamless-workflows-with-the-rest-of-grafana-cloud/</guid></item><item><title>也许打电话给我：设计事件响应流程</title><link>https://grafana.com/blog/2024/03/28/call-me-maybe-designing-an-incident-response-process/</link><description>&lt;p&gt;嘿，我刚刚部署——这太疯狂了。但是服务器坏了，所以给我打电话，可以吗？&lt;/p&gt;&lt;p&gt;让您的服务随时可用是现代软件运营的黄金标准。实现这一目标的最简单方法就是&lt;em&gt;编写无错误的软件&lt;/em&gt;，但即使您达到了这个完全无法实现的目标 - 事情还是会发生！现代软件很少存在于真空中，并且通常依赖于大量的外部服务和库。特别是在云服务环境中，您无法控制堆栈的每个部分。最终，有些事情可能而且一定会出错。&lt;/p&gt;&lt;p&gt;为了解决这个问题，您需要一个定义明确的&lt;strong&gt;事件响应流程&lt;/strong&gt;，该流程是概述事件发生时应采取哪些步骤的文档。但如果你是这个世界的新手怎么办？您可能甚至不知道该问哪些问题以便在那一刻到来时做好准备。这就是这篇博文的由来。&lt;/p&gt;&lt;p&gt;当然，每个组织和架构都是不同的，因此我无法提供一刀切的解决方案。相反，这篇文章应该引导您走向正确的方向，并帮助您在事件发生之前、期间和之后提出正确的问题。&lt;/p&gt;&lt;h2 id="whats-an-incident"&gt;有什么事件吗？&lt;/h2&gt;&lt;p&gt;在开始经历不同的场景和挑战（技术和社会）之前，您需要弄清楚何时将某件事视为事件。&lt;/p&gt;&lt;p&gt;事件可以有多种形式。在开发事件响应流程时，一个好的起点是记录组织事件的构成。它可能看起来像这样：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;存在以下任一情况的生产系统存在问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;可能会对客户产生明显的影响&lt;/li&gt;&lt;li&gt;您需要让第二个团队/小队参与来解决问题&lt;/li&gt;&lt;li&gt;经过一个小时的集中分析，问题仍未解决&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;&lt;p&gt;该列表绝不是详尽无遗的。您可能需要排除某些条件或添加更多条件，具体取决于您的业务领域。财务影响也可能会影响您宣布事件的决定。&lt;/p&gt;&lt;p&gt;无论如何，您都希望避免出现这样的情况：应该在几个小时前宣布事件，而现在您正在处理事件本身，并组织从头开始重建时间线的开销。&lt;/p&gt;&lt;h3 id="how-do-we-know-we-have-an-incident"&gt;我们怎么知道发生了事件？&lt;/h3&gt;&lt;p&gt;处理事件的第一步是知道某些东西出现了问题。问题可以手动报告（例如，通过支持、团队成员或直接由客户报告），也可以通过&lt;a href="https://grafana.com/products/cloud/incident/?pg=blog&amp;amp;plcmt=body-txt"&gt;可观察性解决方案&lt;/a&gt;自动报告。无论您如何进行报告，您的首要任务应该是建立一个系统，让您尽快知道有什么事情发生。&lt;/p&gt;&lt;p&gt;警报系统可以配置为观察特定指标、日志或其他指标，并在特定指标违反规则时发出警报。&lt;/p&gt;&lt;p&gt;例如，一个简单的警报规则可以是：&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;如果超过 0.1% 的 HTTP 响应为 500 并持续至少五分钟，请提醒我们。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;在这里，我们用特定值指定条件（超过 0.1% 的 HTTP 响应是 500），并标记该条件成立的持续时间（至少五分钟）。需要该持续时间来避免单个、短暂的异常值发出不稳定的警报。&lt;/p&gt;&lt;p&gt;如果可以的话，您应该对违反服务级别目标 (SLO) 的行为发出警报。有关详细信息，请参阅&lt;a href="https://sre.google/workbook/alerting-on-slos/" rel="noopener noreferrer" target="_blank"&gt;Google SRE 手册的第 5 章&lt;/a&gt;。&lt;/p&gt;&lt;h4 id="manual-reporting"&gt;手动报告&lt;/h4&gt;&lt;p&gt;遗憾的是，警报系统永远无法捕获所有可能出错的事情。此时了解如何手动创建事件很有用。手动创建事件的另一个用例是需要保密处理的安全事件。许多&lt;a href="https://grafana.com/products/cloud/irm/?pg=blog&amp;amp;plcmt=body-txt"&gt;事件响应和管理 (IRM) 解决方案&lt;/a&gt;提供与消息传递工具的集成，从而简化了报告和创建事件。&lt;/p&gt;&lt;p&gt;手动报告事件时，请确保提供足够的信息并随时回答后续问题。&lt;/p&gt;&lt;h3 id="when-to-notify"&gt;什么时候通知？&lt;/h3&gt;&lt;p&gt;根据收到的警报类型，您可能需要执行不同的操作。这个过程称为&lt;strong&gt;路由&lt;/strong&gt;。在此阶段，将匹配警报元数据并确定初步严重性。&lt;/p&gt;&lt;p&gt;然后可以使用该严重性来确定我们是否想要发出警报以及如何发出警报。找到正确的平衡可能很棘手。如果不是绝对必要的话，您不想在半夜叫醒工程师，但您也不想冒潜在问题被忽视的风险。&lt;/p&gt;&lt;h4 id="severity-levels"&gt;严重程度&lt;/h4&gt;&lt;p&gt;对事件进行分类的有用框架是基于事件的&lt;strong&gt;严重性&lt;/strong&gt;。严重性应作为基本的优先级工具，并一目了然地显示事件的紧急程度。&lt;/p&gt;&lt;p&gt;不同紧急情况的通用定义可能如下所示：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;严重：&lt;/strong&gt;当出现以下任一情况时，紧急需要立即关注&lt;/p&gt;&lt;ul&gt;&lt;li&gt;系统已关闭且无法运行且没有可用的解决方法&lt;/li&gt;&lt;li&gt;全部或大部分数据面临丢失或损坏的重大风险&lt;/li&gt;&lt;li&gt;业务运营可能受到严重干扰&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;重大：&lt;/strong&gt;需要帮助的重大阻塞问题&lt;/p&gt;&lt;ul&gt;&lt;li&gt;尽管长期生产力可能会受到影响，但运营可以以有限的方式继续&lt;/li&gt;&lt;li&gt;重大里程碑、产品或客户面临风险&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;&lt;strong&gt;轻微：&lt;/strong&gt;可能会影响客户，但没有人被阻止&lt;/p&gt;&lt;ul&gt;&lt;li&gt;对运营和客户没有显着影响或仅有轻微影响&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;您可以在下面找到示例事件及其分类方式的表格：&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;strong&gt;事件&lt;/strong&gt;&lt;/th&gt;&lt;th&gt;&lt;strong&gt;严重性&lt;/strong&gt;&lt;/th&gt;&lt;th&gt;&lt;strong&gt;原因&lt;/strong&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;无法访问着陆页&lt;/td&gt;&lt;td&gt;批判的&lt;/td&gt;&lt;td&gt;用户无法再访问目标系统&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;搜索推荐不可用&lt;/td&gt;&lt;td&gt;主要的&lt;/td&gt;&lt;td&gt;核心功能仍然有效，但用户可能找不到他们想要的东西&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;用户的名字和姓氏被交换&lt;/td&gt;&lt;td&gt;严重/次要&lt;/td&gt;&lt;td&gt;根据受影响的系统，这可能是一个小问题（例如，它仅在您的个人资料上显示错误）或导致重大问题（例如，我们向错误的人开具发票）&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;这些例子还表明，利用有限的信息很难对事件进行分类。当新信息可用时，它可以改变事件的严重性。&lt;/p&gt;&lt;h3 id="who-to-notify"&gt;通知谁？&lt;/h3&gt;&lt;p&gt;这将是更棘手的问题之一，因为它需要考虑许多不同的方面：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;谁能解决这个问题？&lt;/li&gt;&lt;li&gt;谁有空？&lt;/li&gt;&lt;li&gt;他们醒了吗？&lt;/li&gt;&lt;li&gt;他们这个时候&lt;em&gt;可以&lt;/em&gt;工作吗？&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;为了以易于理解的方式存储此信息，您需要将人员&lt;strong&gt;分组&lt;/strong&gt;（谁可以解决此问题？）并为这些团队规划&lt;strong&gt;时间表&lt;/strong&gt;（谁有空？他们醒着吗？）。&lt;/p&gt;&lt;p&gt;在现代工程组织中，决定哪个团队可以处理该事件应该很简单：如果你构建它，你就维护它。根据您的组织布局，这也可能是一个运营团队。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;em&gt;提示：为新团队成员创建一份入职文档，概述严重性、分类、待命职责以及他们需要访问的位置。这可以极大地帮助新团队成员的入职。&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;h4 id="planning-a-schedule"&gt;规划时间表&lt;/h4&gt;&lt;p&gt;时间表定义了特定时间段内待命的人员。设计日程安排时，请记住以下几点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;持续时间：&lt;/strong&gt;连续几周待命可能会让人非常疲惫，但每天轮班也会导致头痛。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;可预测性&lt;/strong&gt;：工程师希望提前计划个人活动，并需要知道他们在那段时间是否待命。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;平衡：&lt;/strong&gt;这应该是不言而喻的，但要尽量将轮班平均分配给所有团队成员。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;法律限制：&lt;/strong&gt;不同国家对于待命时间和频率有不同的规定。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;如果您的团队分布在全球各地，您可能需要考虑&lt;em&gt;实行全天候&lt;/em&gt;轮换，即您仅在正常工作时间内随叫随到。对于规模较小、地理位置集中的团队来说，每周轮换是一个很好的起点。&lt;/p&gt;&lt;h4 id="what-does-it-mean-to-be-on-call"&gt;待命是什么意思？&lt;/h4&gt;&lt;p&gt;当您值班时，我们希望能够通过一些商定的沟通渠道与您联系。通常，这将是您手机上的应用程序，但也可能是物理寻呼机。当警报被触发时，您需要按照流程进行处理。这可能只是简单地确认警报（如果可以等待下一个工作日）或打开事件。&lt;/p&gt;&lt;p&gt;您应事先商定收到警报和确认警报（或开始处理警报）之间的时间，以便工程师可以相应地计划他们的一天。&lt;/p&gt;&lt;h3 id="how-to-notify"&gt;如何通知？&lt;/h3&gt;&lt;p&gt;让我们回顾一下！我们已经发出警报（自动或手动），以正确的严重程度将其发送给正确的团队，并确定此时向谁发出警报。下一个问题是：我们如何才能接触到他们？&lt;/p&gt;&lt;p&gt;这是&lt;strong&gt;升级链&lt;/strong&gt;和&lt;strong&gt;通知策略&lt;/strong&gt;的责任。他们继续通过通知和集成来发送警报。&lt;/p&gt;&lt;p&gt;升级链示例如下所示：&lt;/p&gt;&lt;blockquote&gt;&lt;ol&gt;&lt;li&gt;通知当前待命工程师&lt;/li&gt;&lt;li&gt;在 Slack 频道中发帖&lt;/li&gt;&lt;li&gt;等待20分钟&lt;/li&gt;&lt;li&gt;通知二级值班工程师&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p&gt;当通知工程师时，他们各自的通知策略将决定应该响起哪些铃声。这可能看起来像：&lt;/p&gt;&lt;blockquote&gt;&lt;ol&gt;&lt;li&gt;发送移动推送通知&lt;/li&gt;&lt;li&gt;发送电子邮件&lt;/li&gt;&lt;li&gt;等待五分钟&lt;/li&gt;&lt;li&gt;拨打我的号码&lt;/li&gt;&lt;/ol&gt;&lt;/blockquote&gt;&lt;p&gt;如果在任何时候警报得到确认，则将跳过其余步骤。&lt;/p&gt;&lt;h3 id="what-happens-when-i-get-an-alert"&gt;当我收到警报时会发生什么？&lt;/h3&gt;&lt;p&gt;如果您收到寻呼（或以任何其他方式收到通知），则由您根据所获得的信息来决定是否需要发生事件。如果您不确定，制造事件始终是最安全的选择。您可能不想创建事件的某些情况是可证明的误报、快速例行补救措施或由另一个当前活动的事件引起的。&lt;/p&gt;&lt;h2 id="how-to-handle-an-incident"&gt;发生事件如何处理？&lt;/h2&gt;&lt;p&gt;现在您已经知道何时以及如何声明事件，让我们仔细看看事件处理过程中不同角色和职责的示例框架。以下规则基于我们的内部 IRM 手册，也是我们用于支持&lt;a href="https://grafana.com/products/cloud/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana Cloud 的&lt;/a&gt;规则。虽然它们适合一般用途，但请务必始终考虑到您的组织环境并根据您认为合适的方式更改部分。&lt;/p&gt;&lt;h3 id="who-does-what"&gt;谁做了什么？&lt;/h3&gt;&lt;p&gt;当宣布事件时，我们有两个角色需要扮演：&lt;em&gt;指挥官&lt;/em&gt;和&lt;em&gt;调查员&lt;/em&gt;。默认情况下，当前待命的工程师将担任调查员，而辅助待命工程师则担任指挥官的角色。当然，如果某人有更深入的知识，他们可以自愿担任这些角色中的任何一个 - 即使在事件期间！唯一的要求是这种转移必须得到现任和新工程师的同意，以避免双方都认为对方目前正在处理该事件。&lt;/p&gt;&lt;h4 id="investigator"&gt;研究者&lt;/h4&gt;&lt;p&gt;调查员负责解决该事件。这看起来如何取决于所使用的技术、系统、经验和影响，因此没有明确的指导方针来指导我们做什么。如果您有操作手册，这些可能是一个不错的起点。运行手册是概述已知或预期问题的识别和解决方案（例如磁盘已满、证书未更新）的文档。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;em&gt;提示：在事件处理过程中，优先考虑缓解事件症状，而不是永久解决问题。目标是在最短的时间内减轻事件产生的影响，同时保留有助于调查的证据。&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;在处理该事件时，请确保尽快传达新的发现并留意您的情绪状态。如果您感到恐慌或不知所措，请向事件指挥官寻求更多支持。&lt;/p&gt;&lt;h4 id="commander"&gt;指挥官&lt;/h4&gt;&lt;p&gt;作为指挥官，你的工作就是&lt;em&gt;支持&lt;/em&gt;和&lt;em&gt;沟通&lt;/em&gt;。您的首要任务是为调查员提供他们需要的东西。这可以是访问系统、访问其他团队的人员或与外部供应商取得联系。&lt;/p&gt;&lt;p&gt;指挥官将事件的状态传达给其他团队（以及客户支持，如果适用），并帮助调查人员确定优先顺序。他们还可以提供调试想法和假设，但只能以不干涉的方式提供。另一项职责是提取调查人员发现的重要信息，以记录事件的进展。&lt;/p&gt;&lt;p&gt;与调查员一样，定期反省你的情绪状态。如果事情变得压力太大，请另一个人接任指挥官。&lt;/p&gt;&lt;h4 id="other-people"&gt;其他人&lt;/h4&gt;&lt;p&gt;有时，事件需要多个不同人的合作。如果您不参与某个事件，则假设您会在事件指挥官的要求下提供支持。宣布事件使事件指挥官有权指挥公司内任何级别的任何人员帮助解决事件。&lt;/p&gt;&lt;p&gt;调查员仍然是调查的所有者​​，其他相关人员应努力支持调查员。&lt;/p&gt;&lt;h2 id="what-happens-afterward"&gt;之后会发生什么？&lt;/h2&gt;&lt;p&gt;一旦面向用户的影响得到缓解，事件就可以被视为&lt;em&gt;已解决&lt;/em&gt;。然而，这并不意味着一切都是固定的，你可以忘记曾经发生过的事情。您还需要采取一些步骤，才能认为事件处理工作已经完成。&lt;/p&gt;&lt;h3 id="creating-a-post-incident-review"&gt;创建事件后审查&lt;/h3&gt;&lt;p&gt;作为事件指挥官，您的任务是创建事件后审查 (PIR) 文档。这方面的工作实际上可以在事件发生期间开始。 PIR 用于记录事件期间发生的情况以及解决方式。它还可以作为回顾，讨论哪些进展顺利，哪些出错，以及我们幸运的地方。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;em&gt;提示：如果由于误报而宣布事件或结果无效，则并不严格需要 PIR。然而，反思这一事件并了解如何避免将来在这方面花费资源仍然是有用的。&lt;/em&gt;&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt; PIR 旨在用于内部教育，并可作为未来事件的参考。如果您需要向客户或更广泛的公众传达该事件，请根据 PIR 创建单独的文档，并考虑到更新的目标受众。&lt;/p&gt;&lt;p&gt;要改进此工作流程，请在您选择的文档存储解决方案（Google Docs、Confluence 或 Git）中创建模板。您可以在我们新发布的&lt;a href="https://github.com/grafana/act-kit" rel="noopener noreferrer" target="_blank"&gt;act-kit&lt;/a&gt;中找到相关示例。复制现有模板时，请花点时间思考标题和内容，以确保它适合您。&lt;/p&gt;&lt;h3 id="creating-follow-up-tasks"&gt;创建后续任务&lt;/h3&gt;&lt;p&gt;由于调查人员的目标是修复症状，这通常会导致应用临时修复来尽快解决事件。软件界有句老话：“没有什么比临时修复更永久的了”。解决事件后立即创建后续任务非常重要。此任务是修复错误、更改配置还是从头开始重写整个应用程序取决于事件的根本原因。&lt;/p&gt;&lt;h2 id="cheat-sheet"&gt;备忘单&lt;/h2&gt;&lt;p&gt;到目前为止，我们已经介绍了很多内容。为了帮助您在制定事件响应计划之前整理思绪，我创建了这份备忘单，您可以将其用作未来的快速参考。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/call-me-maybe/OnCall-IRM-Cheat-Sheet-Portrait%282%29.png"&gt;&lt;img alt="" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="" src="https://grafana.com/media/blog/call-me-maybe/OnCall-IRM-Cheat-Sheet-Portrait%282%29.png" /&gt;&lt;/noscript&gt;&lt;/a&gt;&lt;/figure&gt;&lt;h2 id="what-else"&gt;还有什么？&lt;/h2&gt;&lt;p&gt;虽然这篇文章应该可以帮助您在设置 on-call 或 IRM 流程时提出正确的问题，但可能性是无限的。也许您想&lt;a href="https://grafana.com/blog/2022/08/29/get-started-with-grafana-oncall-and-terraform/?pg=blog&amp;amp;plcmt=body-txt"&gt;以代码的形式管理待命轮换&lt;/a&gt;、探索&lt;a href="https://grafana.com/docs/grafana-cloud/alerting-and-irm/incident/configure/integrations/configure-slack/?pg=blog&amp;amp;plcmt=body-txt"&gt;ChatOps&lt;/a&gt;或将创建的事件连接到状态页面。&lt;/p&gt;&lt;p&gt;无论您的旅程将带您走向何方：请注意什么最符合您自己、您的团队以及您的组织的最大利益，这样您就会走上正确的道路，找到适合您的工具和技术。&lt;/p&gt;&lt;h3 id="simplify-incident-response-with-grafana-irm"&gt;使用 Grafana IRM 简化事件响应&lt;/h3&gt;&lt;p&gt;虽然可靠的事件响应流程是您团队的重要指导，但您不必单独执行文档中概述的所有操作。 &lt;a href="https://grafana.com/products/cloud/irm/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana IRM&lt;/a&gt;提供了一系列旨在简化和促进事件响应和待命管理的功能。这包括触发事件、自动化警报路由和升级链以及简化待命调度的功能。&lt;/p&gt;&lt;p&gt; &lt;em&gt;&lt;a href="https://grafana.com/products/cloud/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana Cloud&lt;/a&gt;是开始使用指标、日志、跟踪、仪表板等的最简单方法。我们为每个用例提供慷慨的永久免费套餐和计划。&lt;a href="https://grafana.com/auth/sign-up/create-user/?pg=blog&amp;amp;plcmt=body-txt"&gt;现在免费注册&lt;/a&gt;！&lt;/em&gt;&lt;/p&gt;</description><pubDate>Thu, 28 Mar 2024 00:00:00 GMT</pubDate><guid isPermaLink="true">https://grafana.com/blog/2024/03/28/call-me-maybe-designing-an-incident-response-process/</guid></item><item><title>如何使用 ChatGPT 视觉 API 和 Grafana Cloud Metrics 自动执行图像分析</title><link>https://grafana.com/blog/2024/03/27/how-to-automate-image-analysis-with-the-chatgpt-vision-api-and-grafana-cloud-metrics/</link><description>&lt;p&gt;OpenAI 的 ChatGPT 具有处理自然语言、推理用户提示并生成类人对话作为响应的非凡能力。然而，俗话说，“一图胜千言”——也许更重要的成就是 ChatGPT 能够理解和回答有关图像的问题。&lt;/p&gt;&lt;p&gt;在这篇文章中，我们将通过一个示例介绍如何使用 ChatGPT 的视觉功能（正式称为&lt;a href="https://platform.openai.com/docs/guides/vision" rel="noopener noreferrer" target="_blank"&gt;GPT-4 with Vision（或 GPT-4V））&lt;/a&gt;来识别图像中的对象，然后在 Grafana Cloud 中自动将结果绘制为指标。在我们的示例中，我们将使用来自美国国家公园管理局的公开图像，但最终，您将能够利用计算机视觉技术和&lt;a href="https://grafana.com/docs/grafana-cloud/send-data/metrics/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana Cloud Metrics&lt;/a&gt;来实现您自己的独特用例。&lt;/p&gt;&lt;h2 id="example-count-the-number-of-vehicles-entering-yellowstone"&gt;示例：统计进入黄石公园的车辆数量&lt;/h2&gt;&lt;p&gt;以下示例说明了如何自动化图像分析过程——这是一项以前由人类执行的耗时且手动的任务。基本上，我们将拥有一个触手可及的人工智能代理转变为情报分析师。&lt;/p&gt;&lt;p&gt;让我们开始吧。&lt;/p&gt;&lt;h3 id="task"&gt;任务&lt;/h3&gt;&lt;p&gt;我们想要统计等待从北门（通常称为罗斯福拱门）进入黄石国家公园的车辆数量。然后，我们将输出保存在度量时间序列中，我们可以使用 Grafana Cloud 在图表中查看。&lt;/p&gt;&lt;h3 id="prerequisites"&gt;先决条件&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;Ruby 初级编程技能&lt;/li&gt;&lt;li&gt;&lt;a href="https://grafana.com/auth/sign-up/create-user/?pg=blog&amp;amp;plcmt=body-txt"&gt;免费 Grafana 云帐户&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="inputs-provided"&gt;提供的输入&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;供 AI 代理匹配的示例输入图像&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://images.unsplash.com/photo-1616549972169-0a0d961c9905" rel="noopener noreferrer" target="_blank"&gt;车辆1&lt;/a&gt;&lt;/li&gt;&lt;li&gt; &lt;a href="https://images.unsplash.com/photo-1544601640-b256c49a192d" rel="noopener noreferrer" target="_blank"&gt;车辆2&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;随时间刷新的待检查图像&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://www.nps.gov/webcams-yell/mammoth_arch.jpg" rel="noopener noreferrer" target="_blank"&gt;黄石北门安全摄像头动态&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="process"&gt;过程&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;第 1 步：&lt;/strong&gt;初始化您的 OpenAI API 客户端。&lt;/p&gt;&lt;div class="code-snippet code-snippet__mini"&gt;&lt;div class="lang-toolbar__mini"&gt; &lt;span class="code-clipboard"&gt;&lt;button&gt;&lt;img alt="将代码复制到剪贴板" class="code-clipboard__icon" height="13" src="https://grafana.com/media/images/icons/icon-copy-small-2.svg" width="14" /&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="code-snippet code-snippet__border"&gt;&lt;pre&gt;&lt;code class="language-none"&gt;@openai_client = OpenAI::Client.new( access_token: ENV[&amp;quot;OPENAI_API_KEY&amp;quot;], organization_id: ENV[&amp;quot;OPENAI_API_ORGANIZATION_ID&amp;quot;] )&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;第 2 步：&lt;/strong&gt;准备您的 ChatGPT 视觉提示。这些提示告诉 ChatGPT 如何处理所提供的图像。&lt;/p&gt;&lt;p&gt;请注意，我们提供了两张示例车辆的图像，希望 ChatGPT 能够识别它们。我们的第三张图像来自黄石罗斯福拱门入口处的安全摄像头。随着新的入口图像可用，第三张图像将每隔几分钟更新一次。最后，我们向 OpenAI 指定一个包含在机器可读 JSON 对象中的示例输出，其键/值结果为&lt;code&gt;&amp;quot;matches&amp;quot;&lt;/code&gt; 。&lt;/p&gt;&lt;div class="code-snippet code-snippet__mini"&gt;&lt;div class="lang-toolbar__mini"&gt; &lt;span class="code-clipboard"&gt;&lt;button&gt;&lt;img alt="将代码复制到剪贴板" class="code-clipboard__icon" height="13" src="https://grafana.com/media/images/icons/icon-copy-small-2.svg" width="14" /&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="code-snippet code-snippet__border"&gt;&lt;pre&gt;&lt;code class="language-none"&gt;system_context = &amp;quot;You are an expert image analyst capable of identifying patterns between images. You count a match when you find an object in the third image that looks like a car or truck from the first or second images. Only count a match if you&amp;#39;re very confident a match exists.&amp;quot; user_messages = [ { &amp;quot;type&amp;quot;: &amp;quot;text&amp;quot;, &amp;quot;text&amp;quot;: &amp;quot;How many times does the object from the first or second image appear in the third image? Be precise.&amp;quot;}, { &amp;quot;type&amp;quot;: &amp;quot;image_url&amp;quot;, &amp;quot;image_url&amp;quot;: { &amp;quot;url&amp;quot;: &amp;quot;https://images.unsplash.com/photo-1616549972169-0a0d961c9905&amp;quot;, }, }, { &amp;quot;type&amp;quot;: &amp;quot;image_url&amp;quot;, &amp;quot;image_url&amp;quot;: { &amp;quot;url&amp;quot;: &amp;quot;https://images.unsplash.com/photo-1544601640-b256c49a192d&amp;quot;, }, }, { &amp;quot;type&amp;quot;: &amp;quot;image_url&amp;quot;, &amp;quot;image_url&amp;quot;: { &amp;quot;url&amp;quot;: &amp;quot;https://www.nps.gov/webcams-yell/mammoth_arch.jpg&amp;quot;, }, } ] example_output = &amp;#39; Example response object: { &amp;quot;matches&amp;quot;: integer, } &amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;步骤 3：&lt;/strong&gt;调用 ChatGPT 视觉 API： &lt;code&gt;gpt-4-vision-preview&lt;/code&gt; 。&lt;/p&gt;&lt;div class="code-snippet code-snippet__mini"&gt;&lt;div class="lang-toolbar__mini"&gt; &lt;span class="code-clipboard"&gt;&lt;button&gt;&lt;img alt="将代码复制到剪贴板" class="code-clipboard__icon" height="13" src="https://grafana.com/media/images/icons/icon-copy-small-2.svg" width="14" /&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="code-snippet code-snippet__border"&gt;&lt;pre&gt;&lt;code class="language-none"&gt;begin response = @openai_client.chat( parameters: { model: &amp;quot;gpt-4-vision-preview&amp;quot;, messages: [ { role: &amp;quot;system&amp;quot;, content: system_context }, { role: &amp;quot;system&amp;quot;, content: example_output }, { role: &amp;quot;user&amp;quot;, content: user_messages } ], temperature: 0.4, max_tokens: 100 }) rescue =&amp;gt; err logger.fatal(err) return else logger.info(&amp;quot;OpenAI API response received and successfully processed&amp;quot;) logger.info(&amp;quot;Response:\n#{response}&amp;quot;) end&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;步骤 4：&lt;/strong&gt;保存来自 OpenAI 的响应，该响应应该是一个具有一对键/值对的 JSON 对象，例如 { &lt;code&gt;“matches”: integer&lt;/code&gt; }。请务必查看示例提示输入图像以验证 ChatGPT 结果的准确性。&lt;/p&gt;&lt;div class="code-snippet code-snippet__mini"&gt;&lt;div class="lang-toolbar__mini"&gt; &lt;span class="code-clipboard"&gt;&lt;button&gt;&lt;img alt="将代码复制到剪贴板" class="code-clipboard__icon" height="13" src="https://grafana.com/media/images/icons/icon-copy-small-2.svg" width="14" /&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="code-snippet code-snippet__border"&gt;&lt;pre&gt;&lt;code class="language-none"&gt;hash_results = {} hash_results = JSON.parse(response.dig(&amp;quot;choices&amp;quot;, 0, &amp;quot;message&amp;quot;, &amp;quot;content&amp;quot;))&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;步骤5：&lt;/strong&gt;将OpenAI对样本图像检查的匹配结果推送到Grafana Cloud Metrics。&lt;/p&gt;&lt;p&gt;我们使用下面的&lt;a href="https://grafana.com/docs/grafana-cloud/send-data/metrics/metrics-influxdb/push-from-telegraf/?pg=blog&amp;amp;plcmt=body-txt/#pushing-from-applications-directly"&gt;Influx Line Protocol&lt;/a&gt;格式一次写入一个指标，由 Grafana Cloud 的后端转换为 Prometheus 指标。请注意，我们提供了指标名称和标签约定，以便您可以从这个示例进行扩展，以跟踪来自单个图表中多个入口的指标。您可以在 Grafana Cloud 门户中找到端点 URL 以及所需的指标写入凭据。&lt;/p&gt;&lt;div class="code-snippet code-snippet__mini"&gt;&lt;div class="lang-toolbar__mini"&gt; &lt;span class="code-clipboard"&gt;&lt;button&gt;&lt;img alt="将代码复制到剪贴板" class="code-clipboard__icon" height="13" src="https://grafana.com/media/images/icons/icon-copy-small-2.svg" width="14" /&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="code-snippet code-snippet__border"&gt;&lt;pre&gt;&lt;code class="language-none"&gt;# # Save metric in the Influx Line Protocol format # metrics_payload = &amp;quot;nps_entrance,park=yellowstone vehicles=#{hash_results[&amp;#39;matches&amp;#39;]}&amp;quot; # # Push metric to Grafana Cloud using the Influx Line Protocol # begin uri = URI.parse(ENV[&amp;#39;GRAFANA_CLOUD_METRICS_INFLUX_PROXY_ENDPOINT&amp;#39;]) response = Net::HTTP.start(uri.host, uri.port, use_ssl: true) do |client| request = Net::HTTP::Post.new(uri.path) request.body = metrics_payload request[&amp;quot;Authorization&amp;quot;] = &amp;quot;Basic #{@grafana_base64_encoded_auth_token}&amp;quot; request[&amp;quot;Content-Type&amp;quot;] = &amp;quot;text/plain&amp;quot; client.request(request) end rescue =&amp;gt; err logger.fatal(err) return else logger.info &amp;#39;Grafana Cloud response:&amp;#39; logger.info response.code logger.info &amp;#39;&amp;#39; return end&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;第 6 步：&lt;/strong&gt;访问您的 Grafana Cloud 实例以绘制随时间变化的指标图表。我们建议首先使用&lt;a href="https://grafana.com/docs/grafana/latest/explore/?pg=blog&amp;amp;plcmt=body-txt"&gt;探索页面&lt;/a&gt;，然后从下拉列表中选择示例指标。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/chatgpt_grafana_cloud_metrics/chatgpt_grafana_cloud_metrics_explore_view.png"&gt;&lt;img alt="Grafana Cloud 中的探索视图的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="Grafana Cloud 中的探索视图的屏幕截图。" src="https://grafana.com/media/blog/chatgpt_grafana_cloud_metrics/chatgpt_grafana_cloud_metrics_explore_view.png" /&gt;&lt;/noscript&gt;&lt;/a&gt;&lt;/figure&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/chatgpt_grafana_cloud_metrics/chatgpt_grafana_cloud_metrics_line_graph.png"&gt;&lt;img alt="Grafana Cloud Metrics 中的折线图的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="Grafana Cloud Metrics 中的折线图的屏幕截图。" src="https://grafana.com/media/blog/chatgpt_grafana_cloud_metrics/chatgpt_grafana_cloud_metrics_line_graph.png" /&gt;&lt;/noscript&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;要记录长时间内的车辆匹配数量，我们建议将此程序设置为在摄像头刷新时每 3-5 分钟执行一次。&lt;/p&gt;&lt;p&gt;就是这样！有关使用 ChatGPT 视觉功能和 Grafana Cloud Metrics 的此示例的完整代码版本，请访问以下&lt;a href="https://gist.github.com/jmarbach/a3acab424770c7fba5a5696ef81faaf1" rel="noopener noreferrer" target="_blank"&gt;GitHub Gist&lt;/a&gt; 。如果您想更进一步，监控 OpenAI 脚本的成本和资源使用情况，请查看我们的&lt;a href="https://grafana.com/blog/2023/11/02/monitor-your-openai-usage-with-grafana-cloud/"&gt;OpenAI 集成&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;如果您有疑问或遇到困难，请随时在我们的&lt;a href="https://community.grafana.com/" rel="noopener noreferrer" target="_blank"&gt;社区论坛&lt;/a&gt;中寻求帮助或&lt;a href="https://grafana.com/auth/sign-in"&gt;联系我们的支持团队&lt;/a&gt;，我们将很乐意为您提供帮助。&lt;/p&gt;&lt;p&gt; &lt;em&gt;&lt;a href="https://grafana.com/products/cloud/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana Cloud&lt;/a&gt;是开始使用指标、日志、跟踪、仪表板等的最简单方法。我们为每个用例提供慷慨的永久免费套餐和计划。&lt;a href="https://grafana.com/auth/sign-up/create-user/?pg=blog&amp;amp;plcmt=body-txt"&gt;现在免费注册&lt;/a&gt;！&lt;/em&gt;&lt;/p&gt;</description><pubDate>Wed, 27 Mar 2024 11:07:00 GMT</pubDate><guid isPermaLink="true">https://grafana.com/blog/2024/03/27/how-to-automate-image-analysis-with-the-chatgpt-vision-api-and-grafana-cloud-metrics/</guid></item><item><title>CI/CD 可观察性：从 CD 管道中提取 DORA 指标</title><link>https://grafana.com/blog/2024/03/26/ci/cd-observability-extracting-dora-metrics-from-a-cd-pipeline/</link><description>&lt;p&gt;去年 11 月，Dimitris 和 Giordano Ricci 撰写了一篇关于&lt;a href="https://grafana.com/blog/2023/11/20/ci-cd-observability-via-opentelemetry-at-grafana-labs/?pg=blog&amp;amp;plcmt=body-txt"&gt;CI/CD 可观察性的&lt;/a&gt;博客文章，探讨了提取跟踪和指标的方法，以便更好地了解 CI/CD 系统内部可能出现的问题。这篇文章的重点是从持续集成 (CI) 系统中获取数据，它确实引起了社区的共鸣。&lt;/p&gt;&lt;p&gt;基于这项工作，Dimitris、Horst 和 Zack Zehring 作为&lt;a href="https://grafana.com/blog/2024/03/01/grafana-labs-hackathon-projects-where-are-they-now/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana Labs 最新黑客马拉松&lt;/a&gt;的一部分，开始探索如何将该方法扩展到 CI 领域之外并进入持续交付 (CD) 领域。我们这里的重点是寻找从一些内部服务的 CD 工作流程中提取 DevOps 研究和评估 (DORA) 指标的方法。&lt;/p&gt;&lt;h2 id="the-system-under-observation"&gt;被观察系统&lt;/h2&gt;&lt;p&gt;为了将这一切放在正确的上下文中，让我们快速浏览一下我们想要监视的部署。我们的主要目标是探索各种方法并创建获取 DORA 指标的概念验证。这意味着我们希望保持测试用例简单：具有 CI 管道的单个服务，在默认分支上进行新提交时生成 Docker 映像。构建镜像后，会在&lt;a href="https://argoproj.github.io/workflows/?pg=blog&amp;amp;plcmt=body-txt" rel="noopener noreferrer" target="_blank"&gt;Argo Workflows&lt;/a&gt;中创建一个工作流程，将镜像推送到临时环境中。执行相关测试后，需要手动批准该工作流程才能继续并将相同的 Docker 映像推送到生产环境中。&lt;/p&gt;&lt;p&gt;虽然此工作流程会执行一些基本的运行状况检查，但部署始终存在导致中断的风险。因此，我们还通过&lt;a href="https://grafana.com/products/cloud/incident/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana 事件&lt;/a&gt;跟踪任何此类事件，人们可以在其中协作以使服务恢复在线。&lt;/p&gt;&lt;h2 id="why-are-dora-metrics-interesting"&gt;为什么 DORA 指标很有趣？&lt;/h2&gt;&lt;p&gt;如果您正在操作 CI/CD 管道（如上面提到的工作流程），您想知道它们的执行情况。将更改投入生产需要多长时间？我们如何处理停电？我们多久引入一次导致失败的变更？ DORA 指标已发展成为行业标准，可帮助回答这些问题并确定组织内软件交付的有效性。它们大致分为三个重点领域：&lt;/p&gt;&lt;h3 id="velocity"&gt;速度&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;部署频率：&lt;/strong&gt;这是一个更广泛的指标，使我们能够衡量部署频率。如果我们经常部署，则表明我们可以快速为最终用户带来新功能或修复。通常认为部署频率高是有利的，因为这通常表明可交付成果较小，其中包含的问题也较少。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;更改的平均交付时间：&lt;/strong&gt;与部署频率类​​似，我们希望快速向最终用户提供新功能和修复。该指标帮助我们确定特定更改（或提交）通过各种流程一直到达生产环境平均需要多长时间。这里的目标是缩短交货时间。&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="stability"&gt;稳定&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;更改失败率：&lt;/strong&gt;这是指生产环境的部署导致“失败”的百分比。简而言之，这告诉我们更新导致实际问题的频率。变更失败率高意味着用户满意度较低。该指标帮助我们识别部署中的薄弱点，以便我们可以在它们成为真正的问题之前主动采取行动。低变更失败率意味着我们的团队在部署前做好了验证工作，确保了更流畅的用户体验，并促进了我们平台/产品的总体持续改进。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;平均恢复时间：&lt;/strong&gt;与变更失败率类似，它衡量团队从生产故障中恢复的速度。这很重要，因为解决问题的速度越快，烧钱的次数就越少，对客户的影响也就越小。与此同时，没有人喜欢等待他们的服务重新上线。该指标中的一个小值会让您的用户满意，但还不止于此。它还让 IC 和管理人员感到高兴，因为他们知道缓解问题比以往任何时候都容易。当然，所有这一切都取决于良好的文档和在问题影响用户之前主动解决问题的方法。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;第三个重点领域是&lt;em&gt;可靠性&lt;/em&gt;，它广泛涵盖服务的各个操作方面，超出了部署本身。这些指标与&lt;a href="https://grafana.com/blog/2022/04/18/service-level-objectives-how-slos-have-changed-the-business-of-observability/?pg=blog&amp;amp;plcmt=body-txt"&gt;服务级别目标&lt;/a&gt;(SLO) 密切相关，确保系统始终满足定义的性能期望。因此，我们宣布它超出了我们的黑客马拉松项目的范围。&lt;/p&gt;&lt;h2 id="what-we-did-to-get-the-data"&gt;我们做了什么来获取数据&lt;/h2&gt;&lt;p&gt;为了获取这些指标，我们创建了从 Argo Workflows 和 Grafana Incident 一直到&lt;a href="https://grafana.com/oss/tempo/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana Tempo&lt;/a&gt; （用于跟踪存储）和&lt;a href="https://grafana.com/oss/mimir/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana Mimir&lt;/a&gt; （用于指标存储）的数据管道：&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/cd-observability-dora-metrics/cd-workflow-v2.png"&gt;&lt;img
class="lazyload "
data-src="/media/blog/cd-observability-dora-metrics/cd-workflow-v2.png"data-srcset="/media/blog/cd-observability-dora-metrics/cd-workflow-v2.png?w=320 320w, /media/blog/cd-observability-dora-metrics/cd-workflow-v2.png?w=550 550w, /media/blog/cd-observability-dora-metrics/cd-workflow-v2.png?w=750 750w, /media/blog/cd-observability-dora-metrics/cd-workflow-v2.png?w=900 900w, /media/blog/cd-observability-dora-metrics/cd-workflow-v2.png?w=1040 1040w, /media/blog/cd-observability-dora-metrics/cd-workflow-v2.png?w=1240 1240w, /media/blog/cd-observability-dora-metrics/cd-workflow-v2.png?w=1920 1920w"
data-sizes="auto"alt="用于提取 DORA 指标的 CD 工作流程"
width="990"
height="404"
/&gt; &lt;noscript&gt;&lt;img
src="/media/blog/cd-observability-dora-metrics/cd-workflow-v2.png"
alt="用于提取 DORA 指标的 CD 工作流程"
width="990"
height="404"
/&gt;&lt;/noscript&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;为了获取特定于工作流的指标，我们创建了一个小型 Kubernetes 控制器/通知程序，称为“Argo Workflows OTEL 导出器”，用于监视 Argo Workflows 管理的资源的更改并提取指标和跟踪数据。&lt;/p&gt;&lt;p&gt;为了获取与事件相关的数据，我们为 Grafana Incident 创建了一个 Webhook 接收器，它也可以推送指标。&lt;/p&gt;&lt;p&gt;然后，两个数据流都收集在&lt;a href="https://github.com/open-telemetry/opentelemetry-collector-contrib" target="_blank" rel="noopener noreferrer"&gt;otel-collector&lt;/a&gt;实例中，这使我们能够从收集的跟踪中提取更多指标，而无需在 Argo Workflows OTEL 导出器中放入太多逻辑。&lt;/p&gt;&lt;p&gt;最后，酒店收集器将指标和跟踪分别输入 Mimir 和 Tempo，以便它们可以在 Grafana 实例中可视化。&lt;/p&gt;&lt;p&gt;在以下部分中，我们将进一步详细介绍这些组件如何帮助我们实现特定指标。&lt;/p&gt;&lt;h3 id="dora-metrics-velocity"&gt; DORA 指标：速度&lt;/h3&gt;&lt;p&gt;速度指标都是关于部署过程的，重点关注特定代码到达生产环境所需的时间。因此，我们实现了一个小型 Kubernetes informer，它可以监视 Argo Workflows 创建的工作流资源，并在完成时从中生成 OTEL 指标和跟踪。&lt;/p&gt;&lt;p&gt;在此类别中列出的两个指标中，&lt;strong&gt;部署频率&lt;/strong&gt;更容易提取：我们所要做的就是找出哪些工作流资源直接涉及将工件推向生产并捕获在特定时间范围内运行的数量。以下 PromQL 查询在很大程度上执行此操作：&lt;/p&gt;&lt;div class="code-snippet code-snippet__mini"&gt;&lt;div class="lang-toolbar__mini"&gt; &lt;span class="code-clipboard"&gt;&lt;button x-data="app_code_snippet()" x-init="init()" @click="copy()"&gt;&lt;img class="code-clipboard__icon" src="/media/images/icons/icon-copy-small-2.svg" alt="将代码复制到剪贴板" width="14" height="13"&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="code-snippet code-snippet__border"&gt;&lt;pre data-expanded="false"&gt; &lt;code class="language-none"&gt;sum(cd_argoworkflows_count_total{workflow_group=&amp;quot;backstage&amp;quot;}) - min(cd_argoworkflows_count_total{workflow_group=&amp;quot;backstage&amp;quot;} offset $__range)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;&lt;strong&gt;变更的平均交付时间&lt;/strong&gt;有点棘手。部署管道通常不知道任何有关特定更改的信息。它所关心的只是获取工件（例如，Docker 映像），更新生产环境的配置以使用该映像，并等待部署成功。为了解决这个问题，我们将来自 GitHub 的附加元数据包含到部署工作流程中，其中包含（除其他外）相关提交的日期。然后，我们计算从创建提交到工作流程完成的时间，并将结果推送到给定项目的交付时间的直方图中，并使用如下所示的查询：&lt;/p&gt;&lt;div class="code-snippet code-snippet__mini"&gt;&lt;div class="lang-toolbar__mini"&gt; &lt;span class="code-clipboard"&gt;&lt;button x-data="app_code_snippet()" x-init="init()" @click="copy()"&gt;&lt;img class="code-clipboard__icon" src="/media/images/icons/icon-copy-small-2.svg" alt="将代码复制到剪贴板" width="14" height="13"&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="code-snippet code-snippet__border"&gt;&lt;pre data-expanded="false"&gt; &lt;code class="language-none"&gt;cd_argoworkflows_leadtime_sum{workflow_group=&amp;quot;backstage&amp;quot;} / cd_argoworkflows_leadtime_count{workflow_group=&amp;quot;backstage&amp;quot;}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;&lt;br /&gt;这两个只是纯粹的指标，但我们还希望有一个更详细的数据集可用于后处理。为此，Kubernetes informer 还为每个已完成的工作流资源生成了跟踪，其中不仅包括有关工作流的信息，还包括有关每个执行步骤的计时信息。与指标类似，这些跟踪被转发到我们的中央 otel-collector 实例，在那里它们被处理并用于使用&lt;a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/blob/main/connector/spanmetricsconnector/README.md" target="_blank" rel="noopener noreferrer"&gt;spanmetrics 连接器&lt;/a&gt;生成一些附加指标。最后，otel-collector 将原始跟踪、原始指标和派生指标发送到我们的 Tempo 和 Mimir 实例，以便它们可以在仪表板内呈现： &lt;/p&gt;&lt;figure
class="figure-wrapper figure-wrapper__lightbox w-100p "
style="max-width: 100%;"
itemprop="associatedMedia"
itemscope=""
itemtype="http://schema.org/ImageObject"
&gt; &lt;a
class="lightbox-link captioned"
href="/media/blog/cd-observability-dora-metrics/deployment-frequency.png"
itemprop="contentUrl"
&gt;&lt;img
class="lazyload mb-0"
data-src="/media/blog/cd-observability-dora-metrics/deployment-frequency.png"data-srcset="/media/blog/cd-observability-dora-metrics/deployment-frequency.png?w=320 320w, /media/blog/cd-observability-dora-metrics/deployment-frequency.png?w=550 550w, /media/blog/cd-observability-dora-metrics/deployment-frequency.png?w=750 750w, /media/blog/cd-observability-dora-metrics/deployment-frequency.png?w=900 900w, /media/blog/cd-observability-dora-metrics/deployment-frequency.png?w=1040 1040w, /media/blog/cd-observability-dora-metrics/deployment-frequency.png?w=1240 1240w, /media/blog/cd-observability-dora-metrics/deployment-frequency.png?w=1920 1920w"
data-sizes="auto"alt="Example velocity metrics as shown on a Grafana dashboard"
width="1558"
height="1368"
title="*Grafana 仪表板上显示的速度指标示例*"
/&gt; &lt;noscript&gt;&lt;img
src="/media/blog/cd-observability-dora-metrics/deployment-frequency.png"
alt="Example velocity metrics as shown on a Grafana dashboard"
width="1558"
height="1368"
title="*Grafana 仪表板上显示的速度指标示例*"
/&gt;&lt;/noscript&gt;&lt;figcaption class="w-100p caption mb-1 text-gray-13 "&gt; &lt;em&gt;Grafana 仪表板上显示的速度指标示例&lt;/em&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;仪表板在简单的值面板中显示数据，突出显示给定时间段内跟踪的工作流程数量。此外，我们认为提供实际工作流程跟踪的链接会很有用，您可以在下面找到一个示例。至于更改的提前时间，我们在仪表板中显示了平均值以及 0.9 分位数，以便更好地注意到异常值。请注意，屏幕截图中的值只是从各种测试运行中收集的示例。 &lt;/p&gt;&lt;figure
class="figure-wrapper figure-wrapper__lightbox w-100p "
style="max-width: 100%;"
itemprop="associatedMedia"
itemscope=""
itemtype="http://schema.org/ImageObject"
&gt; &lt;a
class="lightbox-link captioned"
href="/media/blog/cd-observability-dora-metrics/argo-worfklows-otel-exporter.png"
itemprop="contentUrl"
&gt;&lt;img
class="lazyload mb-0"
data-src="/media/blog/cd-observability-dora-metrics/argo-worfklows-otel-exporter.png"data-srcset="/media/blog/cd-observability-dora-metrics/argo-worfklows-otel-exporter.png?w=320 320w, /media/blog/cd-observability-dora-metrics/argo-worfklows-otel-exporter.png?w=550 550w, /media/blog/cd-observability-dora-metrics/argo-worfklows-otel-exporter.png?w=750 750w, /media/blog/cd-observability-dora-metrics/argo-worfklows-otel-exporter.png?w=900 900w, /media/blog/cd-observability-dora-metrics/argo-worfklows-otel-exporter.png?w=1040 1040w, /media/blog/cd-observability-dora-metrics/argo-worfklows-otel-exporter.png?w=1240 1240w, /media/blog/cd-observability-dora-metrics/argo-worfklows-otel-exporter.png?w=1920 1920w"
data-sizes="auto"alt="A sample trace covering a single Workflow"
width="2000"
height="1144"
title="*覆盖单个工作流程的示例跟踪*"
/&gt; &lt;noscript&gt;&lt;img
src="/media/blog/cd-observability-dora-metrics/argo-worfklows-otel-exporter.png"
alt="A sample trace covering a single Workflow"
width="2000"
height="1144"
title="*覆盖单个工作流程的示例跟踪*"
/&gt;&lt;/noscript&gt;&lt;figcaption class="w-100p caption mb-1 text-gray-13 "&gt;&lt;em&gt;覆盖单个工作流程的示例跟踪&lt;/em&gt;&lt;/a&gt;&lt;/figure&gt;&lt;h3 id="dora-metrics-stability"&gt;DORA 指标：稳定性&lt;/h3&gt;&lt;p&gt;为了计算我们的稳定性指标，我们与&lt;a href="/products/cloud/incident/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana Incident&lt;/a&gt;集成。这使我们能够根据生产环境中发生的实时中断引起的真实事件来计算指标。我们通过以下方式实现了这一点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;创建 Grafana Incident 指标收集器，用于侦听来自 Grafana Incident 的特定事件的 Webhooks。&lt;/li&gt;&lt;li&gt;收到 Webhook 后，会使用 GRPC 服务生成指标并将其推送到 OpenTelemetry 接收器。&lt;/li&gt;&lt;li&gt;然后，OpenTelemetry 接收器使用&lt;a href="/oss/agent/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana Agent&lt;/a&gt;将指标推送到 Prometheus Remote-Write，然后指标可以显示在我们的 Grafana 仪表板中。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这是通过以下图像提供的一个小演示： &lt;/p&gt;&lt;figure
class="figure-wrapper figure-wrapper__lightbox w-100p "
style="max-width: 100%;"
itemprop="associatedMedia"
itemscope=""
itemtype="http://schema.org/ImageObject"
&gt; &lt;a
class="lightbox-link captioned"
href="/media/blog/cd-observability-dora-metrics/change-failure-rate-1.png"
itemprop="contentUrl"
&gt;&lt;img
class="lazyload mb-0"
data-src="/media/blog/cd-observability-dora-metrics/change-failure-rate-1.png"data-srcset="/media/blog/cd-observability-dora-metrics/change-failure-rate-1.png?w=320 320w, /media/blog/cd-observability-dora-metrics/change-failure-rate-1.png?w=550 550w, /media/blog/cd-observability-dora-metrics/change-failure-rate-1.png?w=750 750w, /media/blog/cd-observability-dora-metrics/change-failure-rate-1.png?w=900 900w, /media/blog/cd-observability-dora-metrics/change-failure-rate-1.png?w=1040 1040w, /media/blog/cd-observability-dora-metrics/change-failure-rate-1.png?w=1240 1240w, /media/blog/cd-observability-dora-metrics/change-failure-rate-1.png?w=1920 1920w"
data-sizes="auto"alt="Stability DORA metrics before a new incident arrived"
width="912"
height="718"
title="*新事件发生之前 DORA 指标的稳定性*"
/&gt; &lt;noscript&gt;&lt;img
src="/media/blog/cd-observability-dora-metrics/change-failure-rate-1.png"
alt="Stability DORA metrics before a new incident arrived"
width="912"
height="718"
title="*新事件发生之前 DORA 指标的稳定性*"
/&gt;&lt;/noscript&gt;&lt;figcaption class="w-100p caption mb-1 text-gray-13 "&gt;&lt;em&gt;新事件发生前的稳定性 DORA 指标&lt;/em&gt;&lt;/a&gt;&lt;/figure&gt;&lt;figure
class="figure-wrapper figure-wrapper__lightbox w-100p "
style="max-width: 100%;"
itemprop="associatedMedia"
itemscope=""
itemtype="http://schema.org/ImageObject"
&gt; &lt;a
class="lightbox-link captioned"
href="/media/blog/cd-observability-dora-metrics/decalre-incident.png"
itemprop="contentUrl"
&gt;&lt;img
class="lazyload mb-0"
data-src="/media/blog/cd-observability-dora-metrics/decalre-incident.png"data-srcset="/media/blog/cd-observability-dora-metrics/decalre-incident.png?w=320 320w, /media/blog/cd-observability-dora-metrics/decalre-incident.png?w=550 550w, /media/blog/cd-observability-dora-metrics/decalre-incident.png?w=750 750w, /media/blog/cd-observability-dora-metrics/decalre-incident.png?w=900 900w, /media/blog/cd-observability-dora-metrics/decalre-incident.png?w=1040 1040w, /media/blog/cd-observability-dora-metrics/decalre-incident.png?w=1240 1240w, /media/blog/cd-observability-dora-metrics/decalre-incident.png?w=1920 1920w"
data-sizes="auto"alt="The moment before the new incident is declared"
width="934"
height="744"
title="*新事件宣布前的那一刻*"
/&gt; &lt;noscript&gt;&lt;img
src="/media/blog/cd-observability-dora-metrics/decalre-incident.png"
alt="The moment before the new incident is declared"
width="934"
height="744"
title="*新事件宣布前的那一刻*"
/&gt;&lt;/noscript&gt;&lt;figcaption class="w-100p caption mb-1 text-gray-13 "&gt;&lt;em&gt;新事件宣布前一刻&lt;/em&gt;&lt;/a&gt;&lt;/figure&gt;&lt;figure
class="figure-wrapper figure-wrapper__lightbox w-100p "
style="max-width: 100%;"
itemprop="associatedMedia"
itemscope=""
itemtype="http://schema.org/ImageObject"
&gt; &lt;a
class="lightbox-link captioned"
href="/media/blog/cd-observability-dora-metrics/change-failure-rate-2.png"
itemprop="contentUrl"
&gt;&lt;img
class="lazyload mb-0"
data-src="/media/blog/cd-observability-dora-metrics/change-failure-rate-2.png"data-srcset="/media/blog/cd-observability-dora-metrics/change-failure-rate-2.png?w=320 320w, /media/blog/cd-observability-dora-metrics/change-failure-rate-2.png?w=550 550w, /media/blog/cd-observability-dora-metrics/change-failure-rate-2.png?w=750 750w, /media/blog/cd-observability-dora-metrics/change-failure-rate-2.png?w=900 900w, /media/blog/cd-observability-dora-metrics/change-failure-rate-2.png?w=1040 1040w, /media/blog/cd-observability-dora-metrics/change-failure-rate-2.png?w=1240 1240w, /media/blog/cd-observability-dora-metrics/change-failure-rate-2.png?w=1920 1920w"
data-sizes="auto"alt="The refreshed dashboard, after a new incident is declared"
width="1024"
height="726"
title="*宣布新事件后刷新的仪表板*"
/&gt; &lt;noscript&gt;&lt;img
src="/media/blog/cd-observability-dora-metrics/change-failure-rate-2.png"
alt="The refreshed dashboard, after a new incident is declared"
width="1024"
height="726"
title="*宣布新事件后刷新的仪表板*"
/&gt;&lt;/noscript&gt;&lt;figcaption class="w-100p caption mb-1 text-gray-13 "&gt;&lt;em&gt;宣布新事件后刷新的仪表板&lt;/em&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;对于&lt;strong&gt;更改失败率&lt;/strong&gt;指标，我们使用以下查询：&lt;/p&gt;&lt;div class="code-snippet code-snippet__mini"&gt;&lt;div class="lang-toolbar__mini"&gt; &lt;span class="code-clipboard"&gt;&lt;button x-data="app_code_snippet()" x-init="init()" @click="copy()"&gt;&lt;img class="code-clipboard__icon" src="/media/images/icons/icon-copy-small-2.svg" alt="将代码复制到剪贴板" width="14" height="13"&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="code-snippet code-snippet__border"&gt;&lt;pre data-expanded="false"&gt; &lt;code class="language-none"&gt;sum(cd_incidents_count_total{service_name=&amp;quot;argo-workflows-otel-exporter&amp;quot;, repo=&amp;quot;enghub&amp;quot;, status=&amp;quot;active&amp;quot;}) / sum(cd_argoworkflows_count_total{service_name=&amp;quot;argo-workflows-otel-exporter&amp;quot;, workflow_group=&amp;quot;enghub&amp;quot;})&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;这被解释为特定时间范围内事件总数除以部署总数。&lt;/p&gt;&lt;p&gt;对于&lt;strong&gt;恢复服务指标的时间&lt;/strong&gt;，我们使用&lt;a href="/docs/grafana-cloud/alerting-and-irm/incident/visualize-data/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana Incident 数据源&lt;/a&gt;来查询相关服务的指标。然后，我们可以根据发起事件时分配的标签来查询事件。 （ &lt;a href="/docs/grafana-cloud/alerting-and-irm/incident/visualize-data/?pg=blog&amp;amp;plcmt=body-txt#example-queries"&gt;在此处&lt;/a&gt;阅读有关如何查询数据源的更多信息。）所有活动事件（未设置&lt;code&gt;time_to_resolve&lt;/code&gt;变量的事件）都标记为&lt;strong&gt;Pending&lt;/strong&gt; ，已解决的事件显示实际解决时间值。&lt;/p&gt;&lt;h2 id="why-use-opentelemetry-and-how-does-it-enable-observability"&gt;为什么使用 OpenTelemetry 以及它如何实现可观察性？&lt;/h2&gt;&lt;p&gt;正如我们之前提到的，我们在这个黑客马拉松项目中使用了&lt;a href="/oss/opentelemetry/?pg=blog&amp;amp;plcmt=body-txt"&gt;OpenTelemetry&lt;/a&gt; 。它通过提供用于测量、收集和移动遥测信号的关键部分（指标、跟踪和日志）的开放指南和工具来帮助提高可观察性。它还建立了一种在信号和服务之间共享遥测信息的通用方法，并提出了命名规则（语义约定），以确保可观测性工具和公司可以轻松连接和分析来自各种应用程序的遥测数据。 （&lt;em&gt;如果您想了解有关 OpenTelemetry 作用的更多信息，我们推荐&lt;a href="https://www.oreilly.com/library/view/practical-opentelemetry-adopting/9781484290750/" target="_blank" rel="noopener noreferrer"&gt;Daniel Gomez Blanco 关于该主题的书&lt;/a&gt;。&lt;/em&gt; ）&lt;/p&gt;&lt;p&gt;在我们的例子中，我们使用 Grafana、Mimir、Tempo 和 Grafana Incident 来提取 DORA 指标，所有这些指标都与 OpenTelemetry 兼容。同样，我们也可以使用其他数据源用于相同目的或替换 Grafana 事件。例如，我们可以使用 GitLab 标签之类的东西来创建事件。&lt;/p&gt;&lt;p&gt;事实上，我们认为，CI/CD 可观测性的广泛采用可能需要更广泛地采用 OpenTelemetry 标准。这将涉及创建适合 CD 流程的新命名规则，并调整 CD 的某些方面，特别是在遥测和监控方面，以符合 OpenTelemetry 指南。尽管需要进行这些调整，但 CD 管道之间更好的兼容性和标准化遥测流的好处将使这些努力变得值得。&lt;/p&gt;&lt;p&gt;在这个世界中，无论我们使用什么工具生成事件，我们关心的指标都具有相同的含义和约定，OpenTelemetry 将与供应商无关，并且只根据需要收集数据。正如我们之前所说，您可以从一项服务迁移到另一项服务（例如，从 GitLab 迁移到 GitHub），这不会产生任何影响，因为传入的数据将具有相同的约定。&lt;/p&gt;&lt;h2 id="looking-forward"&gt;期待&lt;/h2&gt;&lt;p&gt;此时此实现只是一个概念验证。不过，我们认为，一旦投入生产，我们将能够收集的数据将帮助我们优化此服务和其他内部服务的部署流程。&lt;strong&gt;变更的平均交付时间&lt;/strong&gt;尤其应该帮助我们优化可交付成果的大小，而且还可以检测各种管道内花费时间超过严格必要时间的步骤。稳定性指标还将帮助我们更全面地了解服务部署后发生的情况，并将这些知识反馈到之前的步骤中。&lt;/p&gt;&lt;p&gt;从学习的角度来看，这次黑客马拉松帮助更多的人了解 CI/CD 可观察性主题，但也向我们展示了可用工具中的一些差距，这些差距在未来将非常有趣！&lt;/p&gt;&lt;h3 id="ideas-for-next-steps"&gt;下一步的想法&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;将其贡献给&lt;a href="https://cloud-native.slack.com/archives/C0598R66XAP" target="_blank" rel="noopener noreferrer"&gt;CNCF CI/CD 可观测性工作组&lt;/a&gt;。&lt;/li&gt;&lt;li&gt;与日志进行更多集成。从 Argo Workflows 和 Grafana Incident 获取日志，并在仪表板中访问它们。&lt;/li&gt;&lt;li&gt;创建一个 Grafana 应用程序插件，负责 DORA 指标。&lt;/li&gt;&lt;li&gt;让 argo-workflows-otel-exporter 成为一个实际的接收器，并&lt;a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver" target="_blank" rel="noopener noreferrer"&gt;在此处&lt;/a&gt;将其开源。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt; &lt;em&gt;&lt;a href="/products/cloud/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana Cloud&lt;/a&gt;是开始使用指标、日志、跟踪、仪表板等的最简单方法。我们为每个用例提供慷慨的永久免费套餐和计划。&lt;a href="/auth/sign-up/create-user/?pg=blog&amp;amp;plcmt=body-txt"&gt;现在免费注册&lt;/a&gt;！&lt;/em&gt;&lt;/p&gt;</description><pubDate>Tue, 26 Mar 2024 00:00:00 GMT</pubDate><guid isPermaLink="true">https://grafana.com/blog/2024/03/26/ci/cd-observability-extracting-dora-metrics-from-a-cd-pipeline/</guid></item><item><title>如何使用 GitHub Actions 验证 Sigma 规则以改进安全监控</title><link>https://grafana.com/blog/2024/03/25/how-to-validate-sigma-rules-with-github-actions-for-improved-security-monitoring/</link><description>&lt;p&gt;监控身份提供商的日志对于识别潜在的安全威胁至关重要。这些日志对于安全团队至关重要，他们可以将它们存储在&lt;a href="https://grafana.com/docs/loki/latest/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana Loki&lt;/a&gt;等专用工具中，以增强可访问性和分析能力。&lt;/p&gt;&lt;p&gt;精确定位这些日志中特定模式的能力是关键——通过将这些模式制作成 Loki 查询，您可以跨日志进行有针对性的搜索。您可以设置警报来简化此过程，但随着时间的推移，手动进行检查可能会变得很麻烦。&lt;/p&gt;&lt;p&gt;输入&lt;a href="https://github.com/SigmaHQ/sigma" rel="noopener noreferrer" target="_blank"&gt;Sigma&lt;/a&gt; ，这是一个用于定义模式检测规则的开放标准。通过采用 YAML 格式的规则，Sigma 允许您指定要搜索的确切日志模式，从而优化您的安全操作。西格玛规则之所以特别强大，是因为它们的多功能性；它们是通用的，可以转换为各种后端的查询。&lt;a href="https://github.com/grafana/pySigma-backend-loki" rel="noopener noreferrer" target="_blank"&gt;pySigma-backend-loki&lt;/a&gt;项目就是一个例子，它将 Sigma 规则转换为 LogQL 查询，进一步提高安全监控策略的效率和有效性。&lt;/p&gt;&lt;p&gt;这篇博文介绍了一个由 Grafana Labs 安全运营团队开发的新 GitHub Action，它可以根据我们之前开发的 JSON 模式自动验证 Sigma 规则。我们将深入研究该工具的历史及其诞生过程，然后逐步介绍如何将其集成到 GitHub Actions 的工作流程中。&lt;/p&gt;&lt;h2 id="a-little-more-than-a-bit-of-history"&gt;一点点历史&lt;/h2&gt;&lt;p&gt;2023 年夏天，Grafana SecOps 团队正在开发一个集成&lt;a href="https://github.com/SigmaHQ/pySigma" rel="noopener noreferrer" target="_blank"&gt;pySigma&lt;/a&gt;和&lt;a href="https://github.com/grafana/pySigma-backend-loki" rel="noopener noreferrer" target="_blank"&gt;pySigma-backend-loki&lt;/a&gt;的内部项目，该项目以 Sigma 贡献者的基础工作为基础。&lt;/p&gt;&lt;p&gt;在项目的进展过程中，我们发现需要在&lt;a href="https://github.com/SigmaHQ/sigma" rel="noopener noreferrer" target="_blank"&gt;Sigma 存储库&lt;/a&gt;中进行更好的验证，所有 Sigma 规则都存储在其中并进行维护。从&lt;a href="https://github.com/SigmaHQ/sigma-specification" rel="noopener noreferrer" target="_blank"&gt;Sigma 规范存储库&lt;/a&gt;制作的现有架构需要更新。而且，它是按照&lt;a href="https://rjbs.manxome.org/rx/" rel="noopener noreferrer" target="_blank"&gt;Rx Schema&lt;/a&gt;格式化的，这是当时我相当陌生的标准。经过调查，我们发现 Rx Schema 格式已经过时，并且似乎不再维护。&lt;/p&gt;&lt;p&gt;根据我们在 JSON 模式方面的经验，我们决定在&lt;a href="https://github.com/SigmaHQ/sigma/blob/master/tests/validate-sigma-schema/sigma-schema.json" rel="noopener noreferrer" target="_blank"&gt;Sigma 规范的基础上为 Sigma 规则创建 JSON 模式&lt;/a&gt;，为 Sigma 项目做出贡献。 Sigma 规则是用 YAML 编写的，因此 JSON 架构可以帮助验证其内容。这项工作涉及与 Sigma 维护者的大量协作和迭代，最终成功合并了我们的贡献。&lt;/p&gt;&lt;figure class="figure-wrapper w-100p "&gt; &lt;a class="lightbox-link" href="https://github.com/SigmaHQ/sigma/pull/4367"&gt;&lt;img alt="GitHub 中拉取请求 4367 的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="GitHub 中拉取请求 4367 的屏幕截图。" src="https://grafana.com/media/blog/sigma_rules_github_actions/sigma_rules_pull_request_4367.jpg" /&gt;&lt;/noscript&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;该模式还可以在&lt;a href="https://github.com/SchemaStore/schemastore" rel="noopener noreferrer" target="_blank"&gt;Schema Store&lt;/a&gt;上找到，它是可在 IDE 或 JSON 工具中使用的独立 JSON 模式的集合。欲了解更多信息，请访问&lt;a href="https://www.schemastore.org/json/" rel="noopener noreferrer" target="_blank"&gt;架构商店网站&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;我们的贡献包括一个小型 Bash 脚本以及&lt;a href="https://github.com/python-jsonschema/check-jsonschema" rel="noopener noreferrer" target="_blank"&gt;check-jsonschema&lt;/a&gt;项目，它使我们能够根据新引入的 JSON 模式验证所有规则。此过程中出现了两条具有无效相关 UUID 的 Sigma 规则，我们立即解决了该问题。现在，每个更改规则的新提交都会根据此 JSON 架构进行验证。&lt;/p&gt;&lt;p&gt;几个月前，在一次团队讨论中，出现了为工作流程开发 GitHub Action 来验证 Sigma 规则（包括私有存储库中的规则）的想法。我们之前都没有这方面的经验，所以我们开始了学习之旅，最终创建了一个 GitHub Action。最初，我们扩展了 Bash 脚本以在 GitHub Actions 中使用，但在其功能和可维护性方面面临一些挑战。最终，我们用Python重写了脚本，以利用&lt;a href="https://docs.python.org/3/library/pathlib.html" rel="noopener noreferrer" target="_blank"&gt;pathlib&lt;/a&gt;模块和其他功能，增强了脚本的有效性。&lt;/p&gt;&lt;p&gt;我们的努力得到了 Sigma 维护者的&lt;a href="https://github.com/SigmaHQ/sigma/discussions/4723" rel="noopener noreferrer" target="_blank"&gt;积极反馈&lt;/a&gt;，特别是&lt;a href="https://github.com/nasbench" rel="noopener noreferrer" target="_blank"&gt;Nasreddine Bencherchali&lt;/a&gt; ，他支持将脚本保留在 Sigma 规则存储库中并直接从 Sigma 规范存储库获取模式的想法。这种协作努力需要时间来完善，但最终取得了成功。&lt;/p&gt;&lt;figure class="figure-wrapper w-100p "&gt; &lt;a class="lightbox-link" href="https://github.com/SigmaHQ/sigma/pull/4724"&gt;&lt;img alt="GitHub 中拉取请求 4724 的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="GitHub 中拉取请求 4724 的屏幕截图。" src="https://grafana.com/media/blog/sigma_rules_github_actions/sigma_rules_pull_request_4724.jpg" /&gt;&lt;/noscript&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;我们将&lt;a href="https://github.com/marketplace/actions/sigma-rules-validator" rel="noopener noreferrer" target="_blank"&gt;sigma-rules-validator&lt;/a&gt;项目捐赠给&lt;a href="https://sigmahq.io/" rel="noopener noreferrer" target="_blank"&gt;SigmaHQ&lt;/a&gt; ，经过一些修改和错误修复后，它正式发布，现在可以在&lt;a href="https://github.com/marketplace/actions/sigma-rules-validator" rel="noopener noreferrer" target="_blank"&gt;GitHub Marketplace&lt;/a&gt;上向社区提供。&lt;/p&gt;&lt;h2 id="how-to-validate-sigma-rules"&gt;如何验证 Sigma 规则&lt;/h2&gt;&lt;p&gt;现在，我们将通过一个示例来演示如何使用 sigma-rules-validator 项目验证 Sigma 规则。该项目的&lt;a href="https://github.com/SigmaHQ/sigma-rules-validator" rel="noopener noreferrer" target="_blank"&gt;自述文件&lt;/a&gt;提供了全面的说明，Sigma 存储库本身就是该操作应用程序的一个很好的&lt;a href="https://github.com/SigmaHQ/sigma/blob/master/.github/workflows/sigma-validation.yml" rel="noopener noreferrer" target="_blank"&gt;示例&lt;/a&gt;。&lt;/p&gt;&lt;div class="code-snippet "&gt;&lt;div class="lang-toolbar"&gt; &lt;span class="lang-toolbar__item"&gt;yaml&lt;/span&gt; &lt;span class="code-clipboard"&gt;&lt;button&gt;&lt;img alt="将代码复制到剪贴板" class="code-clipboard__icon" height="13" src="https://grafana.com/media/images/icons/icon-copy-small-2.svg" width="14" /&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;div class="lang-toolbar__border"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="code-snippet "&gt;&lt;pre&gt; &lt;code class="language-yaml"&gt;steps: - uses: SigmaHQ/sigma-rules-validator@v1&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;该过程涉及枚举存储库根目录中的&lt;code&gt;.yml&lt;/code&gt;文件，根据 JSON 架构文件验证它们，然后输出验证结果。对于更有针对性的方法，将 Sigma 文件放置在特定目录（如&lt;code&gt;rules&lt;/code&gt;中，并指定此目录进行验证可以简化流程，并有助于防止枚举非 Sigma 规则。&lt;/p&gt;&lt;div class="code-snippet "&gt;&lt;div class="lang-toolbar"&gt; &lt;span class="lang-toolbar__item"&gt;yaml&lt;/span&gt; &lt;span class="code-clipboard"&gt;&lt;button&gt;&lt;img alt="将代码复制到剪贴板" class="code-clipboard__icon" height="13" src="https://grafana.com/media/images/icons/icon-copy-small-2.svg" width="14" /&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;div class="lang-toolbar__border"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="code-snippet "&gt;&lt;pre&gt; &lt;code class="language-yaml"&gt;steps: - uses: SigmaHQ/sigma-rules-validator@v1 with: paths: &amp;#39;./rules&amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;如果您碰巧在不同的目录中组织不同的规则，您还可以传递多个目录。&lt;/p&gt;&lt;div class="code-snippet "&gt;&lt;div class="lang-toolbar"&gt; &lt;span class="lang-toolbar__item"&gt;yaml&lt;/span&gt; &lt;span class="code-clipboard"&gt;&lt;button&gt;&lt;img alt="将代码复制到剪贴板" class="code-clipboard__icon" height="13" src="https://grafana.com/media/images/icons/icon-copy-small-2.svg" width="14" /&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;div class="lang-toolbar__border"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="code-snippet "&gt;&lt;pre&gt; &lt;code class="language-yaml"&gt;steps: - uses: SigmaHQ/sigma-rules-validator@v1 with: paths: |- ./rules ./custom-rules&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;对于那些在 Sigma 规则存储库中拥有 JSON 架构或打算根据自定义 JSON 架构进行验证的人，该操作可以灵活地适应这些场景。以下示例展示了如何做到这一点。&lt;/p&gt;&lt;div class="code-snippet "&gt;&lt;div class="lang-toolbar"&gt; &lt;span class="lang-toolbar__item"&gt;yaml&lt;/span&gt; &lt;span class="code-clipboard"&gt;&lt;button&gt;&lt;img alt="将代码复制到剪贴板" class="code-clipboard__icon" height="13" src="https://grafana.com/media/images/icons/icon-copy-small-2.svg" width="14" /&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;div class="lang-toolbar__border"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="code-snippet "&gt;&lt;pre&gt; &lt;code class="language-yaml"&gt;steps: - uses: SigmaHQ/sigma-rules-validator@v1 with: paths: &amp;#39;./&amp;#39; schemaFile: &amp;#39;./sigma-schema.json&amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="code-snippet "&gt;&lt;div class="lang-toolbar"&gt; &lt;span class="lang-toolbar__item"&gt;yaml&lt;/span&gt; &lt;span class="code-clipboard"&gt;&lt;button&gt;&lt;img alt="将代码复制到剪贴板" class="code-clipboard__icon" height="13" src="https://grafana.com/media/images/icons/icon-copy-small-2.svg" width="14" /&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;div class="lang-toolbar__border"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="code-snippet "&gt;&lt;pre&gt; &lt;code class="language-yaml"&gt;steps: - uses: SigmaHQ/sigma-rules-validator@v1 with: paths: &amp;#39;./&amp;#39; schemaURL: &amp;#39;https://raw.githubusercontent.com/SigmaHQ/sigma-specification/main/sigma-schema.json&amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;我们希望这一举措将有助于制定有效的 Sigma 规则，并且我们欢迎通过问题或拉取请求提供任何反馈、功能请求或贡献。您还可以通过&lt;a href="https://slack.grafana.com/" rel="noopener noreferrer" target="_blank"&gt;Grafana Community Slack&lt;/a&gt;的 #security 频道与我们联系。&lt;/p&gt;</description><pubDate>Mon, 25 Mar 2024 13:57:00 GMT</pubDate><guid isPermaLink="true">https://grafana.com/blog/2024/03/25/how-to-validate-sigma-rules-with-github-actions-for-improved-security-monitoring/</guid></item><item><title>如何使用 Grafana 显示趋势并理解数据</title><link>https://grafana.com/blog/2024/03/25/how-to-surface-trends-and-make-sense-of-your-data-with-grafana/</link><description>&lt;p&gt;有一句波兰谚语：“Co za dużo to niezdrowo”，或多或少翻译为“足够了，就像一场盛宴一样好”。 （或者，逐字翻译：“某事太多可能不健康。”）有时对于数据来说也是如此。&lt;/p&gt;&lt;p&gt;在 Grafana Labs，我们始终推出产品和功能，通过高效的可视化、自适应可观察性或专用于特定工作流程和用例的应用程序，帮助您理解大量数据。最近，我们进一步添加了一些功能，可以更轻松地显示数据背后的趋势，因此让我们深入探讨您可能在该主题上错过的一些内容：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;使用单元格覆盖和格式设置在表可视化中可视化迷你图。&lt;/li&gt;&lt;li&gt;使用回归分析变换在时间序列可视化中绘制回归线。&lt;/li&gt;&lt;li&gt;在统计可视化中显示数据的百分比变化。&lt;/li&gt;&lt;li&gt;通过趋势可视化来可视化不基于时间的连续数据。&lt;/li&gt;&lt;/ul&gt;&lt;h2 id="table-panel-and-sparklines-in-cells"&gt;单元格中的表格面板和迷你图&lt;/h2&gt;&lt;p&gt;&lt;a href="https://grafana.com/docs/grafana/latest/panels-visualizations/visualizations/table/?pg=blog&amp;amp;plcmt=body-txt"&gt;表格面板&lt;/a&gt;非常适合显示大量数据、深入了解细节以及对数千行中的原始信息进行排序和过滤。它还非常适合呈现概述并引导您关注重要的事情。例如，您可以显示您监控的服务的 RED（速率、错误、持续时间）指标摘要。对于这个用例，一些表功能是非常宝贵的。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt;&lt;a class="lightbox-link" href="https://grafana.com/media/blog/surface-trends-grafana/sparkline.png"&gt;&lt;img alt="以迷你图显示折线、条形和点的时间序列到表格的转换" class="lazyload " /&gt; &lt;noscript&gt;&lt;img alt="以迷你图显示折线、条形和点的时间序列到表格的转换" src="https://grafana.com/media/blog/surface-trends-grafana/sparkline.png" /&gt;&lt;/noscript&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;首先，您可以使用&lt;a href="https://grafana.com/docs/grafana/latest/panels-visualizations/query-transform-data/transform-data/?pg=blog&amp;amp;plcmt=body-txt#time-series-to-table-transform"&gt;时间序列到表的&lt;/a&gt;转换在&lt;a href="https://grafana.com/docs/grafana/latest/panels-visualizations/visualizations/table/#sparkline"&gt;迷你图&lt;/a&gt;中显示时间序列字段 - 一个微型时间序列可视化，您也可以将其配置为线、条形图或点。这是一种无需深入研究特定仪表板即可显示指标突然峰值或持续趋势的好方法。将其与深入分析相结合，您可以在一张表中跟踪基础架构组件的整体运行状况。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/surface-trends-grafana/time-series-to-table.png"&gt;&lt;img alt="组合细胞类型进行趋势分析" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="组合细胞类型进行趋势分析" src="https://grafana.com/media/blog/surface-trends-grafana/time-series-to-table.png" /&gt;&lt;/noscript&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;此外，您还可以使用其他&lt;a href="https://grafana.com/docs/grafana/latest/panels-visualizations/visualizations/table/?pg=blog&amp;amp;plcmt=body-txt#cell-type"&gt;单元格类型&lt;/a&gt;，通过使用仪表单元格类型来直观地比较各种信息。您还可以将单元格类型&lt;a href="https://grafana.com/docs/grafana/latest/panels-visualizations/configure-overrides/?pg=blog&amp;amp;plcmt=body-txt"&gt;覆盖&lt;/a&gt;与&lt;a href="https://grafana.com/docs/grafana/latest/panels-visualizations/configure-value-mappings/?pg=blog&amp;amp;plcmt=body-txt"&gt;值映射&lt;/a&gt;结合起来，将连续数据更改为分类指示器（例如向上/向下或描述指标值范围的文字和图标）。&lt;/p&gt;&lt;h2 id="regression-analysis-transformation"&gt;回归分析变换&lt;/h2&gt;&lt;p&gt;有时很难用可变时间序列数据来解释总体趋势。毕竟，作为人类，我们倾向于关注最高峰值或最新结果，更不用说误报，有时我们会看到不存在任何模式的情况。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/surface-trends-grafana/regression-analysis-transformation.png"&gt;&lt;img alt="回归分析可视化" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="回归分析可视化" src="https://grafana.com/media/blog/surface-trends-grafana/regression-analysis-transformation.png" /&gt;&lt;/noscript&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;如果您想通过长期趋势、季节性和周期性的角度了解一段时间内的时间序列数据，或者如果您想通过“消除极端值”来比较各个序列的趋势，则&lt;a href="https://grafana.com/docs/grafana/latest/panels-visualizations/visualizations/stat/?pg=blog&amp;amp;plcmt=body-txt"&gt;回归分析变换&lt;/a&gt;是一种变换这可以帮助你。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/surface-trends-grafana/regression-analysis-transformation-2.png"&gt;&lt;img alt="回归分析转换可视化" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="回归分析转换可视化" src="https://grafana.com/media/blog/surface-trends-grafana/regression-analysis-transformation-2.png" /&gt;&lt;/noscript&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;您可以在线性回归或多项式模型之间进行选择，后者提供二次、三次、四次和五次次数选项。此外，您可以尝试使用&lt;a href="https://grafana.com/docs/grafana/latest/panels-visualizations/visualizations/time-series/?pg=blog&amp;amp;plcmt=body-txt#fill-below-to"&gt;下面的填充来&lt;/a&gt;绘制图表样式选项，以标记指标远高于趋势的时间范围。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/surface-trends-grafana/regression-line.png"&gt;&lt;img alt="回归线变换可视化" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="回归线变换可视化" src="https://grafana.com/media/blog/surface-trends-grafana/regression-line.png" /&gt;&lt;/noscript&gt;&lt;/a&gt;&lt;/figure&gt;&lt;h2 id="stat-panel-and-percent-change-indicator"&gt;统计面板和百分比变化指示器&lt;/h2&gt;&lt;p&gt;当您需要呈现关键指标或 KPI 时&lt;a href="https://grafana.com/docs/grafana/latest/panels-visualizations/visualizations/stat/?pg=blog&amp;amp;plcmt=body-txt"&gt;，统计面板&lt;/a&gt;会派上用场。但知道这个大数字并不总是足够的——了解最近的变化也同样有价值，甚至更重要。在这种情况下，统计面板中的&lt;a href="https://grafana.com/docs/grafana/latest/panels-visualizations/visualizations/stat/?pg=blog&amp;amp;plcmt=body-txt"&gt;百分比变化指示器&lt;/a&gt;选项会派上用场。通过一个开关，您可以添加有关指标如何变化以及趋势（向上/向下）的信息。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/surface-trends-grafana/percentage-change.png"&gt;&lt;img alt="百分比变化指标可视化" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="百分比变化指标可视化" src="https://grafana.com/media/blog/surface-trends-grafana/percentage-change.png" /&gt;&lt;/noscript&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;百分比变化指示器选项与&lt;a href="https://grafana.com/docs/grafana/latest/panels-visualizations/visualizations/stat/?pg=blog&amp;amp;plcmt=body-txt"&gt;现有的迷你图功能&lt;/a&gt;以及独立显示和隐藏值和标签的可能性相结合，增加了最重要指标的显示选项。&lt;/p&gt;&lt;h2 id="trend-panel"&gt;趋势面板&lt;/h2&gt;&lt;p&gt;&lt;a href="https://grafana.com/docs/grafana/latest/panels-visualizations/visualizations/trend/?pg=blog&amp;amp;plcmt=body-txt"&gt;趋势面板&lt;/a&gt;与时间序列可视化非常相似，但 x 轴表示任何连续范围的值，例如时间、温度或收入。想想上次你被拉去调查是什么时候。收到警报后您的心率一定会上升。为了了解自收到警报以来您的心率发生了怎样的变化，我们可以使用趋势可视化，并沿 x 轴绘制自收到警报以来的每分钟心跳数。 （在这种情况下，幸运的是，这是一个误报，因此升高的心率很快稳定下来）。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/surface-trends-grafana/heart-rate.png"&gt;&lt;img alt="事件期间心率随时间变化的趋势面板" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="事件期间心率随时间变化的趋势面板" src="https://grafana.com/media/blog/surface-trends-grafana/heart-rate.png" /&gt;&lt;/noscript&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;您甚至可以将其用于不可观察性用例。例如，假设您非常喜欢肌肉车。下次当您想了解发动机功率和扭矩与速度的关系时（速度绘制在 x 轴上，功率和扭矩绘制在 y 轴上），只需使用“趋势”面板即可。&lt;/p&gt;&lt;h2 id="beyond-existing-telemetry"&gt;超越现有的遥测技术&lt;/h2&gt;&lt;p&gt;我们在这篇博文中讨论的功能均在 Grafana 10.0 或更高版本中发布。我们已经看到团队在使用这些功能，并且随着越来越多的组织采用最新版本的 Grafana，我们很高兴看到社区的其他成员如何利用这些功能。&lt;/p&gt;&lt;p&gt;虽然这些功能非常适合根据现有数据发现趋势，但您可以使用 Grafana Cloud 走得更远。借助我们的&lt;a href="https://grafana.com/products/cloud/irm/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana 事件和响应管理&lt;/a&gt;解决方案套件，您还可以&lt;a href="https://grafana.com/docs/grafana-cloud/alerting-and-irm/machine-learning/set-up/tutorial/?pg=blog&amp;amp;plcmt=body-txt"&gt;创建指标预测&lt;/a&gt;来帮助您评估未来趋势。因此，无论您是回顾过去还是展望未来，Grafana Cloud 都能满足您的需求！&lt;/p&gt;&lt;p&gt; &lt;em&gt;&lt;a href="https://grafana.com/products/cloud/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana Cloud&lt;/a&gt;是开始使用指标、日志、跟踪、仪表板等的最简单方法。我们为每个用例提供慷慨的永久免费套餐和计划。&lt;a href="https://grafana.com/auth/sign-up/create-user/?pg=blog&amp;amp;plcmt=body-txt"&gt;现在免费注册&lt;/a&gt;！&lt;/em&gt;&lt;/p&gt;</description><pubDate>Mon, 25 Mar 2024 00:00:00 GMT</pubDate><guid isPermaLink="true">https://grafana.com/blog/2024/03/25/how-to-surface-trends-and-make-sense-of-your-data-with-grafana/</guid></item><item><title>航运/第三方物流公司如何利用 Grafana LGTM Stack 减少 MTTR 并增加正常运行时间</title><link>https://grafana.com/blog/2024/03/22/how-shipping/third-party-logistics-companies-reduce-mttr-and-increase-uptime-with-the-grafana-lgtm-stack/</link><description>&lt;p&gt;如今，一切都可以追踪：运输、送货、食品订单。 。 。对于消费者来说，了解包裹或快递的位置是一种额外的好处，但对于从事运输、交付和第三方物流业务的公司来说，这是必需的。拥有正确的可观测系统来确保一切都到达需要的地方也很重要。毕竟，错误、停机或任何导致延误的情况最终都会导致客户不满意和收入损失。&lt;/p&gt;&lt;p&gt;在这里，来自一些全球最大的航运和第三方物流 (3PL) 公司的内部人士分享了 Grafana LGTM Stack（用于日志的&lt;a href="https://grafana.com/oss/loki/?pg=blog&amp;amp;plcmt=body-txt"&gt;Loki&lt;/a&gt; 、用于可视化的&lt;a href="https://grafana.com/oss/grafana?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana&lt;/a&gt; 、用于跟踪的&lt;a href="https://grafana.com/oss/tempo/?pg=blog&amp;amp;plcmt=body-txt"&gt;Tempo&lt;/a&gt;和用于指标的&lt;a href="https://grafana.com/oss/mimir/?pg=blog&amp;amp;plcmt=body-txt"&gt;Mimir&lt;/a&gt; ）如何帮助他们的团队更快地解决问题并改善客户体验。&lt;/p&gt;&lt;p&gt;正如 DHL Express IT 主管 Djamel Djedi 所说：“这个可观察性堆栈提供了很多好处。”&lt;/p&gt;&lt;h2 id="proactive-monitoring-and-reducing-mttr"&gt;主动监控并减少 MTTR&lt;/h2&gt;&lt;p&gt;每年，超过 2.96 亿个包裹通过&lt;a href="https://www.dhl.com/us-en/home.html?locale=true" rel="noopener noreferrer" target="_blank"&gt;DHL&lt;/a&gt;及其优质服务 Time Definite International 运送到世界各地。停机、误报、错误和失败请求的空间非常小， &lt;a href="https://grafana.com/blog/2023/08/16/reduce-mttr-with-grafana-grafana-k6-and-prometheus-inside-dhls-observability-stack/"&gt;DHL Express&lt;/a&gt; Switzerland 的 IT 团队是一个本地部门，提供跟踪清关进度、分析、移动和光学字符识别 (OCR) 扫描的解决方案，以及对穿越该国的每个包裹的仓库管理——意识到传统的监控系统是不够的。由于系统是孤立的，IT 团队在出现问题时往往会做出反应，这会影响识别和解决问题所需的时间。&lt;/p&gt;&lt;p&gt; DHL 通过使用 Grafana、Grafana k6 和 Prometheus 的以&lt;a href="https://grafana.com/blog/2023/08/16/reduce-mttr-with-grafana-grafana-k6-and-prometheus-inside-dhls-observability-stack/"&gt;Grafana 为中心的可观测性解决方案&lt;/a&gt;转变了其 IT 和业务流程。然后，他们能够采取主动的监控方法，这得益于 Grafana 仪表板和&lt;a href="https://grafana.com/products/cloud/alerting/"&gt;Grafana 警报&lt;/a&gt;的强大实施。&lt;/p&gt;&lt;p&gt; “我们的警报包含应用程序的名称、问题的描述、Grafana 仪表板的链接以及 Microsoft Teams 中包含修复说明的 wiki 的链接，”首席架构师 Michael Lerch 说。 “结果？无论谁值班，他们都可以比我们以前更快地解决出现的问题。”&lt;/p&gt;&lt;p&gt;截至 2023 年，该团队已将 Grafana 使用量增加到 80 个警报、40 个仪表板和 60 个活跃用户。在此过程中，他们也减轻了集体的日常压力。 “我喜欢每天早上到达并查看显示一切正常的 Grafana 仪表板，”IT 主管 Djamel Djedid 说。 “你不需要滚动电子邮件或希望没有人给你打电话或发短信——你已经知道了。”&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/shipping_companies_grafana_use_cases/shipping_companies_dhl_grafana_dashboard.png"&gt;&lt;img alt="" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="" src="https://grafana.com/media/blog/shipping_companies_grafana_use_cases/shipping_companies_dhl_grafana_dashboard.png" /&gt;&lt;/noscript&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;详细了解&lt;a href="https://grafana.com/blog/2023/08/16/reduce-mttr-with-grafana-grafana-k6-and-prometheus-inside-dhls-observability-stack/"&gt;DHL 的可观测性堆栈&lt;/a&gt;及其实施 Grafana 堆栈的分阶段方法。&lt;/p&gt;&lt;h2 id="smooth-customer-experiences"&gt;流畅的客户体验&lt;/h2&gt;&lt;p&gt;印度各地数百万消费者依靠&lt;a href="https://grafana.com/success/blinkit/?pg=blog&amp;amp;plcmt=body-txt"&gt;Blinkit&lt;/a&gt; （以前称为 Grofers）来运送杂货和必需品。使该公司如此受欢迎的一项功能是什么？ &lt;a href="https://blinkit.com/" rel="noopener noreferrer" target="_blank"&gt;Blinkit&lt;/a&gt;承诺所有送货均在 10 分钟或更短的时间内完成。&lt;/p&gt;&lt;p&gt;客户满意度不仅仅取决于即时到达 - Blinkit 还需要购物者在订购时获得顺畅的体验。结帐过程中的小问题可能会导致购物车被遗弃，因此需要快速解决问题以防止销售损失。在用 Grafana Cloud 替换 ELK Stack 后（“我们花了一半的时间来确保 ELK Stack 的一切正常运行”，Blinkit 工程经理 Vaibhav Krishna 说），Blinkit 可以持续访问查看其运行情况所需的关键数据。整个实时可观测性画面。&lt;/p&gt;&lt;p&gt; Grafana 中可视化的一个关键数据源是每分钟的客户结账次数，它与 Blinkit 的客户满意度和忠诚度指标直接相关。&lt;/p&gt;&lt;p&gt; “ &lt;a href="https://grafana.com/oss/grafana?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana&lt;/a&gt; 、 &lt;a href="https://grafana.com/oss/loki/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana Loki&lt;/a&gt;和&lt;a href="https://grafana.com/products/cloud/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana Cloud&lt;/a&gt;帮助我们确保我们的结账功能始终为客户服务，”Krishna 说。 “如果我们没有有效的结账系统，我们就没有电子商务平台。”&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/shipping_companies_grafana_use_cases/shipping_companies_blinkit_grafana_dashboard.png"&gt;&lt;img alt="" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="" src="https://grafana.com/media/blog/shipping_companies_grafana_use_cases/shipping_companies_blinkit_grafana_dashboard.png" /&gt;&lt;/noscript&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;了解&lt;a href="https://grafana.com/success/blinkit/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana Cloud 如何实现 Blinkit 的可观测性目标&lt;/a&gt;。&lt;/p&gt;&lt;h2 id="self-service-onboarding-and-real-user-monitoring"&gt;自助服务入门和真实用户监控&lt;/h2&gt;&lt;p&gt;作为综合集装箱物流领域的领导者，马士基为超过 100,000 家通过海洋、港口、空运和陆运运输货物的客户提供服务。总的来说，该公司负责确保全球 20% 的全球贸易顺利进行。&lt;/p&gt;&lt;p&gt;马士基拥有庞大而复杂的基础设施，并采用云优先、技术驱动的方法来开展业务。当公司开始对其技术环境进行现代化改造时，其目标是为客户提供更高的可靠性、可见性和敏捷性。其中一个重要部分是授权开发人员在技术方面做出自己的选择——但这也有一个缺点。马士基平台工程总监 Roshith Radhakrishnan 表示，由于没有全面的覆盖范围，管理工具和关联数据“几乎不可能”。&lt;/p&gt;&lt;p&gt;为了解决这个问题，马士基通过使用 Grafana LGTM Stack 构建集中式内部可观测平台（称为 MOP），彻底改变了其可观测性。 MOP 为用户提供简单的自助服务，并使可观察性民主化，使整个开发组织的所有用户都可以使用数据。&lt;/p&gt;&lt;p&gt;但团队还想了解 MOP 的功能是如何使用的，并且需要一个前端可观察性解决方案。借助&lt;a href="https://grafana.com/oss/faro/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana Faro&lt;/a&gt; （高度可配置的 Web SDK），马士基能够将真实用户监控 (RUM) 添加到其平台，而无需额外成本或新的供应商麻烦。 MOP 现在为前端用户提供了模板化（但可定制）仪表板，他们可以在其中监控页面性能摘要，其中包含 Web 生命体征和其他指标，例如异常、错误和用户分析数据。&lt;/p&gt;&lt;p&gt;换句话说，“Grafana Labs 拯救了我们”，马士基可观测平台高级工程经理 Henry Kühl 说道。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/shipping_companies_grafana_use_cases/shipping_companies_maersk_grafana_dashboard.png"&gt;&lt;img alt="" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="" src="https://grafana.com/media/blog/shipping_companies_grafana_use_cases/shipping_companies_maersk_grafana_dashboard.png" /&gt;&lt;/noscript&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;详细了解&lt;a href="https://grafana.com/about/events/observabilitycon/2023/how-maersk-consolidated-observability-with-grafana-lgtm-stack/"&gt;Maersk 如何在其平台中使用 Grafana LGTM Stack 和 Faro&lt;/a&gt; ，以及它如何为所有边缘端点提供支持可观测性的可能性。&lt;/p&gt;&lt;p&gt; &lt;em&gt;&lt;a href="https://grafana.com/products/cloud/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana Cloud&lt;/a&gt;是开始使用指标、日志、跟踪和仪表板的最简单方法。我们为每个用例提供慷慨的永久免费套餐和计划。&lt;a href="https://grafana.com/auth/sign-up/create-user/?pg=blog&amp;amp;plcmt=body-txt"&gt;现在免费注册！&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;</description><pubDate>Fri, 22 Mar 2024 10:52:00 GMT</pubDate><guid isPermaLink="true">https://grafana.com/blog/2024/03/22/how-shipping/third-party-logistics-companies-reduce-mttr-and-increase-uptime-with-the-grafana-lgtm-stack/</guid></item><item><title>使用 eBPF 进行 OpenTelemetry 分布式跟踪：Grafana Beyla 1.3 中的新增功能</title><link>https://grafana.com/blog/2024/03/21/opentelemetry-distributed-tracing-with-ebpf-whats-new-in-grafana-beyla-1.3/</link><description>&lt;p&gt;Grafana Beyla 是一个开源 eBPF 自动检测工具，自从我们 &lt;a href="https://grafana.com/blog/2023/09/13/grafana-beyla-open-source-ebpf-auto-instrumentation/"&gt;引入该项目&lt;/a&gt;以来，它已经能够生成 OpenTelemetry 跟踪范围。 &lt;a href="https://grafana.com/blog/2023/09/13/grafana-beyla-open-source-ebpf-auto-instrumentation/"&gt;&lt;/a&gt;然而，Grafana Beyla 的初始版本生成的跟踪是单跨 OpenTelemetry 跟踪，这意味着跟踪上下文信息仅限于单个服务视图。 Beyla 能够获取传递给检测服务的 TraceID 信息，但无法将其向上游传播到其他服务。&lt;/p&gt;&lt;p&gt;由于完整的分布式跟踪是一种出色的生产调试工具，因此我们在&lt;a href="https://grafana.com/blog/2024/01/24/grafana-beyla-1.2-release-ebpf-auto-instrumentation-with-full-kubernetes-support/"&gt;Beyla 1.2&lt;/a&gt;以及最近的&lt;a href="https://github.com/grafana/beyla/releases/tag/v1.3.1" rel="noopener noreferrer" target="_blank"&gt;Beyla 1.3&lt;/a&gt;版本中的自动分布式跟踪目标方面取得了重大进展。我们使用了两种不同的方法——自动标头注入和黑盒上下文传播——它们协同工作以提供尽可能完整的分布式跟踪功能。&lt;/p&gt;&lt;p&gt;在这篇博文中，我们将概述这两种方法，包括它们的工作原理、当前的局限性以及它们将如何发展。&lt;/p&gt;&lt;h2 id="approach-1-trace-context-propagation-with-automatic-header-injection"&gt;方法 1：通过自动标头注入跟踪上下文传播&lt;/h2&gt;&lt;p&gt;任何使用 OpenTelemetry SDK 进行服务检测的人都应该熟悉这种方法。总体思路是，检测拦截传入请求，读取任何提供的跟踪信息，并将该跟踪信息存储在&lt;a href="https://opentelemetry.io/docs/languages/js/context/" rel="noopener noreferrer" target="_blank"&gt;请求上下文&lt;/a&gt;中。然后，该请求上下文被注入到应用程序对上游服务的传出调用中。 &lt;a href="https://www.w3.org/TR/trace-context/" rel="noopener noreferrer" target="_blank"&gt;W3C 跟踪上下文标准&lt;/a&gt;定义了跟踪信息上下文应是什么样子，如图 1 所示。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link captioned" href="https://grafana.com/media/blog/grafana-beyla-1.3/beyla-1.3--W3C-trace-context-standard-.png"&gt;&lt;img alt="An image depicting the W3C Trace Context standard." class="lazyload mb-0" title="*图 1. 用于跟踪信息上下文的 W3C 跟踪上下文标准。*" /&gt; &lt;noscript&gt;&lt;img alt="An image depicting the W3C Trace Context standard." src="https://grafana.com/media/blog/grafana-beyla-1.3/beyla-1.3--W3C-trace-context-standard-.png" title="*图 1. 用于跟踪信息上下文的 W3C 跟踪上下文标准。*" /&gt;&lt;/noscript&gt;&lt;figcaption class="w-100p caption mb-1 text-gray-13 "&gt;&lt;em&gt;图 1. 用于跟踪信息上下文的 W3C 跟踪上下文标准。&lt;/em&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;根据W3C标准，跟踪信息通过HTTP/HTTP2/gRPC请求头传播，如图1所示。它包含一个唯一的 TraceID，用于标识属于该跟踪的所有&lt;a href="https://opentelemetry.io/docs/concepts/signals/traces/#spans" rel="noopener noreferrer" target="_blank"&gt;跟踪范围&lt;/a&gt;。跟踪的每个单独请求都有一个唯一的 SpanID，该 SpanID 用作父 SpanID 以在跟踪中创建客户端-服务器关系。图 2 中的伪代码显示了通常如何完成此操作。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link captioned" href="https://grafana.com/media/blog/grafana-beyla-1.3/beyla-1.3-trace-info-propagated-through-request-headers.png"&gt;&lt;img alt="A screenshot of code showing trace information propagated through request headers." class="lazyload mb-0" title="*图 2.通过 HTTP/HTTP2/gRPC 请求标头传播的跟踪信息。*" /&gt; &lt;noscript&gt;&lt;img alt="A screenshot of code showing trace information propagated through request headers." src="https://grafana.com/media/blog/grafana-beyla-1.3/beyla-1.3-trace-info-propagated-through-request-headers.png" title="*图 2.通过 HTTP/HTTP2/gRPC 请求标头传播的跟踪信息。*" /&gt;&lt;/noscript&gt;&lt;figcaption class="w-100p caption mb-1 text-gray-13 "&gt;&lt;em&gt;图 2.通过 HTTP/HTTP2/gRPC 请求标头传播的跟踪信息。&lt;/em&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt; Beyla 使用与上述相同的方法，不同之处在于它使用仔细注入的 eBPF 探针来读取传入跟踪信息并在传出调用中注入跟踪标头。这种自动检测和上下文传播目前仅针对 Go 程序实现，并且自 Beyla 1.2 版本以来就可用。&lt;/p&gt;&lt;p&gt; Beyla 了解 Go 内部结构并跟踪 Go &lt;code&gt;goroutine&lt;/code&gt;创建，以便将传入请求的上下文传播到任何发出的调用。这种跟踪甚至适用于异步请求，因为 Beyla 能够跟踪&lt;code&gt;goroutine&lt;/code&gt;父子关系及其生命周期。在图 3 中，我们显示了与图 2 中所示的手动检测等效的操作，但由 Beyla 自动完成。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link captioned" href="https://grafana.com/media/blog/grafana-beyla-1.3/beyla-1.3-automatic-instrumentation-of-context-propagation.png"&gt;&lt;img alt="A screenshot demonstrating automatic instrumentation of context propagation in Beyla." class="lazyload mb-0" title="*图 3. Beyla 中上下文传播的自动检测。*" /&gt; &lt;noscript&gt;&lt;img alt="A screenshot demonstrating automatic instrumentation of context propagation in Beyla." src="https://grafana.com/media/blog/grafana-beyla-1.3/beyla-1.3-automatic-instrumentation-of-context-propagation.png" title="*图 3. Beyla 中上下文传播的自动检测。*" /&gt;&lt;/noscript&gt;&lt;figcaption class="w-100p caption mb-1 text-gray-13 "&gt;&lt;em&gt;图 3. Beyla 中上下文传播的自动检测。&lt;/em&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;这种方法适用于所有 Go 应用程序，并且我们已经为 HTTP(S)、HTTP2 和 gRPC 实现了这种自动上下文传播。然而，有一个限制：当 Linux 内核处于锁定模式时，我们用来在传出请求中写入标头信息的 eBPF 帮助程序会受到保护。当内核启用了安全启动或者已在&lt;code&gt;integrity&lt;/code&gt;或&lt;code&gt;security&lt;/code&gt;锁定模式下手动配置时，通常会发生这种情况。尽管这些锁定配置在云虚拟机/容器配置中并不常见，但我们会自动检测 Linux 内核是否允许我们使用帮助程序，并相应地启用传播支持。&lt;/p&gt;&lt;p&gt;我们计划在 Beyla 的未来版本中将对自动标头注入的支持扩展到更多语言。&lt;/p&gt;&lt;h2 id="approach-2-black-box-context-propagation"&gt;方法 2：黑盒上下文传播&lt;/h2&gt;&lt;p&gt;黑盒上下文传播的想法非常简单。如果单个 Beyla 实例监控两个或多个相互通信的服务，我们可以使用 TCP 连接元组来唯一标识每个单独的连接请求。本质上，Beyla 不需要在 HTTP/gRPC 标头中传播上下文；它可以“记住”给定的连接元组，并在另一端收到请求时查找它。&lt;/p&gt;&lt;p&gt;图 4 显示了此连接跟踪的工作原理。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link captioned" href="https://grafana.com/media/blog/grafana-beyla-1.3/beyla-1.3-black-box-context-propagation.png"&gt;&lt;img alt="A diagram depicting connection tracking in black-box context propagation." class="lazyload mb-0" title="*图 4. 黑盒上下文传播中的连接跟踪。*" /&gt; &lt;noscript&gt;&lt;img alt="A diagram depicting connection tracking in black-box context propagation." src="https://grafana.com/media/blog/grafana-beyla-1.3/beyla-1.3-black-box-context-propagation.png" title="*图 4. 黑盒上下文传播中的连接跟踪。*" /&gt;&lt;/noscript&gt;&lt;figcaption class="w-100p caption mb-1 text-gray-13 "&gt;&lt;em&gt;图 4. 黑盒上下文传播中的连接跟踪。&lt;/em&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;这种方法对于所有编程语言都是相同的，因此这种上下文传播适用于任何应用程序，无论它是用什么编程语言编写的。由于上下文信息的“记住”部分是在本地存储的 Beyla eBPF 映射中完成的，因此这种方法目前仅限于单个节点。将 Beyla 连接到外部存储可以消除此限制，我们正在考虑将来对此提供支持。&lt;/p&gt;&lt;p&gt;虽然我们解释了如何在黑盒上下文传播功能中跟踪服务之间的连接，但我们仍然需要做更多的工作来跟踪服务内传入到传出的请求。当传入请求与任何未来的传出调用由同一线程处理时，请求跟踪就很简单。我们通过线程 ID 将传入请求连接到传出请求。&lt;/p&gt;&lt;p&gt;但对于异步请求，我们必须添加更复杂的跟踪。对于 Go 应用程序，我们已经跟踪&lt;code&gt;goroutine&lt;/code&gt;生命周期和父关系，但对于其他编程语言，我们添加了对跟踪&lt;code&gt;sys_clone&lt;/code&gt;调用的支持。通过跟踪&lt;code&gt;sys_clone&lt;/code&gt; ，我们可以跟踪请求线程的父子关系，类似于跟踪&lt;code&gt;goroutines&lt;/code&gt; 。这在某种程度上效果很好——也就是说，它不适用于使用传出客户端线程池的应用程序。通常，线程池预先创建了线程，并且通过跟踪&lt;code&gt;sys_clone&lt;/code&gt;不会捕获客户端请求的异步切换。我们计划通过在 Beyla 的未来版本中添加更多特定于库/语言的请求跟踪来缓解这一限制。&lt;/p&gt;&lt;h2 id="next-steps"&gt;下一步&lt;/h2&gt;&lt;p&gt;Beyla 1.3 为许多场景提供了 OpenTelemetry 分布式跟踪支持，无需开发人员进行任何工作。我们相信，改进 Beyla 未来版本中的当前限制将提供与手动检测相同或更好的分布式跟踪功能。&lt;/p&gt;&lt;p&gt;我们也很想听听您与 Grafana Beyla 的经历。请随时加入我们的&lt;a href="https://slack.grafana.com/" rel="noopener noreferrer" target="_blank"&gt;Community Slack&lt;/a&gt;中的 #beyla 频道。我们还在每个月的第二个星期三举办每月一次的 Beyla 社区电话会议。您可以在&lt;a href="https://calendar.google.com/calendar/u/0/embed?src=grafana.com_n57lluqpn4h4edroeje6199o00@group.calendar.google.com" rel="noopener noreferrer" target="_blank"&gt;Grafana 社区日历&lt;/a&gt;上找到所有详细信息。&lt;/p&gt;&lt;p&gt;&lt;em&gt;要了解有关 Grafana Beyla 中分布式跟踪的更多信息，您可以查看我们的&lt;a href="https://grafana.com/docs/beyla/latest/distributed-traces/?pg=blog&amp;amp;plcmt=body-txt"&gt;技术文档&lt;/a&gt;。有关开始使用 Beyla 的分步指导，您可以参考本&lt;a href="https://grafana.com/docs/beyla/latest/tutorial/getting-started/?pg=blog&amp;amp;plcmt=body-txt"&gt;教程&lt;/a&gt;。&lt;/em&gt;&lt;/p&gt;</description><pubDate>Thu, 21 Mar 2024 12:55:00 GMT</pubDate><guid isPermaLink="true">https://grafana.com/blog/2024/03/21/opentelemetry-distributed-tracing-with-ebpf-whats-new-in-grafana-beyla-1.3/</guid></item></channel></rss>