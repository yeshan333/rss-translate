<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Grafana Labs 上的 Grafana Labs 博客</title><link>https://grafana.com/blog/</link><description>Grafana Labs 上的 Grafana Labs 博客中的最​​新内容</description><lastBuildDate>Tue, 04 Jun 2024 16:04:37 GMT</lastBuildDate><generator>rfeed v1.1.1</generator><docs>https://github.com/svpino/rfeed/blob/master/README.md</docs><item><title>【Grafana Tempo 2.5 release: vParquet4, streaming endpoints, and more metrics】Grafana Tempo 2.5 版本：vParquet4、流端点和更多指标</title><link>https://grafana.com/blog/2024/06/03/grafana-tempo-2.5-release-vparquet4-streaming-endpoints-and-more-metrics/</link><description>&lt;p&gt;&lt;a href="https://github.com/grafana/tempo/releases/tag/v2.5.0" rel="noopener noreferrer" target="_blank"&gt;Grafana Tempo 2.5&lt;/a&gt;带来了性能改进，vParquet4 为新的 TraceQL 功能和其他指标功能奠定了基础！&lt;/p&gt;&lt;div class="shortcode youtube"&gt;&lt;/div&gt;&lt;p&gt;观看上面的视频，了解 TraceQL 指标的亮点，或继续阅读以快速了解 Tempo 的最新更新。如果您正在寻找更深入的内容，请立即查看&lt;a href="https://grafana.com/docs/tempo/latest/release-notes/v2-5/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana Tempo 2.5 发行说明&lt;/a&gt;或&lt;a href="https://github.com/grafana/tempo/blob/main/CHANGELOG.md#v250" rel="noopener noreferrer" target="_blank"&gt;变更日志&lt;/a&gt;。&lt;/p&gt;&lt;h2 id="more-traceql-metrics"&gt;更多 TraceQL 指标&lt;/h2&gt;&lt;p&gt;&lt;a href="https://grafana.com/docs/tempo/latest/operations/traceql-metrics/?pg=blog&amp;amp;plcmt=body-txt"&gt;TraceQL 指标&lt;/a&gt;是 Grafana Tempo 中的一项实验性功能，可根据跟踪动态创建指标。我们正在努力实现全面可用性，因此请继续关注。&lt;/p&gt;&lt;p&gt;在&lt;a href="https://grafana.com/blog/2024/02/29/grafana-tempo-2.4-release-traceql-metrics-tiered-caching-and-tco-improvements/"&gt;Tempo 2.4&lt;/a&gt;中，我们引入了基本的&lt;code&gt;rate()&lt;/code&gt;方法。现在，在 2.5 中，我们添加了&lt;code&gt;quantile_over_time()&lt;/code&gt;和&lt;code&gt;histogram_over_time()&lt;/code&gt; ，允许用户聚合数值，例如最重要的跨度持续时间。请注意，您可以在同一查询中指定多个分位数。&lt;/p&gt;&lt;p&gt; &lt;code&gt;{ name = &amp;quot;GET /:endpoint&amp;quot; } | quantile_over_time(duration, .99, .9, .5)&lt;/code&gt;&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link captioned" href="https://grafana.com/media/blog/tempo-2.5/tempo-2.5-duration-quantiles-for-GET-endpoint-span.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="Duration quantiles over time." class="lazyload mb-0" title="*GET /:端点跨度的持续时间分位数。*" /&gt; &lt;noscript&gt;&lt;img alt="Duration quantiles over time." src="https://grafana.com/media/blog/tempo-2.5/tempo-2.5-duration-quantiles-for-GET-endpoint-span.png" title="*GET /:端点跨度的持续时间分位数。*" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;figcaption class="w-100p caption text-gray-13 "&gt; &lt;em&gt;GET /:endpoint 跨度的持续时间分位数。&lt;/em&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;您可以按任何范围或资源属性进行分组。&lt;/p&gt;&lt;p&gt; &lt;code&gt;{ name = &amp;quot;GET /:endpoint&amp;quot; } | quantile_over_time(duration, .99) by (span.http.target)&lt;/code&gt;&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link captioned" href="https://grafana.com/media/blog/tempo-2.5/tempo-2.5-duration-p99.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="Grouping by a span or resource attribute." class="lazyload mb-0" title="*span.http.target 的持续时间 p99。*" /&gt; &lt;noscript&gt;&lt;img alt="Grouping by a span or resource attribute." src="https://grafana.com/media/blog/tempo-2.5/tempo-2.5-duration-p99.png" title="*span.http.target 的持续时间 p99。*" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;figcaption class="w-100p caption text-gray-13 "&gt; &lt;em&gt;span.http.target 的持续时间 p99。&lt;/em&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;此外，分位数不仅限于跨度持续时间；跨度上的任何数字属性都是公平的游戏。为了演示这种级别的灵活性，请考虑&lt;code&gt;span.http.status_code&lt;/code&gt;上这个完全无意义的分位数：&lt;/p&gt;&lt;p&gt; &lt;code&gt;{ name = &amp;quot;GET /:endpoint&amp;quot; } | quantile_over_time(span.http.status_code, .99, .9, .5)&lt;/code&gt;&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link captioned" href="https://grafana.com/media/blog/tempo-2.5/tempo-2.5-span-http-status-code.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="A quantile of the span.http.status code." class="lazyload mb-0" title="*span.http.status_code 分位数（你永远不会真正这样做）。*" /&gt; &lt;noscript&gt;&lt;img alt="A quantile of the span.http.status code." src="https://grafana.com/media/blog/tempo-2.5/tempo-2.5-span-http-status-code.png" title="*span.http.status_code 分位数（你永远不会真正这样做）。*" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;figcaption class="w-100p caption text-gray-13 "&gt; &lt;em&gt;span.http.status_code 分位数（你永远不会真正这样做）。&lt;/em&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;这些功能都是前沿的，与往常一样，我们建议使用最新版本的 Grafana 和 Tempo 以获得最佳体验。&lt;/p&gt;&lt;h2 id="more-streaming-endpoints"&gt;更多流媒体端点&lt;/h2&gt;&lt;p&gt;在 2.5 中，我们对 Tempo 中的查询前端组件进行了重大重构。此重构包括许多性能改进，但我们主要是为了全面添加&lt;a href="https://github.com/grafana/tempo/blob/main/pkg/tempopb/tempo.proto#L34-L41" rel="noopener noreferrer" target="_blank"&gt;流式 gRPC 端点&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;目前，Grafana 仅支持 TraceQL 流式搜索端点，但我们希望尽快添加对其他端点的支持。我对 Grafana 支持流媒体指标端点感到特别兴奋，这样当 Tempo 检索数据时，我们就可以在屏幕上看到漂亮的指标线。&lt;/p&gt;&lt;p&gt;尽管 Grafana 尚不支持所有这些端点，但可以使用适当构建的 gRPC 客户端来调用它们，并且我们的&lt;a href="https://grafana.com/docs/tempo/latest/operations/tempo_cli/"&gt;Tempo CLI 工具&lt;/a&gt;也支持它们。例如，您可以像这样查询流指标：&lt;/p&gt;&lt;p&gt; &lt;code&gt;./tempo-cli query api metrics localhost:3200 &amp;#39;{ status = error } | rate() by (name)&amp;#39; –use-grpc&lt;/code&gt;&lt;/p&gt;&lt;h2 id="vparquet4-paves-the-way-for-new-features"&gt; vParquet4 为新功能铺平了道路&lt;/h2&gt;&lt;p&gt;vParquet4 是我们最新的 Parquet 版本。它在 Tempo 2.5 中可用，但直到下一个版本才会默认。 vParquet4 添加了新列以允许查询事件、链接、数组等。预计这些功能很快就会添加到 TraceQL 中！&lt;/p&gt;&lt;p&gt;要试验 vParquet4 并为新功能做好准备，您可以立即&lt;a href="https://grafana.com/docs/tempo/latest/configuration/parquet/#choose-a-different-block-format"&gt;配置 Tempo&lt;/a&gt;以使用它。我们要感谢红帽公司的&lt;a href="https://github.com/andreasgerstmayr" rel="noopener noreferrer" target="_blank"&gt;Andreas Gerstmayr&lt;/a&gt;添加列和代码，以便将&lt;a href="https://github.com/grafana/tempo/blob/main/pkg/tempopb/tempo.proto#L121-L127" rel="noopener noreferrer" target="_blank"&gt;每个服务的跨度和错误计数&lt;/a&gt;返回到我们的搜索结果中。我们预计很快会增加对 Grafana 的支持。&lt;/p&gt;&lt;h2 id="important-breaking-changes"&gt;重要的突破性变化&lt;/h2&gt;&lt;p&gt;Tempo 2.5 中有两个重大变化值得一提。&lt;/p&gt;&lt;p&gt;首先，&lt;a href="https://hub.docker.com/r/grafana/tempo/tags" rel="noopener noreferrer" target="_blank"&gt;官方 Docker 镜像&lt;/a&gt;中的 Tempo 进程曾经以&lt;code&gt;root&lt;/code&gt;身份运行。在此版本中，我们已将其更新为以&lt;code&gt;UID 10001&lt;/code&gt;运行（一个受欢迎的安全更新）。这意味着在磁盘上维护文件的摄取器和指标生成器等组件在没有干预的情况下不会干净地出现。新用户&lt;code&gt;10001&lt;/code&gt;将无权访问&lt;code&gt;root&lt;/code&gt;创建的旧文件。请参阅&lt;a href="https://grafana.com/docs/tempo/latest/release-notes/v2-5/"&gt;发行说明&lt;/a&gt;以获取有关升级的帮助。&lt;/p&gt;&lt;p&gt;接下来，原始 vParquet 格式&lt;a href="https://github.com/grafana/tempo/pull/3663" rel="noopener noreferrer" target="_blank"&gt;已从 Tempo 2.5 中删除&lt;/a&gt;。这意味着无法从 Tempo 2.1 直接升级到 Tempo 2.5。运营商需要升级到中间版本，并等待旧的 vParquet 块不再保留，然后再升级到 2.5。&lt;/p&gt;&lt;p&gt;有关重大变更的完整列表，请查看&lt;a href="https://grafana.com/docs/tempo/latest/release-notes/v2-5/"&gt;Grafana Tempo 2.5 发行说明&lt;/a&gt;或&lt;a href="https://github.com/grafana/tempo/blob/main/CHANGELOG.md#v250" rel="noopener noreferrer" target="_blank"&gt;变更日志&lt;/a&gt;。&lt;/p&gt;&lt;h2 id="whats-next-in-grafana-tempo"&gt; Grafana Tempo 的下一步是什么？&lt;/h2&gt;&lt;p&gt; Tempo 目前有两项主要举措。第一个是GA TraceQL指标，第二个是继续扩展TraceQL语言。&lt;/p&gt;&lt;p&gt;既然我们在代码库中正式拥有了 vParquet4，那么在即将发布的版本中，预计会在&lt;a href="https://github.com/grafana/tempo/blob/main/docs/design-proposals/2023-11%20TraceQL%20Extensions.md" rel="noopener noreferrer" target="_blank"&gt;TraceQL 语言扩展&lt;/a&gt;中详细介绍稳定的功能。&lt;/p&gt;&lt;p&gt;经过大量的努力，我们确定对指标的 RF3 跟踪进行重复数据删除不会达到我们想要的性能目标。因此，我们正在讨论 Tempo 的架构转变，以允许将 RF1 数据写入对象存储，同时保持当前的可用性和持久性水平。如果您想参与此对话，请参加&lt;a href="https://docs.google.com/document/d/1yGsI6ywU-PxZBjmq3p3vAXr9g5yBXSDk4NU8LGo8qeY/edit" rel="noopener noreferrer" target="_blank"&gt;每月一次的 Tempo 社区电话会议&lt;/a&gt;。我们正在讨论很多想法。&lt;/p&gt;&lt;p&gt;这将是 Tempo 运营方面的重大转变，我们预计将带来更低的 TCO、更快的 TraceQL 和大规模 TraceQL 指标。期待这里发生巨大的变化！&lt;/p&gt;&lt;p&gt;如果您有兴趣了解更多有关 Grafana Tempo 的新闻或搜索进度，请加入我们的&lt;a href="https://slack.grafana.com/" rel="noopener noreferrer" target="_blank"&gt;Grafana Labs 社区 Slack&lt;/a&gt;频道 #tempo，在&lt;a href="https://community.grafana.com/c/grafana-tempo/40" rel="noopener noreferrer" target="_blank"&gt;我们的社区论坛&lt;/a&gt;中发布问题，在&lt;a href="https://twitter.com/actually_chores" rel="noopener noreferrer" target="_blank"&gt;X（以前称为 Twitter&lt;/a&gt; ）上联系，或加入我们的&lt;a href="https://docs.google.com/document/d/1yGsI6ywU-PxZBjmq3p3vAXr9g5yBXSDk4NU8LGo8qeY/edit" rel="noopener noreferrer" target="_blank"&gt;每月 Tempo社区呼吁&lt;/a&gt;。到时候那里见！&lt;/p&gt;&lt;p&gt;如果您想更接近奇迹发生的地方，为什么不看看 Grafana Labs 的&lt;a href="https://grafana.com/about/careers/"&gt;空缺职位&lt;/a&gt;呢？&lt;/p&gt;&lt;p&gt;&lt;em&gt;开始使用&lt;a href="https://grafana.com/oss/tempo/?pg=blog"&gt;Grafana Tempo 的&lt;/a&gt;最简单方法是使用&lt;a href="https://grafana.com/products/cloud/?pg=blog"&gt;Grafana Cloud&lt;/a&gt; ，我们的永久免费套餐现在包括 50GB 跟踪以及 50GB 日志和 10K 系列指标。您可以&lt;a href="https://grafana.com/signup/cloud/connect-account?pg=blog"&gt;免费注册&lt;/a&gt;！&lt;/em&gt;&lt;/p&gt;</description><pubDate>Mon, 03 Jun 2024 11:45:00 GMT</pubDate><guid isPermaLink="true">https://grafana.com/blog/2024/06/03/grafana-tempo-2.5-release-vparquet4-streaming-endpoints-and-more-metrics/</guid></item><item><title>【Monitoring your morning commute with Grafana: the story of a Golden Grot Awards winner】使用 Grafana 监控您早上的通勤情况：金格罗特奖得主的故事</title><link>https://grafana.com/blog/2024/05/31/monitoring-your-morning-commute-with-grafana-the-story-of-a-golden-grot-awards-winner/</link><description>&lt;p&gt;“如果你住在亚特兰大，交通就会很糟糕；这很糟糕。如果有一天天气不好，那就更糟了。”&lt;/p&gt;&lt;p&gt;你不必住在亚特兰大附近的任何地方，就能体会到鲁本·费尔南德斯在这里分享的情感。我们大多数人都经历过在都市区或周边地区通勤所带来的挫折，因此鲁本领先于当地道路瓶颈的新颖方法使他成为今年&lt;a href="https://grafana.com/about/events/grafanacon/2024/golden-grot-awards/"&gt;金格罗特奖（&lt;/a&gt;我们的年度奖项）的获奖者之一也就不足为奇了。表彰个人和专业仪表板中的最佳作品。&lt;/p&gt;&lt;p&gt; Ruben 在个人仪表板类别中获胜， &lt;a href="https://cuponesruben.grafana.net/public-dashboards/bc2d84c6d80e4acf9e826a32c4620351?orgId=1&amp;amp;refresh=5s" rel="noopener noreferrer" target="_blank"&gt;他构建了 Grafana 仪表板&lt;/a&gt;来帮助他导航早上去办公室的行程，包括何时离开以及采取哪种交通方式。他使用 API 和 GTFS 实时提要从&lt;a href="https://www.weather.gov/" rel="noopener noreferrer" target="_blank"&gt;Weather.gov&lt;/a&gt;和&lt;a href="https://www.itsmarta.com/" rel="noopener noreferrer" target="_blank"&gt;亚特兰大大都会交通管理局&lt;/a&gt;获取数据，以及从 Google 地图和 Bing 地图获取行驶时间和交通信息。他还使用 Python 的 Prometheus 检测库来组合指标并将其发送到&lt;a href="https://grafana.com/products/cloud/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana Cloud&lt;/a&gt; 。&lt;/p&gt;&lt;div class="shortcode youtube"&gt;&lt;/div&gt;&lt;h2 id="gridlock-bad-weather-and-a-return-to-the-office"&gt; 交通堵塞、恶劣天气和返回办公室&lt;/h2&gt;&lt;p&gt;Ruben 18 个月前开始使用 Grafana，作为 SRE 工作的一部分。他对去年的&lt;a href="https://grafana.com/blog/2023/06/15/meet-our-golden-grot-awards-grand-prize-winners/"&gt;首届金格罗特奖&lt;/a&gt;很感兴趣，并开始思考自己可以建造什么供自己个人使用，也可以提交今年的奖项。他寻找可能支持他的项目的公共数据源，就在那时他收到了一些灵​​感。&lt;/p&gt;&lt;p&gt;鲁本被告知他需要在大流行后返回办公室，他开始查看公交车时刻表和开车时间，这让他考虑跟踪天气并将所有这些信息捆绑在一个地方。&lt;/p&gt;&lt;p&gt; “交通时间可能从 25 分钟缩短到 1 小时；它可能会在这个范围内发生变化。于是我就想，每天早上我要检查什么？天气怎么样？交通状况如何？我的通勤时间要多长？”鲁本说。 “我应该坐火车吗？因为开车要花一个小时？我不喜欢那样。我更喜欢坐公共汽车，然后在火车上我可以读书。因此，将所有信息集中在一处，我可以更轻松地了解必须做什么。”&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/golden-grot/2024/dashboards/screenshot-goldengrot-ruben-fernandez.gif"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="鲁本的仪表板" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="鲁本的仪表板" src="https://grafana.com/media/golden-grot/2024/dashboards/screenshot-goldengrot-ruben-fernandez.gif" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;鲁本继续寻找改进他的仪表板的方法。他希望纳入移动通知，甚至考虑纳入外带咖啡订单，看看这将如何影响他的到达时间。与此同时，他说很高兴看到他的家人和同事对他的胜利感到多么兴奋。&lt;/p&gt;&lt;p&gt; “工作了 30 年，我从来没有遇到过这样的事情，”鲁本说。 “没有人真正认可我的工作，所以他们非常高兴——我的家人、我的朋友、每个人。”&lt;/p&gt;&lt;p&gt;他还感谢社区的支持，帮助从决赛入围者名单中选出获胜者。&lt;/p&gt;&lt;p&gt; “这让我感到自豪，”他说。 “当人们给你颁奖时，他们是在告诉你，你做了一些好事，所以是的，我喜欢这一点。”&lt;/p&gt;&lt;h2 id="what-makes-a-great-dashboard"&gt;是什么造就了一个出色的仪表板？&lt;/h2&gt;&lt;p&gt; Ruben 的仪表板以其实用性和独创性令评委们惊叹不已。&lt;/p&gt;&lt;p&gt; “想象一个人在上班前查看 Grafana 仪表板是非常未来主义和有趣的，”一位评委说。&lt;/p&gt;&lt;p&gt;另一位法官表示：“Ruben 将 Grafana 用于一个非常有用的用例，世界各地的许多人都在努力解决这个问题：高效的日常通勤。” “Ruben 没有手动查找有关交通拥堵、公共汽车和火车运输时刻表、天气等信息，而是创建了一个令人惊叹的仪表板，该仪表板汇集了所有这些信息，并提供了很好的概述和支持，使通勤变得更加轻松和更多数据驱动的决策。对于每天通勤上班的人来说，我建议创建一个类似的仪表板来简化日常决策过程。”&lt;/p&gt;&lt;p&gt;鲁本认为他的仪表板之所以脱颖而出，是因为其非典型用例和实时视频源的结合。他承认，很难找到时间来学习构建仪表板和查找数据源，尤其是作为工作和家庭时间之后的业余项目。但对于那些希望构建自己的仪表板供个人使用的人来说，他表示关键是不要被吓倒。&lt;/p&gt;&lt;p&gt; “不要放弃，”鲁本说。 “很多次你都会说，‘好吧，算了吧。我不想这么做。但有一天，像我一样，你有了[灵感]，有些事情发生了变化，你跟上，然后你开始添加东西，你变得兴奋，然后你再次上升。所以不要因为有一些怀疑就扔掉它；继续前进。”&lt;/p&gt;</description><pubDate>Fri, 31 May 2024 00:00:00 GMT</pubDate><guid isPermaLink="true">https://grafana.com/blog/2024/05/31/monitoring-your-morning-commute-with-grafana-the-story-of-a-golden-grot-awards-winner/</guid></item><item><title>【How to export any Grafana visualization to a CSV file, Microsoft Excel, or Google Sheets】如何将任何 Grafana 可视化导出到 CSV 文件、Microsoft Excel 或 Google Sheets</title><link>https://grafana.com/blog/2024/05/30/how-to-export-any-grafana-visualization-to-a-csv-file-microsoft-excel-or-google-sheets/</link><description>&lt;p&gt;Grafana 仪表板是将大量技术信息合并到一张方便的图片中的好方法。有时，将数据从特定的 Grafana 可视化导出为另一种格式也很有用，这样您就可以进一步分析它并与其他人共享。&lt;/p&gt;&lt;p&gt;在这篇博文中，我们将介绍如何为您使用的任何 Grafana 可视化导出 CSV 数据。这样可以轻松地将数据导入流行的电子表格应用程序，例如 Microsoft Excel 或 Google Sheets。本文中描述的步骤在三个方面是通用的：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;它们适用于任何 Grafana 可视化，因为在幕后，所有可视化都只是将一系列数据帧绘制到屏幕上。&lt;/li&gt;&lt;li&gt;它们适用于任何数据源（关系或非关系），因为查询结果会转换为相同的数据帧。&lt;/li&gt;&lt;li&gt;它们将在 Grafana 仪表板上或任何&lt;a href="https://grafana.com/docs/grafana/latest/explore/"&gt;Grafana Explore&lt;/a&gt;查询中工作。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我们将使用&lt;a href="https://play.grafana.org/d/000000012/grafana-play-home?orgId=1" rel="noopener noreferrer" target="_blank"&gt;Grafana Play&lt;/a&gt;上的&lt;a href="https://play.grafana.org/d/000000003/1-graphite3a-sample-website-dashboard?orgId=1" rel="noopener noreferrer" target="_blank"&gt;示例网站监控仪表板&lt;/a&gt;。您可以使用该示例仪表板执行本文中显示的所有操作。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/export-visualizations/export_visualizations_sample_dashboard.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="Grafana 仪表板示例的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="Grafana 仪表板示例的屏幕截图。" src="https://grafana.com/media/blog/export-visualizations/export_visualizations_sample_dashboard.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;h2 id="pick-the-data-you-want-to-export"&gt;选择您要导出的数据&lt;/h2&gt;&lt;p&gt;让我们从服务器请求仪表板中的数据开始，该数据显示在下面的时间序列面板中。请注意，在图例中，我们显示了四个不同 Web 服务器的堆叠线：01、02、03 和 04。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/export-visualizations/export_visualizations_time_series_panel.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="时间序列面板的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="时间序列面板的屏幕截图。" src="https://grafana.com/media/blog/export-visualizations/export_visualizations_time_series_panel.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;在可视化顶部的三点菜单中，选择&lt;strong&gt;“检查”&lt;/strong&gt; &amp;gt; &lt;strong&gt;“数据”&lt;/strong&gt; 。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/export-visualizations/export_visualizations_inspect_data.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="显示导航至“数据”选项的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="显示导航至“数据”选项的屏幕截图。" src="https://grafana.com/media/blog/export-visualizations/export_visualizations_inspect_data.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;在右侧，您会看到一个托盘滑出。这是可视化中显示的数据的表格格式版本，带有蓝色的&lt;strong&gt;“下载 CSV”&lt;/strong&gt;按钮。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/export-visualizations/export_visualizations_inspect_server_requests.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="服务器请求指标的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="服务器请求指标的屏幕截图。" src="https://grafana.com/media/blog/export-visualizations/export_visualizations_inspect_server_requests.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;&lt;em&gt;&lt;strong&gt;如果这就是您所需要的，那么您就完成了！&lt;/strong&gt;&lt;/em&gt;但此功能还有更多功能；继续阅读以了解它的工作原理、如何将其与 Grafana Explore 一起使用，以及您还可以用它做什么。&lt;/p&gt;&lt;h2 id="select-and-download-a-data-frame"&gt;选择并下载数据框&lt;/h2&gt;&lt;p&gt;从 Grafana 可视化中获取 CSV 和表格数据并不像看起来那么明显；&lt;a href="https://grafana.com/docs/grafana/latest/fundamentals/dashboards-overview/#plugins"&gt;从数据源进入插件的&lt;/a&gt;数据可能采用多种不同的格式（例如 JSON、行和列或 CSV），但是当它通过其余的大门走向可视化时，它始终位于&lt;a href="https://grafana.com/developers/plugin-tools/introduction/data-frames"&gt;数据帧&lt;/a&gt;中。当您导出数据时，您正在导出由某些查询生成的 Grafana&lt;em&gt;数据框&lt;/em&gt;- 您不是直接从基础数据源导出数据。&lt;/p&gt;&lt;p&gt;在此背景下，让我们展开&lt;strong&gt;“检查”&lt;/strong&gt;菜单中的&lt;strong&gt;“数据选项”&lt;/strong&gt;部分，看看除了简单导出到 CSV 之外我们还能做什么。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/export-visualizations/export_visualizations_web_server_01.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="显示数据选项的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="显示数据选项的屏幕截图。" src="https://grafana.com/media/blog/export-visualizations/export_visualizations_web_server_01.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;如果您在上一步中仔细观察，您可能会注意到我们导出的数据仅适用于第一个 Web 服务器 - web_server_01 - 而不是所有四个框架。在上面的对话框中，我们可以看到 Grafana 将整个可视化分为四个框架，我们可以单独导出每个框架。&lt;/p&gt;&lt;p&gt;但是，如果您有一个包含多行的时间序列（正如我们在此处的示例中所做的那样），您通常需要电子表格中的所有数据，而不仅仅是其中一行。为此，我们可以选择&lt;strong&gt;按时间连接的系列选项&lt;/strong&gt;，该选项导出您在可视化中看到的所有数据。&lt;/p&gt;&lt;p&gt;我们示例中的四个系列是四个独立的数据集，每个数据集包含单个 Web 服务器的时间和数据点。当我们按时间连接它们时，我们将所有数据重新组合到我们之前在时间序列图表中看到的同一时间线上。&lt;/p&gt;&lt;p&gt;如下所示，还有适用于 CSV 处理应用程序和 Excel 的格式化数据和添加标题的选项。我将选择&lt;strong&gt;“下载 Excel”&lt;/strong&gt;以将该标题行添加到我的数据中，然后单击&lt;strong&gt;“下载 CSV”&lt;/strong&gt; 。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/export-visualizations/export_visualizations_series_joined_by_time.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="显示按时间连接的系列选项的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="显示按时间连接的系列选项的屏幕截图。" src="https://grafana.com/media/blog/export-visualizations/export_visualizations_series_joined_by_time.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;下载的文件名为&lt;code&gt;server requests-data-as-joinbyfield-2024-05-06 13_45_39.csv&lt;/code&gt; ，这很方便，因为它准确地告诉我们导出的内容和时间。这意味着，如果您对许多可视化执行此操作，您可以将数据分开并记住是什么。&lt;/p&gt;&lt;p&gt;最后一步是将生成的 CSV 导入 Google Sheets、Microsoft Excel 或您使用的任何其他应用程序。由于标头已经存在，因此数据到达时应如下所示：&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/export-visualizations/export_visualizations_spreadsheet.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="包含服务器请求数据的电子表格的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="包含服务器请求数据的电子表格的屏幕截图。" src="https://grafana.com/media/blog/export-visualizations/export_visualizations_spreadsheet.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;h2 id="export-data-from-grafana-explore"&gt;从 Grafana Explore 导出数据&lt;/h2&gt;&lt;p&gt;如果您还没有仪表板，您可能只想使用 Grafana Explore 来运行查询并导出数据。这也是可行的。&lt;/p&gt;&lt;p&gt;让我们看一下&lt;a href="https://play.grafana.org/explore?schemaVersion=1&amp;amp;panes=%7B%22agk%22:%7B%22datasource%22:%22grafanacloud-prom%22,%22queries%22:%5B%7B%22refId%22:%22A%22,%22expr%22:%22aws_ec2_cpuutilization_average%22,%22range%22:true,%22instant%22:true,%22datasource%22:%7B%22type%22:%22prometheus%22,%22uid%22:%22grafanacloud-prom%22%7D,%22editorMode%22:%22builder%22,%22legendFormat%22:%22__auto%22,%22useBackend%22:false,%22disableTextWrap%22:false,%22fullMetaSearch%22:false,%22includeNullMetadata%22:true%7D%5D,%22range%22:%7B%22from%22:%22now-1h%22,%22to%22:%22now%22%7D%7D%7D&amp;amp;orgId=1" rel="noopener noreferrer" target="_blank"&gt;Play 上 Prometheus 指标探索的链接&lt;/a&gt;。在 Explore 视图中，我们正在对&lt;code&gt;aws_ec2_cpuutilization_average&lt;/code&gt;执行一个非常简单的 PromQL 查询。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/export-visualizations/export_visualizations_prometheus_metrics.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="浏览视图中 PromQL 查询的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="浏览视图中 PromQL 查询的屏幕截图。" src="https://grafana.com/media/blog/export-visualizations/export_visualizations_prometheus_metrics.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;在这里，我们将点击&lt;strong&gt;查询检查器&lt;/strong&gt;按钮来查看发送到数据库的查询的详细信息。&lt;/p&gt;&lt;p&gt;在下面打开的托盘中，右侧标记为&lt;strong&gt;“数据”&lt;/strong&gt;的选项卡将显示我们从面板可视化导出数据时看到的所有相同选项。上面所说的一切在这里都适用：数据框的选择、标题行以及如何导出。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/export-visualizations/export_visualizations_aws_ec2.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="“数据”选项卡的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="“数据”选项卡的屏幕截图。" src="https://grafana.com/media/blog/export-visualizations/export_visualizations_aws_ec2.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;h2 id="wrapping-up"&gt;包起来&lt;/h2&gt;&lt;p&gt;Grafana 在内部将您的数据作为一系列数据帧进行处理，无论数据来自何处或最初如何存储和查询。这意味着导出数据相当简单；我们只是将这些数据框转换为 CSV 文件，您可以将其与任何电子表格应用程序或任何其他软件一起使用。&lt;/p&gt;&lt;p&gt;有关 Grafana 仪表板的所有部分如何协同工作的更多信息，&lt;a href="https://grafana.com/docs/grafana/latest/fundamentals/dashboards-overview/"&gt;请查看我们的仪表板概述&lt;/a&gt;。如果您对此主题还有任何其他问题，请随时在&lt;a href="https://community.grafana.com/" rel="noopener noreferrer" target="_blank"&gt;Grafana 社区网站&lt;/a&gt;上提问！&lt;/p&gt;&lt;p&gt; &lt;em&gt;&lt;a href="https://grafana.com/products/cloud/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana Cloud&lt;/a&gt;是开始使用仪表板、指标、日志、跟踪等的最简单方法。我们为每个用例提供慷慨的永久免费套餐和计划。&lt;a href="https://grafana.com/auth/sign-up/create-user/?pg=blog&amp;amp;plcmt=body-txt"&gt;现在免费注册&lt;/a&gt;！&lt;/em&gt;&lt;/p&gt;</description><pubDate>Thu, 30 May 2024 16:11:00 GMT</pubDate><guid isPermaLink="true">https://grafana.com/blog/2024/05/30/how-to-export-any-grafana-visualization-to-a-csv-file-microsoft-excel-or-google-sheets/</guid></item><item><title>【Grafana Loki query acceleration: How we sped up queries without adding resources】Grafana Loki 查询加速：我们如何在不添加资源的情况下加速查询</title><link>https://grafana.com/blog/2024/05/29/grafana-loki-query-acceleration-how-we-sped-up-queries-without-adding-resources/</link><description>&lt;p&gt;正如我们在&lt;a href="https://grafana.com/blog/2024/04/09/grafana-loki-3.0-release-all-the-new-features/"&gt;推出 Grafana Loki 最新主要版本&lt;/a&gt;时所讨论的那样，我们在过去五年中通过平衡功能开发和大规模支持用户来发展日志聚合系统。后者的一个重要部分是使查询速度更快——这也是 Loki 3.0 的主要关注点。&lt;/p&gt;&lt;p&gt;我们已经看到峰值查询吞吐量从 Loki 1.0 时代的 10 GB/s 增长到 3.0 之前的 1 TB/s 以上。然而，为了进一步发展，并确保我们恪守成本效益高且易于开发人员使用的原则，我们一直在寻找变得更聪明的机会。&lt;/p&gt;&lt;p&gt;例如，我们最近注意到&lt;a href="https://grafana.com/docs/loki/latest/query/log_queries/?pg=blog&amp;amp;plcmt=body-txt#line-filter-expression"&gt;过滤器查询&lt;/a&gt;的一个有趣的事情：它们接触了很多他们不需要的数据。在 7 天的时间里，我们的 Grafana Labs 产品集群处理了 280 PB 的日志。从总数中，大约 140 PB 的搜索日志与任何过滤表达式都不匹配。也就是说，50%的搜索数据没有返回结果！更糟糕的是，每 100 万条日志中，65% 的处理数据 (182 PB) 最多只返回一条日志行。&lt;/p&gt;&lt;p&gt;当然，我们可以通过投入更多计算资源来解决吞吐量问题，但这与我们让 Loki 具有成本效益和可扩展性的愿景不符。相反，我们将此视为挑战&lt;em&gt;和&lt;/em&gt;机遇。我们如何改善这些返回速度更快的过滤查询的体验，同时仍然保持 Loki 的易用性和成本效益原则？&lt;/p&gt;&lt;p&gt;输入查询加速，这是 Loki 3.0 中包含的一项实验性功能。&lt;/p&gt;&lt;h2 id="how-we-approached-query-acceleration-in-loki"&gt;我们如何在 Loki 中实现查询加速&lt;/h2&gt;&lt;p&gt;在深入研究之前，我们应该快速介绍一下我们将在本博文中使用的两个概念： &lt;a href="https://en.wikipedia.org/wiki/N-gram" rel="noopener noreferrer" target="_blank"&gt;n-gram&lt;/a&gt;和&lt;a href="https://en.wikipedia.org/wiki/Bloom_filter" rel="noopener noreferrer" target="_blank"&gt;布隆过滤器&lt;/a&gt;。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;我们使用&lt;strong&gt;n-gram&lt;/strong&gt;作为子串的排列。例如，给定字符串“abcdef”，不同的三元组（n-gram，其中 n=3）是“abc”、“bcd”、“cde”和“def”。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;布隆过滤器&lt;/strong&gt;是允许概率匹配的数据结构。它们允许一些误报，但&lt;em&gt;不允许&lt;/em&gt;误报。它们在数据库领域有着悠久的使用历史。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;如上所述，我们观察到大多数数据在查询时都是不相关的——它从来没有机会对特定查询有价值。因此，我们意识到识别和消除不相关数据本质上与仅搜索相关数据相同。此外，因为我们选择关注“数据不存在的地方”，所以我们寻找一种空间有效的数据结构，它为我们提供了对过滤器查询的相关数据可能在哪里的“足够好”的估计，这将那么让我们忽略其余的数据。&lt;/p&gt;&lt;p&gt;另一个关键成分是 n-gram。它们使我们能够保持“结构无意识”，这使得 Loki 如此易于使用（无模式）。它创建了大量数据，但我们受益于&lt;em&gt;许多日志行具有共同信息&lt;/em&gt;的事实。例如，下面所有以绿色突出显示的文本都显示了不同日志中的重复文本，即所谓的公共信息。&lt;/p&gt;&lt;p&gt; &lt;span style="color: green;"&gt;msg=”将商品添加到购物车” userID=”&lt;/span&gt; a4hbfer74g &lt;span style="color: green;"&gt;” itemID=”&lt;/span&gt; jr8fdnasd65u4”&lt;/p&gt;&lt;p&gt; &lt;span style="color: green;"&gt;msg=”将商品添加到购物车” userID=”&lt;/span&gt; a4hbfer74g &lt;span style="color: green;"&gt;” itemID=”&lt;/span&gt; 78kjasdj4hs21”&lt;/p&gt;&lt;p&gt; &lt;span style="color: green;"&gt;msg =“将商品添加到购物车”userID =“&lt;/span&gt; h74jndvys6 &lt;span style="color: green;"&gt;”itemID =“&lt;/span&gt; yclk37uzs95j8”&lt;/p&gt;&lt;p&gt;幸运的是，布隆过滤器的本质意味着重复是免费的，因此日志行的熵帮助我们解决了空间（成本）问题。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/loki-query-acceleration/bloom-filters-code.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="颜色编码的日志线，绿色表示经常，黄色表示有时，红色表示很少" class="lazyload " /&gt; &lt;noscript&gt;&lt;img alt="颜色编码的日志线，绿色表示经常，黄色表示有时，红色表示很少" src="https://grafana.com/media/blog/loki-query-acceleration/bloom-filters-code.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;把所有这些加起来，我们最终得到了以下方法，我们将在下一节中深入探讨：&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/loki-query-acceleration/ngrams-as-bloom-filter-keys.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="N-gram 作为布隆过滤器键映射" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="N-gram 作为布隆过滤器键映射" src="https://grafana.com/media/blog/loki-query-acceleration/ngrams-as-bloom-filter-keys.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;这意味着所有过滤器查询都可以从 Bloom 中受益，顺便说一句，我们目前看到的 Bloom 大小约为日志本身大小的 2%。&lt;/p&gt;&lt;p&gt;除了我们已经讨论过的所有内容之外，查询加速还附带了全新的查询分片策略，我们利用布隆过滤器来产生更少、更公平的查询分片。&lt;/p&gt;&lt;p&gt;传统上，通过分析 TSDB 索引统计数据，Loki 会确定最接近的 2 的幂，以将数据划分为理论上大小大致相等的分片。不幸的是，当某些系列的数据比其他系列多得多时，情况通常并非如此。因此，某些分片最终会比其他分片处理更多的数据。&lt;/p&gt;&lt;p&gt;我们现在使用布隆过滤器来减少查询前端规划阶段要立即处理的块数量，并均匀分配每个分片查询需要处理的块数量。&lt;/p&gt;&lt;h2 id="how-the-bloom-filter-components-work"&gt;布隆过滤器组件如何工作&lt;/h2&gt;&lt;p&gt;让我们深入了解一下布隆过滤器是如何创建的以及如何使用它们来匹配过滤表达式。我们引入了两个新组件：Bloom 压缩器和 Bloom 网关。&lt;/p&gt;&lt;p&gt;布隆压缩器根据对象存储中的块构建布隆过滤器。我们为每个系列构建一个 Bloom，并将它们聚合到块文件中。 Bloom 区块中的 Series 遵循与 Loki 的&lt;a href="https://grafana.com/docs/loki/latest/operations/storage/tsdb/?pg=blog&amp;amp;plcmt=body-txt"&gt;TSDB&lt;/a&gt;和分片计算相同的排序方案。这在查询时提供了数据局部性优势，因为同一分片中的系列可能位于同一块中。除了块之外，压缩器还维护一个元数据文件列表，其中包含对 Bloom 块的引用以及构建它们的 TSDB 索引文件。&lt;/p&gt;&lt;p&gt;布隆压缩器是水平可扩展的，它们使用环来分片租户并声明该系列键空间子集的所有权。对于给定的系列，拥有该系列的压缩器将迭代其块内的所有日志行并构建 Bloom。对于每个日志行，我们计算其 n-gram 并将每个 n-gram 的哈希值和每个 n-gram 的哈希值加上块标识符附加到 Bloom。前者允许网关跳过整个系列，而后者则用于跳过单个块。&lt;/p&gt;&lt;p&gt;例如，给定块&lt;span style="color: green;"&gt;“aaf67d”&lt;/span&gt;中的日志行&lt;span style="color: green;"&gt;“abcdef”&lt;/span&gt; ，我们计算其n-gram： &lt;span style="color: green;"&gt;“abc”，“bcd”，“cde”，“def”&lt;/span&gt; 。并附加到系列 Bloom &lt;span style="color: green;"&gt;hash(“abc”)&lt;/span&gt; 、 &lt;span style="color: green;"&gt;hash(“abc” + “aaf67d”)&lt;/span&gt; ... &lt;span style="color: green;"&gt;hash(“def”)&lt;/span&gt; 、 &lt;span style="color: green;"&gt;hash(“def” + ““aaf67d”)&lt;/span&gt; 。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/loki-query-acceleration/bloom-compactor.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="Bloom 压缩器架构" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="Bloom 压缩器架构" src="https://grafana.com/media/blog/loki-query-acceleration/bloom-compactor.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;另一方面，Bloom 网关处理来自索引网关的块过滤请求。该服务获取块列表和过滤表达式，并将它们与布隆过滤器进行匹配，删除那些与给定过滤器表达式不匹配的块。&lt;/p&gt;&lt;p&gt;与 Bloom 压缩器一样，新网关也可水平扩展，并将环用于与压缩器相同的目的：对租户和系列键空间进行分片。索引网关使用环来根据这些块的系列指纹来确定它们应该发送块过滤请求的 Bloom 网关。&lt;/p&gt;&lt;p&gt;通过将 n-gram 添加到压缩器中的 Bloom 过滤器而不是整个日志行，Bloom 网关可以执行部分​​匹配。对于上面的示例，过滤器表达式&lt;span style="color: green;"&gt;|= “abcd”&lt;/span&gt;将生成两个 n 元语法： &lt;span style="color: green;"&gt;“abc”&lt;/span&gt;和&lt;span style="color: green;"&gt;“bcd”&lt;/span&gt; 。两者都将与布鲁姆比赛。&lt;/p&gt;&lt;p&gt;现在，对于该系列中的每个块，我们可以通过将块 ID 附加到 n-gram 来再次测试 Bloom。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/loki-query-acceleration/bloom-gateway.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="Bloom网关架构" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="Bloom网关架构" src="https://grafana.com/media/blog/loki-query-acceleration/bloom-gateway.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;总的来说，下图展示了我们如何构建 Bloom，以及如何使用它们来跳过与过滤表达式中的 n 元语法不匹配的序列和块：&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/loki-query-acceleration/architecture.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="组合架构" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="组合架构" src="https://grafana.com/media/blog/loki-query-acceleration/architecture.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt; N 元语法的大小是可配置的。 n-gram 越长，我们需要附加到布隆过滤器的标记就越少。然而，较长的过滤表达式需要能够根据布隆过滤器检查它们。对于上面的示例，n 元语法长度为 3，我们需要过滤至少包含 3 个字符的表达式。&lt;/p&gt;&lt;h2 id="creating-a-good-user-experience"&gt;创造良好的用户体验&lt;/h2&gt;&lt;p&gt;当然，我们的主要目标是让查询更快地返回数据！对于特别小的“针”，例如查找 UUID 或其他很少出现的字符串，这种方法往往效果更好。&lt;/p&gt;&lt;p&gt;布隆过滤器对于精确搜索特别有用 - 例如，如果您正在查找提及特定客户 ID 或唯一错误代码的所有日志。我们发现这对于使用 Loki 的开发人员和支持工程师来说是一种非常常见的模式。由于 Bloom 过滤器允许 Loki 仅处理可能包含这些术语的日志，并且这些术语可能出现在很少的日志行中，因此对搜索时间的影响很大。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link captioned" href="https://grafana.com/media/blog/loki-query-acceleration/support-ticket.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="Support ticket" class="lazyload mb-0" title="*常见用例的示例*" /&gt;&lt;noscript&gt;&lt;img alt="Support ticket" src="https://grafana.com/media/blog/loki-query-acceleration/support-ticket.png" title="*常见用例的示例*" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;figcaption class="w-100p caption text-gray-13 "&gt;&lt;em&gt;常见用例的示例&lt;/em&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;所有迹象都表明布隆过滤器确实有效。早期的内部测试表明，使用 Bloom 过滤器，Loki 可以在运行查询时跳过很大一部分日志数据。我们的开发环境测试表明，我们现在可以过滤掉之前处理查询所需的 70% 到 90% 的块。&lt;/p&gt;&lt;p&gt;下面是我们在使用布隆过滤器运行“大海捞针”搜索之一时看到的结果示例。该查询包含多个过滤条件，代表了我们看到客户在由 Loki 提供支持的&lt;a href="https://grafana.com/products/cloud/logs/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana Cloud Logs&lt;/a&gt;上运行的典型用例。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link captioned" href="https://grafana.com/media/blog/loki-query-acceleration/filter-ration.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="Filter ratio" class="lazyload mb-0" title="*使用blooms绕过的块和系列的百分比*" /&gt; &lt;noscript&gt;&lt;img alt="Filter ratio" src="https://grafana.com/media/blog/loki-query-acceleration/filter-ration.png" title="*使用blooms绕过的块和系列的百分比*" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;figcaption class="w-100p caption text-gray-13 "&gt;&lt;em&gt;使用绽放绕过的块和系列的百分比&lt;/em&gt;&lt;/a&gt;&lt;/figure&gt;&lt;h3 id="a-note-of-caution-on-use-cases"&gt;关于用例的注意事项&lt;/h3&gt;&lt;p&gt;在我们当前的实现中，并非每个查询都会受益于布隆过滤器。让我们看一下布隆过滤器会被调用和不会被调用的条件：&lt;/p&gt;&lt;p&gt;使用blooms的查询应满足以下条件：&lt;/p&gt;&lt;ul class="bullet-img-check"&gt;&lt;li&gt;查询应至少包含一个过滤表达式。而&lt;span style="color: green;"&gt;{env=“prod”} |= “order=17863472” | logfmt&lt;/span&gt;将使用布隆过滤器， &lt;span style="color: green;"&gt;{env=“prod”} | logmt&lt;/span&gt;不会。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;但是，以下内容将阻止查询利用绽放：&lt;/p&gt;&lt;ul class="bullet-img-check-red-3"&gt;&lt;li&gt;布隆过滤器不用于不等于过滤器：常规过滤器和正则表达式过滤器。 &lt;span style="color: green;"&gt;!= “debug”&lt;/span&gt;和&lt;span style="color: green;"&gt;!~ “(staging|dev)&lt;/span&gt;都不会使用布隆过滤器。&lt;/li&gt;&lt;li&gt;在行格式化表达式之后过滤表达式不会使用布隆过滤器。例如&lt;span style="color: green;"&gt;|= `level=“error”` |对数函数 | line_format “ERROR {{.err}}” |= `traceID=“3ksn8d4jj3”`&lt;/span&gt;其中&lt;span style="color: green;"&gt;|= `level=“error”`&lt;/span&gt;将从 Bloom 过滤器中受益，但&lt;span style="color: green;"&gt;|= `traceID=“3ksn8d4jj3”`&lt;/span&gt;则不会。&lt;/li&gt;&lt;li&gt;尚未在 Bloom 网关上下载 Bloom 块的查询。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我们还能够以一种符合 Loki 易用性原则之一的方式来实现这一点：&lt;strong&gt;大规模无模式&lt;/strong&gt;。因此，除了数据返回速度更快之外，查询体验看起来完全相同。您仍然可以以相同的方式提取数据。当我们在&lt;a href="https://grafana.com/products/cloud/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana Cloud&lt;/a&gt;中推出这一功能时，无需进行任何配置即可在客户端使用 Blooms。&lt;/p&gt;&lt;h2 id="looking-ahead"&gt;展望未来&lt;/h2&gt;&lt;p&gt;这是一个非常有前途的实验性功能，但这只是一个开始。我们已经让它发挥作用了：现在是时候让它变得更简单、更快了！要了解有关查询加速的更多信息，以及如何在 Loki 集群中启用它，请查看&lt;a href="https://grafana.com/docs/loki/latest/?pg=oss-loki&amp;amp;plcmt=quick-links"&gt;Loki 3.0 文档&lt;/a&gt;。&lt;/p&gt;&lt;p&gt; &lt;em&gt;&lt;a href="https://grafana.com/products/cloud/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana Cloud&lt;/a&gt;是开始使用指标、日志、跟踪、仪表板等的最简单方法。我们为每个用例提供慷慨的永久免费套餐和计划。&lt;a href="https://grafana.com/auth/sign-up/create-user/?pg=blog&amp;amp;plcmt=body-txt"&gt;现在免费注册&lt;/a&gt;！&lt;/em&gt;&lt;/p&gt;</description><pubDate>Wed, 29 May 2024 00:00:00 GMT</pubDate><guid isPermaLink="true">https://grafana.com/blog/2024/05/29/grafana-loki-query-acceleration-how-we-sped-up-queries-without-adding-resources/</guid></item><item><title>【Grafana OnCall: Use the new bi-directional ServiceNow integration for seamless alert flows】Grafana OnCall：使用新的双向 ServiceNow 集成实现无缝警报流</title><link>https://grafana.com/blog/2024/05/28/grafana-oncall-use-the-new-bi-directional-servicenow-integration-for-seamless-alert-flows/</link><description>&lt;p&gt;当您管理可能影响您的服务和客户的事件时，每一刻都很重要。这就是为什么我们很高兴在&lt;a href="https://grafana.com/products/cloud/oncall/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana OnCall&lt;/a&gt;和 ServiceNow 之间引入新的双向集成，ServiceNow 是许多大型组织用来帮助管理事件的流行平台。&lt;/p&gt;&lt;p&gt;借助&lt;a href="https://grafana.com/products/cloud/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana Cloud&lt;/a&gt;中现已提供的这一新功能，警报可以从 Grafana OnCall 流向 ServiceNow，反之亦然，有助于保持事件状态同步，以便每个人都在同一页面上。这一强大的集成是可配置的，无论您是调整 ServiceNow 凭据还是微调警报行为，您都可以在一个地方进行必要的更改。&lt;/p&gt;&lt;p&gt;让我们详细了解一下这个新功能，以及如何使用它来实现更有凝聚力的事件响应。&lt;/p&gt;&lt;h2 id="route-servicenow-incidents-to-grafana-oncall"&gt;将 ServiceNow 事件路由到 Grafana OnCall&lt;/h2&gt;&lt;p&gt;通过新的集成，在 ServiceNow 中创建的事件可以在 Grafana OnCall 中自动生成相应的警报组。例如，假设您想在 ServiceNow 中创建一个事件，如下所示：&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/grafana-oncall-servicenow/servicenow-ui.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="ServiceNow UI 事件菜单" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="ServiceNow UI 事件菜单" src="https://grafana.com/media/blog/grafana-oncall-servicenow/servicenow-ui.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;一旦您在 ServiceNow 中触发该事件，Grafana OnCall 将自动创建相应的警报组：&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/grafana-oncall-servicenow/corresponding-alert-group.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="Grafana OnCall 中对应的警报组" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="Grafana OnCall 中对应的警报组" src="https://grafana.com/media/blog/grafana-oncall-servicenow/corresponding-alert-group.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;这些警报组通过标准 Grafana OnCall 机制（例如路线、升级链和待命时间表）智能路由，因此可以立即向正确的个人和团队发出警报。以下是 ServiceNow 中基于事件分配组的路由配置示例：&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/grafana-oncall-servicenow/add-route.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="添加路线菜单" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="添加路线菜单" src="https://grafana.com/media/blog/grafana-oncall-servicenow/add-route.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;如图所示，分配给 ServiceNow 中“客户支持”组的事件会触发相应的升级链。同样，标记为“基础设施”和“软件”的事件将被路由到各自的升级链。&lt;/p&gt;&lt;p&gt;此集成可以根据您的需求进行定制，因此您可以根据各种事件属性（例如服务、类别、优先级和其他字段）路由警报。&lt;/p&gt;&lt;h2 id="sync-incident-status"&gt;同步事件状态&lt;/h2&gt;&lt;p&gt;ServiceNow 很灵活，这种集成也很灵活。例如，您可以拥有 ServiceNow 实例特有的自定义事件状态。如果使用得当，这可能非常强大，但如果您的待命服务无法匹配相同的功能，它也可能受到限制。这就是为什么我们确保您可以通过此集成将 ServiceNow 中的任何状态映射回 Grafana OnCall：&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/grafana-oncall-servicenow/status-mapping.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="状态映射" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="状态映射" src="https://grafana.com/media/blog/grafana-oncall-servicenow/status-mapping.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;在 Grafana OnCall 中配置此同步非常简单，确保您的团队始终掌握有关事件状态的最新信息。&lt;/p&gt;&lt;h2 id="create-incidents-in-servicenow"&gt;在 ServiceNow 中创建事件&lt;/h2&gt;&lt;p&gt;想象一下，您已经在可观测性框架中使用了 Alertmanager、 &lt;a href="https://grafana.com/products/cloud/alerting/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana Alerting&lt;/a&gt; 、Amazon SNS、自定义 Webhooks 等工具或&lt;a href="https://grafana.com/docs/oncall/latest/integrations/?pg=blog&amp;amp;plcmt=body-txt#list-of-available-integrations"&gt;Grafana OnCall 支持的任何其他集成&lt;/a&gt;。通过这种新的集成，您可以根据此类工具的警报在 ServiceNow 中创建事件，利用整个监控生态系统的统一配置。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/grafana-oncall-servicenow/connect-integration.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="内容整合列表" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="内容整合列表" src="https://grafana.com/media/blog/grafana-oncall-servicenow/connect-integration.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;此功能可确保您的事件管理集中且一致，无论警报来源如何。&lt;/p&gt;&lt;h2 id="customize-the-integration"&gt;定制集成&lt;/h2&gt;&lt;p&gt;默认情况下，常见的 Grafana OnCall 事件也将反映在 ServiceNow 中。这包括警报组何时创建、确认或解决等。但我们知道每个团队都是不同的，这就是为什么我们确保您可以调整此集成以适应您的工作方式。&lt;/p&gt;&lt;p&gt;想要向事件添加更多信息或根据发生的情况调整警报的处理方式？您可以通过编辑其传出 Webhooks 轻松修改集成的行为。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/grafana-oncall-servicenow/outgoing-webhooks.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="传出 Webhook 菜单" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="传出 Webhook 菜单" src="https://grafana.com/media/blog/grafana-oncall-servicenow/outgoing-webhooks.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;通过利用 Grafana OnCall 的&lt;a href="https://grafana.com/docs/oncall/latest/configure/outgoing-webhooks/?pg=blog&amp;amp;plcmt=body-txt"&gt;传出 webhooks&lt;/a&gt; ，您可以获得大量空间来使用强大的模板引擎进行自定义。例如，假设当 Grafana OnCall 警报组静音时，您不想在 ServiceNow 中执行任何操作，因为这不是正常事件响应的一部分。只需删除“Silented”webhook 即可。&lt;/p&gt;&lt;h2 id="learn-more-about-grafana-oncall"&gt;了解有关 Grafana OnCall 的更多信息&lt;/h2&gt;&lt;p&gt;请参阅&lt;a href="https://grafana.com/docs/oncall/latest/integrations/servicenow/?pg=blog&amp;amp;plcmt=body-txt"&gt;我们的文档&lt;/a&gt;了解更多详细信息，并开始将 ServiceNow 集成到您的 Grafana OnCall 设置中。查看最近的一些 Grafana OnCall 博客文章，了解我们为支持&lt;a href="https://grafana.com/blog/2023/09/18/a-better-grafana-oncall-delivering-on-features-for-users-at-scale/"&gt;大规模运营的组织&lt;/a&gt;、与 Grafana Cloud 的其他部分&lt;a href="https://grafana.com/blog/2024/03/29/a-better-grafana-oncall-seamless-workflows-with-the-rest-of-grafana-cloud/"&gt;更紧密地集成&lt;/a&gt;以及解决我们一些&lt;a href="https://grafana.com/blog/2023/08/31/a-better-grafana-oncall-web-based-scheduling-mobile-app-email-support/"&gt;最大的功能请求而&lt;/a&gt;做出的最新改进。&lt;/p&gt;&lt;p&gt; &lt;em&gt;&lt;a href="https://grafana.com/products/cloud/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana Cloud&lt;/a&gt;是开始使用指标、日志、跟踪、仪表板等的最简单方法。我们为每个用例提供慷慨的永久免费套餐和计划。&lt;a href="https://grafana.com/auth/sign-up/create-user/?pg=blog&amp;amp;plcmt=body-txt"&gt;现在免费注册&lt;/a&gt;！&lt;/em&gt;&lt;/p&gt;</description><pubDate>Tue, 28 May 2024 00:00:00 GMT</pubDate><guid isPermaLink="true">https://grafana.com/blog/2024/05/28/grafana-oncall-use-the-new-bi-directional-servicenow-integration-for-seamless-alert-flows/</guid></item><item><title>【How to monitor steel alloys with Grafana: the story of a Golden Grot Awards winner】如何使用 Grafana 监控钢合金：金格罗特奖获奖者的故事</title><link>https://grafana.com/blog/2024/05/24/how-to-monitor-steel-alloys-with-grafana-the-story-of-a-golden-grot-awards-winner/</link><description>&lt;p&gt;每个出色的 Grafana 仪表板似乎都有这样的“顿悟”时刻——当用户从抽象地思考数据转变为将其视为有形且可立即采取行动的东西时。对于&lt;a href="https://www.theiascientific.com/" rel="noopener noreferrer" target="_blank"&gt;Theia Scientific&lt;/a&gt;联合创始人兼总裁 Christopher Field 来说，每次他向习惯于漫长的数据分析过程的科学研究人员展示仪表板时，都会发生这样的时刻。&lt;/p&gt;&lt;p&gt; “仪表板的一个伟大之处在于，我们展示了它以及我们构建的软件和我们开发的平台，它让科学家们看到了灯泡的亮起，”克里斯托弗说。 “当他们看到它的实际效果时，你就可以直接看到它。”&lt;/p&gt;&lt;p&gt;我们的眼睛也亮了起来，这就是为什么 Christopher 成为今年&lt;a href="https://grafana.com/about/events/grafanacon/2024/golden-grot-awards/"&gt;Golden Grot 奖&lt;/a&gt;的获得者之一，我们的年度奖项旨在表彰个人和专业仪表板中的最佳人选。他在专业仪表板类别中的胜利证明了 Grafana 仪表板的所有非传统用例，因为他的公司使用它来监测由于下一代核裂变反应堆和核聚变暴露于辐射而引起的钢合金缺陷的增长活力。&lt;/p&gt;&lt;div class="shortcode youtube"&gt;&lt;/div&gt;&lt;p&gt; “它验证了我们对这种定制和可视化以及使用带有显微镜的网络堆栈的原始概念，”他说。 “Grafana 正在通过可观察性来完成所有这一切，并在 IT 方面通过 DevOps 进行并监控您的 Web 应用程序，我们有点说，‘让我们为了科学的可观察性而这样做。这适用吗？它真的可以翻译并且有效吗？这证实了，是的，确实如此。”&lt;/p&gt;&lt;h2 id="accelerated-discovery-with-award-winning-grafana-dashboards"&gt;使用屡获殊荣的 Grafana 仪表板加速发现&lt;/h2&gt;&lt;p&gt;克里斯托弗 (Christopher) 与他的核科学家兄弟凯文 (Kevin) 共同创立了这家位于弗吉尼亚州阿灵顿的公司。他们的软件帮助研究人员将图像从房间大小的电子显微镜传输到时间序列数据库和机器学习模型，用于立即识别缺陷。该仪表板在内部共享，其他变体则由美国能源部 (DOE) 国家实验室和研究型大学使用。&lt;/p&gt;&lt;p&gt;借助 Grafana 展示的技术，科学家、工程师和研究人员可以节省高达 80% 的时间来确定合金的适用性。&lt;/p&gt;&lt;p&gt; “凯文花了十年的时间在黑点周围手工绘制方框，绘制了数千甚至数十万张图像，”克里斯托弗说。 “他再也不想这样做了，因此我们着手从根本上改变科学家和工程师研究这些材料和图像的工作流程。”&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/golden-grot/2024/dashboards/screenshot-goldengrot-christopher-field.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="克里斯托弗·菲尔德 (Christopher Field) 的获胜仪表板" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="克里斯托弗·菲尔德 (Christopher Field) 的获胜仪表板" src="https://grafana.com/media/golden-grot/2024/dashboards/screenshot-goldengrot-christopher-field.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;&lt;br /&gt;他们与一些组织合作，在几个小时内向合金发射集中辐射，以模拟该材料在整个世纪内的承受力。克里斯托弗说，几十年来，分析过程基本上没有变化，研究人员每分钟左右拍摄一次快照，然后再回去评估这些图像。&lt;/p&gt;&lt;p&gt; “我们现在可以通过仪表板做的是，他们可以进行分析，并在其仍在运行时确定它是否是一个好的材料，”克里斯托弗说。 “以前，他们可能需要一年半到两年的时间才能做出这一发现。当显微镜学家看到它或我们演示它时，这确实是“顿悟时刻”的部分，他们就像，“哦，我现在可以做到这一点吗？”我不用等吗？”&lt;/p&gt;&lt;p&gt;虽然 Grafana 的用例可能不典型，但它强调了可视化的价值以及可视化如何帮助团队专注于对他们的工作真正重要的事情。&lt;/p&gt;&lt;p&gt; “[画盒子]，这不是科学，这不是没有得到你的答案，”克里斯托弗说。 “因此，让我们将其自动化并解决它，并更快地到达发现点。让我们更快地找到答案。如果我们能在收购时做到这一点，那就更好了，对吧？”&lt;/p&gt;&lt;h2 id="what-makes-a-great-dashboard"&gt;是什么造就了一个出色的仪表板？&lt;/h2&gt;&lt;p&gt;仪表板的功能性和灵活性也给评委们留下了深刻的印象。&lt;/p&gt;&lt;p&gt; “它不仅非常有用，因为它显着加快了发现和审查核反应堆所用钢合金缺陷变化的过程，而且还更进一步。它使用专为这种情况设计的定制交互式面板，这为科学家和工程师提供了对图像集进行深入分析的机会，”一位评委说道。“它展示了交互式仪表板如何培养好奇心和趣味性，有助于改进系统。”&lt;/p&gt;&lt;p&gt;至于 Christopher 会给其他开始创建第一个 Grafana 仪表板的人提供什么建议，他建议向社区寻求支持，从小事做起，不要害怕第一次出错。&lt;/p&gt;&lt;p&gt; “失败没关系，只要继续尝试，”他说。 “如果它没有按照您想要的方式工作，请不要害怕，也不要认为您将拥有一个仪表板来统治所有这些；尝试一些不同的方法，看看会发生什么。”&lt;/p&gt;</description><pubDate>Fri, 24 May 2024 09:25:00 GMT</pubDate><guid isPermaLink="true">https://grafana.com/blog/2024/05/24/how-to-monitor-steel-alloys-with-grafana-the-story-of-a-golden-grot-awards-winner/</guid></item><item><title>【Serverless observability: How to monitor Google Cloud Run with OpenTelemetry and Grafana Cloud】无服务器可观测性：如何使用 OpenTelemetry 和 Grafana Cloud 监控 Google Cloud Run</title><link>https://grafana.com/blog/2024/05/23/serverless-observability-how-to-monitor-google-cloud-run-with-opentelemetry-and-grafana-cloud/</link><description>&lt;p&gt;OpenTelemetry 已成为收集遥测数据（包括跟踪、指标和日志）的首选开源解决方案。该项目的特别独特之处在于它专注于摆脱对专有代码的依赖，为用户提供更好的控制和灵活性。&lt;/p&gt;&lt;p&gt;作为 Grafana Labs 的高级解决方案工程师，我花了很多时间探索 OpenTelemetry，包括业余时间。作为我之前关于使用 OpenTelemetry 获取 AWS Lambda 跟踪&lt;a href="https://grafana.com/blog/2023/10/11/send-lambda-traces-to-grafana-cloud-with-opentelemetry/"&gt;的博客文章&lt;/a&gt;的后续内容，我对将 OTel 应用到其他无服务器解决方案感到好奇。&lt;/p&gt;&lt;p&gt;无服务器平台具有许多优势。它们允许您只需为您使用的资源付费，并且它们会根据工作负载需求自动扩展。此外，无服务器模型无需管理任何底层基础设施，这意味着开发人员有更多时间专注于应用程序开发和部署。&lt;/p&gt;&lt;p&gt;然而，由于其瞬态性，无服务器解决方案有时在可观察性方面可能是一个挑战。无服务器作业被设计为短暂的，这意味着必须立即导出这些实例中生成的遥测数据。这就是 OpenTelemetry 的用武之地，它提供了一种基于推送的方法，使用&lt;a href="https://opentelemetry.io/docs/specs/otel/protocol/" rel="noopener noreferrer" target="_blank"&gt;OpenTelemetry 协议 (OTLP)&lt;/a&gt;摄取遥测数据。&lt;/p&gt;&lt;p&gt;在这篇文章中，我将演示如何使用 OpenTelementry 收集&lt;a href="https://cloud.google.com/run/docs" rel="noopener noreferrer" target="_blank"&gt;Google Cloud Run&lt;/a&gt;的遥测数据，Google Cloud Run 是 Google Cloud Platform (GCP) 中的无服务器解决方案。我们将探索如何将 OpenTelemetry 的自动检测与 Node.js 应用程序结合使用，以高效地从 Cloud Run 服务导出遥测数据，并使用&lt;a href="https://grafana.com/docs/grafana-cloud/monitor-applications/application-observability//?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana Cloud 中的应用程序可观察性&lt;/a&gt;对其进行分析。&lt;/p&gt;&lt;p&gt;&lt;em&gt;注意：您可以在&lt;a href="https://github.com/kadjoudi/otel-cloud-run-grafana-o11y/" rel="noopener noreferrer" target="_blank"&gt;GitHub&lt;/a&gt;上找到本博客中使用的完整源代码。&lt;/em&gt;&lt;/p&gt;&lt;h2 id="first-some-background"&gt;首先，一些背景&lt;/h2&gt;&lt;p&gt;Google Cloud Run 是一个完全托管的容器运行时，可以自动扩展容器中的代码，从零到处理传入请求所需的多个实例。&lt;/p&gt;&lt;p&gt;谷歌最近更新了其 Cloud Run 架构，引入了&lt;a href="https://cloud.google.com/blog/products/serverless/cloud-run-now-supports-multi-container-deployments" rel="noopener noreferrer" target="_blank"&gt;多容器或 sidecar 的概念。&lt;/a&gt;此前，一项 Cloud Run 服务只能运行一个容器。现在，边车容器可以与主（入口）容器一起启动。 &lt;a href="https://cloud.google.com/blog/products/serverless/cloud-run-now-supports-multi-container-deployments" rel="noopener noreferrer" target="_blank"&gt;据谷歌称&lt;/a&gt;，这一变化旨在解决各种用例，包括：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;运行应用程序监视、日志记录和跟踪（实际上，总体上启用可观察性）&lt;/li&gt;&lt;li&gt;使用 Nginx、Envoy 或 Apache2 作为应用程序容器前面的代理&lt;/li&gt;&lt;li&gt;添加身份验证和授权过滤器&lt;/li&gt;&lt;li&gt;运行出站连接代理&lt;/li&gt;&lt;/ul&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt;&lt;a class="lightbox-link captioned" href="https://grafana.com/media/blog/google-cloud-run-otel-app-olly/google_cloud_run_app_olly_sidecar_architecture_resized2.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="A diagram showing the Google Cloud Run sidecar architecture." class="lazyload mb-0" title="*图片来源：&amp;lt;https://cloud.google.com/blog/products/serverless/cloud-run-now-supports-multi-container-deployments&amp;gt;*" /&gt; &lt;noscript&gt;&lt;img alt="A diagram showing the Google Cloud Run sidecar architecture." src="https://grafana.com/media/blog/google-cloud-run-otel-app-olly/google_cloud_run_app_olly_sidecar_architecture_resized2.png" title="*图片来源：&amp;lt;https://cloud.google.com/blog/products/serverless/cloud-run-now-supports-multi-container-deployments&amp;gt;*" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;figcaption class="w-100p caption text-gray-13 "&gt;&lt;em&gt;图片来源： &lt;a href="https://cloud.google.com/blog/products/serverless/cloud-run-now-supports-multi-container-deployments" rel="noopener noreferrer" target="_blank"&gt;https://cloud.google.com/blog/products/serverless/cloud-run-now-supports-multi-container-deployments&lt;/a&gt;&lt;/em&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;通过 sidecar 容器，我们可以部署&lt;a href="https://opentelemetry.io/docs/collector/" rel="noopener noreferrer" target="_blank"&gt;OTel Collector&lt;/a&gt;并捕获 Cloud Run 服务生成的遥测数据。&lt;/p&gt;&lt;p&gt;能够收集遥测数据只是难题的一小部分；我们还需要一个可以存储数据并从中获取见解的后端。这就是&lt;a href="https://grafana.com/docs/grafana-cloud/monitor-applications/application-observability/"&gt;Grafana 云应用程序可观察性&lt;/a&gt;发挥作用的地方。&lt;/p&gt;&lt;p&gt;应用程序可观察性是一种开箱即用的可观察性解决方案，旨在使用 OpenTelemetry 语义约定和 Prometheus 数据模型最大限度地减少现代应用程序（如无服务器）的平均修复时间 (MTTR)。&lt;/p&gt;&lt;p&gt;应用程序可观察性帮助用户：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;数据收集&lt;/strong&gt;：依靠开放标准和 OpenTelemetry 的无锁定仪器来收集指标、跟踪和日志。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;可视化&lt;/strong&gt;：利用预构建的仪表板和工作流程，包括服务清单、服务概述和服务地图，更轻松地探索指标、日志和跟踪。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;异常检测&lt;/strong&gt;：使用预先配置的仪表板来检测服务和应用程序中的异常情况。&lt;/li&gt;&lt;/ul&gt;&lt;h2 id="prepare-the-nodejs-application"&gt;准备 Node.js 应用程序&lt;/h2&gt;&lt;p&gt;自动检测的优点在于它能够检测任何应用程序（检查语言的&lt;a href="https://opentelemetry.io/docs/concepts/instrumentation/zero-code/" rel="noopener noreferrer" target="_blank"&gt;自动检测支持&lt;/a&gt;）并从各种库和框架捕获遥测数据，而无需更改任何代码。&lt;/p&gt;&lt;p&gt;我们在本博客中使用的 Node.js 应用程序基于&lt;a href="https://opentelemetry.io/docs/languages/js/getting-started/nodejs/" rel="noopener noreferrer" target="_blank"&gt;OpenTelemetry Node.js 入门示例，&lt;/a&gt;并进行了一些修改。它由两个服务组成：服务 A 和服务 B。服务 A 将请求定向到在端口 8080 上运行的服务 B。服务 B 使用一条简单的消息响应端口 5050 上的请求： &lt;em&gt;“GRAFANA APPLICATION O11Y IS AWESOME !!!!”&lt;/em&gt; 。此配置旨在展示两个服务之间的通信以及 OTel 如何捕获此交互。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/google-cloud-run-otel-app-olly/google_cloud_run_app_olly_meta.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="显示 OTel、GCP 和 Grafana Cloud 配置的图表。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="显示 OTel、GCP 和 Grafana Cloud 配置的图表。" src="https://grafana.com/media/blog/google-cloud-run-otel-app-olly/google_cloud_run_app_olly_meta.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;h2 id="set-up-the-cloud-run-service"&gt;设置 Cloud Run 服务&lt;/h2&gt;&lt;p&gt;有大量资源详细介绍了设置 Cloud Run 所需的先决条件和步骤。出于本博客的目的，我假设您已经完成了这些操作，但如果没有，您可以按照本&lt;a href="https://cloud.google.com/run/docs/tutorials/custom-metrics-opentelemetry-sidecar" rel="noopener noreferrer" target="_blank"&gt;教程&lt;/a&gt;中概述的步骤进行操作。&lt;/p&gt;&lt;p&gt;由于 Cloud Run 在容器上运行，我们需要创建一个&lt;a href="https://cloud.google.com/artifact-registry/docs/docker/store-docker-container-images" rel="noopener noreferrer" target="_blank"&gt;ArtifactRegistryDocker&lt;/a&gt;存储库来托管我们的应用程序服务映像。&lt;/p&gt;&lt;p&gt;让我们在&lt;code&gt;europe-west9&lt;/code&gt;区域的&lt;code&gt;blog-otel-grafana-o11y&lt;/code&gt;项目中创建&lt;code&gt;otel-grafana-o11y&lt;/code&gt;存储库（不过，您可以选择您选择的区域）。首先，确保启用 ArtifactRegistry API。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/google-cloud-run-otel-app-olly/google_cloud_run_app_olly_artifact_registry_resized2.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="工件注册表的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="工件注册表的屏幕截图。" src="https://grafana.com/media/blog/google-cloud-run-otel-app-olly/google_cloud_run_app_olly_artifact_registry_resized2.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;然后，从控制台运行以下命令。&lt;/p&gt;&lt;div class="code-snippet code-snippet__mini"&gt;&lt;div class="lang-toolbar__mini"&gt; &lt;span class="code-clipboard"&gt;&lt;button&gt;&lt;img alt="将代码复制到剪贴板" class="code-clipboard__icon" height="13" src="https://grafana.com/media/images/icons/icon-copy-small-2.svg" width="14" /&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="code-snippet code-snippet__border"&gt;&lt;pre&gt;&lt;code class="language-none"&gt;gcloud config set project blog-grafana-o11y-otel gcloud config set run/region europe-west9 gcloud artifacts repositories create grafana-o11y-otel \ --repository-format=docker \ --location=europe-west9 \ --project=blog-grafana-o11y-otel&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;以下是 GCP 控制台的输出。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/google-cloud-run-otel-app-olly/google_cloud_run_app_olly_GCPoutput_resized2.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="GCP 输出的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="GCP 输出的屏幕截图。" src="https://grafana.com/media/blog/google-cloud-run-otel-app-olly/google_cloud_run_app_olly_GCPoutput_resized2.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;h2 id="configure-auto-instrumentation-for-our-nodejs-services"&gt;为我们的 Node.js 服务配置自动检测&lt;/h2&gt;&lt;p&gt;现在 Cloud Run 服务已配置完毕，是时候关注我们的 Node.js 应用程序了。让我们检查一下两个服务的代码。&lt;/p&gt;&lt;p&gt; &lt;strong&gt;1. 服务A&lt;/strong&gt;&lt;/p&gt;&lt;div class="code-snippet "&gt;&lt;div class="lang-toolbar"&gt; &lt;span class="lang-toolbar__item"&gt;JavaScript&lt;/span&gt; &lt;span class="code-clipboard"&gt;&lt;button&gt;&lt;img alt="将代码复制到剪贴板" class="code-clipboard__icon" height="13" src="https://grafana.com/media/images/icons/icon-copy-small-2.svg" width="14" /&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;div class="lang-toolbar__border"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="code-snippet "&gt;&lt;pre&gt; &lt;code class="language-javascript"&gt;const express = require(&amp;#39;express&amp;#39;); // Import the Express framework const app = express(); // Create an Express application instance const axios = require(&amp;quot;axios&amp;quot;); // Import the axios library for making HTTP requests // Define a route for handling GET requests to the root URL (&amp;#39;/&amp;#39;) app.get(&amp;#39;/&amp;#39;, async (req, res) =&amp;gt; { // Send a GET request to Service B let response = await axios.get(&amp;quot;http://localhost:5050&amp;quot;); // Send a response to the client, combining the response data from Service B with a custom message res.send(&amp;quot;Service B says: &amp;quot; + response.data); }); // Define the port to listen on, using the value of the PORT environment variable if it&amp;#39;s set, otherwise default to port 8080 const port = parseInt(process.env.PORT) || 8080; // Start the Express server and make it listen on the specified port app.listen(port, () =&amp;gt; { console.log(`Service A listening on port ${port}`); // Log a message to indicate that the server is running });&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt; &lt;strong&gt;2. 服务B&lt;/strong&gt;&lt;/p&gt;&lt;div class="code-snippet "&gt;&lt;div class="lang-toolbar"&gt; &lt;span class="lang-toolbar__item"&gt;JavaScript&lt;/span&gt; &lt;span class="code-clipboard"&gt;&lt;button&gt;&lt;img alt="将代码复制到剪贴板" class="code-clipboard__icon" height="13" src="https://grafana.com/media/images/icons/icon-copy-small-2.svg" width="14" /&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;div class="lang-toolbar__border"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="code-snippet "&gt;&lt;pre&gt; &lt;code class="language-javascript"&gt;const express = require(&amp;#39;express&amp;#39;); // Import the Express framework const app = express(); // Create an Express application instance // Define a route for handling GET requests to the root URL (&amp;#39;/&amp;#39;) app.get(&amp;#39;/&amp;#39;, async (req, res) =&amp;gt; { res.send(&amp;quot;GRAFANA APPLICATION O11 IS AWESOME !!!!&amp;quot;); // Send a response with the message &amp;quot;GRAFANA APPLICATION O11 IS AWESOME&amp;quot; }); // Define the port to listen on, using the value of the PORT environment variable if it&amp;#39;s set, otherwise default to port 5050 const port = parseInt(process.env.PORT || 5050); // Start the Express server and make it listen on the specified port app.listen(port, () =&amp;gt; { console.log(`Service B listening on port ${port}`); // Log a message to indicate that the server is running });&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;现在，让我们根据&lt;a href="https://opentelemetry.io/docs/languages/js/automatic/" rel="noopener noreferrer" target="_blank"&gt;OpenTelemetry JavaScript 文档&lt;/a&gt;和使用 npm &lt;a href="https://www.npmjs.com/package/@opentelemetry/auto-instrumentations-node" rel="noopener noreferrer" target="_blank"&gt;的 @open-telemetry/auto-instrumentions-node 文档，&lt;/a&gt;使用 Node.js 配置自动检测。&lt;/p&gt;&lt;div class="code-snippet code-snippet__mini"&gt;&lt;div class="lang-toolbar__mini"&gt; &lt;span class="code-clipboard"&gt;&lt;button&gt;&lt;img alt="将代码复制到剪贴板" class="code-clipboard__icon" height="13" src="https://grafana.com/media/images/icons/icon-copy-small-2.svg" width="14" /&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="code-snippet code-snippet__border"&gt;&lt;pre&gt;&lt;code class="language-none"&gt;npm install --save @opentelemetry/api npm install --save @opentelemetry/auto-instrumentations-node&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;要使用自动检测来运行 Node.js 应用程序，请运行以下命令。&lt;/p&gt;&lt;div class="code-snippet code-snippet__mini"&gt;&lt;div class="lang-toolbar__mini"&gt; &lt;span class="code-clipboard"&gt;&lt;button&gt;&lt;img alt="将代码复制到剪贴板" class="code-clipboard__icon" height="13" src="https://grafana.com/media/images/icons/icon-copy-small-2.svg" width="14" /&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="code-snippet code-snippet__border"&gt;&lt;pre&gt;&lt;code class="language-none"&gt;node --require @opentelemetry/auto-instrumentations-node/register serviceA.js&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;对于我们的两个服务，我们需要创建一个&lt;code&gt;package.json&lt;/code&gt;文件，其中包含要运行的所有必需的依赖项和命令。然后，该 JSON 包将在 Docker 映像构建过程中使用。&lt;/p&gt;&lt;p&gt;以下是服务 A 的&lt;code&gt;package.json&lt;/code&gt;文件示例，我们在其中指定了&lt;code&gt;express&lt;/code&gt;和&lt;code&gt;axios&lt;/code&gt;库，以及 OpenTelemetry 自动检测库。&lt;/p&gt;&lt;div class="code-snippet code-snippet__mini"&gt;&lt;div class="lang-toolbar__mini"&gt; &lt;span class="code-clipboard"&gt;&lt;button&gt;&lt;img alt="将代码复制到剪贴板" class="code-clipboard__icon" height="13" src="https://grafana.com/media/images/icons/icon-copy-small-2.svg" width="14" /&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="code-snippet code-snippet__border"&gt;&lt;pre&gt;&lt;code class="language-none"&gt;{ &amp;quot;name&amp;quot;: &amp;quot;ServiceA&amp;quot;, &amp;quot;version&amp;quot;: &amp;quot;1.0.0&amp;quot;, &amp;quot;description&amp;quot;: &amp;quot;serviceA running in Cloud Run&amp;quot;, &amp;quot;main&amp;quot;: &amp;quot;index.js&amp;quot;, &amp;quot;scripts&amp;quot;: { &amp;quot;start&amp;quot;: &amp;quot;node --require @opentelemetry/auto-instrumentations-node/register serviceA.js&amp;quot; }, &amp;quot;dependencies&amp;quot;: { &amp;quot;@opentelemetry/api&amp;quot;: &amp;quot;^1.8.0&amp;quot;, &amp;quot;@opentelemetry/auto-instrumentations-node&amp;quot;: &amp;quot;^0.43.0&amp;quot;, &amp;quot;axios&amp;quot;: &amp;quot;^1.6.2&amp;quot;, &amp;quot;express&amp;quot;: &amp;quot;^4.18.2&amp;quot; } }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;现在，让我们为服务 A 创建&lt;a href="https://docs.docker.com/reference/dockerfile/" rel="noopener noreferrer" target="_blank"&gt;Dockerfile&lt;/a&gt; 。&lt;/p&gt;&lt;div class="code-snippet code-snippet__mini"&gt;&lt;div class="lang-toolbar__mini"&gt; &lt;span class="code-clipboard"&gt;&lt;button&gt;&lt;img alt="将代码复制到剪贴板" class="code-clipboard__icon" height="13" src="https://grafana.com/media/images/icons/icon-copy-small-2.svg" width="14" /&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="code-snippet code-snippet__border"&gt;&lt;pre&gt;&lt;code class="language-none"&gt;FROM node:20.12.0-slim WORKDIR /usr/src/app COPY package*.json ./ RUN npm install # Copy local code to the container image. COPY . . # Run the web service on container startup. ENV PORT=8080 CMD [ &amp;quot;npm&amp;quot;, &amp;quot;start&amp;quot; ]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt; ...并将其推送到我们的 Artifact 注册表。&lt;/p&gt;&lt;div class="code-snippet code-snippet__mini"&gt;&lt;div class="lang-toolbar__mini"&gt; &lt;span class="code-clipboard"&gt;&lt;button&gt;&lt;img alt="将代码复制到剪贴板" class="code-clipboard__icon" height="13" src="https://grafana.com/media/images/icons/icon-copy-small-2.svg" width="14" /&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="code-snippet code-snippet__border"&gt;&lt;pre&gt;&lt;code class="language-none"&gt;gcloud builds submit --tag europe-west9-docker.pkg.dev/blog-grafana-o11y-otel/grafana-o11y-otel/servicea:latest&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;对服务 B 重复相同的过程。&lt;/p&gt;&lt;p&gt;从Cloud UI中可以看到我们的Service A和Service B容器已经成功推送。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/google-cloud-run-otel-app-olly/google_cloud_run_app_olly_containers_successfully_pushed.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="GCP UI 的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="GCP UI 的屏幕截图。" src="https://grafana.com/media/blog/google-cloud-run-otel-app-olly/google_cloud_run_app_olly_containers_successfully_pushed.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;h2 id="configure-the-opentelemetry-collector-to-connect-to-application-observability"&gt;配置 OpenTelemetry Collector 以连接到应用程序可观察性&lt;/h2&gt;&lt;p&gt;Grafana Cloud Application Observability 与 OpenTelemetry Collector 兼容，并且本身接受 OTLP。要将 OpenTelemetry Collector 设置为发送到 Grafana Cloud 的数据收集器：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;创建和/或登录 Grafana Cloud 帐户。如果您还没有 Grafana Cloud 帐户，您可以立即创建一个&lt;a href="https://grafana.com/auth/sign-up/create-user/?pg=blog&amp;amp;plcmt=body-txt"&gt;免费的 Grafana Cloud&lt;/a&gt;帐户。&lt;/li&gt;&lt;li&gt; &lt;a href="https://opentelemetry.io/docs/collector/installation/" rel="noopener noreferrer" target="_blank"&gt;安装 OpenTelemetry Collector&lt;/a&gt; 。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;em&gt;注意：OpenTelemetry Collector 有两个发行版：core 和 contrib。应用程序可观察性需要&lt;strong&gt;contrib 分发&lt;/strong&gt;。&lt;/em&gt;&lt;/p&gt;&lt;h3 id="1-create-the-otel-collector-configuration-file"&gt; 1.创建OTel Collector配置文件&lt;/h3&gt;&lt;p&gt;OpenTelemetry Collector 的运行需要&lt;strong&gt;config.yaml&lt;/strong&gt;配置文件。好消息是，Application Observability 包含一个引导配置菜单，可帮助您生成 OTel Collector 配置。要获取此配置，请从列表中选择&lt;strong&gt;添加服务 → OpenTelemetry Collector&lt;/strong&gt; 。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/google-cloud-run-otel-app-olly/google_cloud_run_app_olly_otel_collector_config.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="OTel Collector 配置详细信息的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="OTel Collector 配置详细信息的屏幕截图。" src="https://grafana.com/media/blog/google-cloud-run-otel-app-olly/google_cloud_run_app_olly_otel_collector_config.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt; OpenTelemetry Collector 集成将生成 OpenTelemetry Collector 配置以与 Grafana Cloud Application Observability 一起使用。&lt;/p&gt;&lt;p&gt;为了确保收集器与 Cloud Run 服务无缝协作，我们可以在扩展部分包含&lt;code&gt;health_check&lt;/code&gt;选项。 （有关更多详细信息，请参阅下面的“部署 Cloud Run 服务”部分。）&lt;/p&gt;&lt;div class="code-snippet code-snippet__mini"&gt;&lt;div class="lang-toolbar__mini"&gt; &lt;span class="code-clipboard"&gt;&lt;button&gt;&lt;img alt="将代码复制到剪贴板" class="code-clipboard__icon" height="13" src="https://grafana.com/media/images/icons/icon-copy-small-2.svg" width="14" /&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="code-snippet code-snippet__border"&gt;&lt;pre&gt;&lt;code class="language-none"&gt;extensions: health_check: ... service: extensions: [health_check,basicauth/grafana_cloud_tempo, basicauth/grafana_cloud_prometheus, basicauth/grafana_cloud_loki]&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;您可以在&lt;a href="https://github.com/kadjoudi/otel-cloud-run-grafana-o11y/tree/main/OTelCollector" rel="noopener noreferrer" target="_blank"&gt;GitHub&lt;/a&gt;存储库中找到完整的配置文件。您还可以参考&lt;a href="https://grafana.com/docs/grafana-cloud/monitor-applications/application-observability/setup/collector/opentelemetry-collector/#configuration"&gt;Grafana Cloud 文档&lt;/a&gt;以获取更多信息。&lt;/p&gt;&lt;h3 id="2-create-the-otel-collector-dockerfile"&gt; 2. 创建 OTel 收集器 Dockerfile&lt;/h3&gt;&lt;p&gt;以下是将之前的 OTel Collector 配置捆绑到 contrib 收集器映像中的 Dockerfile 配置：&lt;/p&gt;&lt;div class="code-snippet code-snippet__mini"&gt;&lt;div class="lang-toolbar__mini"&gt; &lt;span class="code-clipboard"&gt;&lt;button&gt;&lt;img alt="将代码复制到剪贴板" class="code-clipboard__icon" height="13" src="https://grafana.com/media/images/icons/icon-copy-small-2.svg" width="14" /&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="code-snippet code-snippet__border"&gt;&lt;pre&gt;&lt;code class="language-none"&gt;FROM otel/opentelemetry-collector-contrib:0.94.0 COPY collector-config.yaml /etc/otelcol-contrib/config.yaml&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;h3 id="3-push-the-otel-collector"&gt; 3. 推送OTel收集器&lt;/h3&gt;&lt;div class="code-snippet code-snippet__mini"&gt;&lt;div class="lang-toolbar__mini"&gt;&lt;span class="code-clipboard"&gt;&lt;button&gt;&lt;img alt="将代码复制到剪贴板" class="code-clipboard__icon" height="13" src="https://grafana.com/media/images/icons/icon-copy-small-2.svg" width="14" /&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="code-snippet code-snippet__border"&gt;&lt;pre&gt;&lt;code class="language-none"&gt;gcloud builds submit --tag europe-west9-docker.pkg.dev/blog-grafana-o11y-otel/grafana-o11y-otel/otelcollector:latest&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;h2 id="deploy-the-cloud-run-service"&gt;部署 Cloud Run 服务&lt;/h2&gt;&lt;p&gt;目前，我们将所有三个容器存储在我们的工件注册表中。现在，我们可以部署 Google Cloud Run 服务。我选择使用 YAML 方法使用&lt;a href="https://knative.dev/docs/" rel="noopener noreferrer" target="_blank"&gt;Knative&lt;/a&gt;配置我的 Cloud Run 服务。&lt;/p&gt;&lt;p&gt;在我们继续之前，有一件重要的事情需要提及：OTel Collector 使用基于推送的方法，因此当应用程序发送遥测数据时，它期望 OTel Collector 准备好接收和导出它。这意味着 OTel Collector 必须在应用程序启动之前启动，并且需要在应用程序关闭后停止。&lt;/p&gt;&lt;p&gt;幸运的是，Google 为 Cloud Run sidecar 添加了一个有用的功能： &lt;a href="https://cloud.google.com/run/docs/deploying#multicontainer-features" rel="noopener noreferrer" target="_blank"&gt;&lt;strong&gt;容器依赖&lt;/strong&gt;。&lt;/a&gt;这使我们能够控制容器启动和停止的顺序。我们可以确保 OTel Collector 在服务 A 和服务 B 之前启动，并在它们之后停止。这非常重要，这样我们就不会错过任何我们应该收集的数据。我们还需要使用&lt;a href="https://cloud.google.com/run/docs/configuring/healthchecks" rel="noopener noreferrer" target="_blank"&gt;启动运行状况检查探针&lt;/a&gt;来成功部署。&lt;/p&gt;&lt;p&gt;此外，正如&lt;a href="https://opentelemetry.io/docs/languages/js/automatic/" rel="noopener noreferrer" target="_blank"&gt;OTEL 文档&lt;/a&gt;中所指定的，我们将使用环境变量并在每个容器部分中传递配置值。&lt;em&gt;注意：目前环境变量配置仅&lt;a href="https://opentelemetry.io/docs/languages/js/automatic/" rel="noopener noreferrer" target="_blank"&gt;支持 Traces&lt;/a&gt; 。&lt;/em&gt;&lt;/p&gt;&lt;p&gt;例如，我们将使用以下环境变量。&lt;/p&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;环境变量&lt;/th&gt;&lt;th&gt;服务容器&lt;/th&gt;&lt;th&gt;服务B容器&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;OTEL_SERVICE_NAME&lt;/td&gt;&lt;td&gt;服务A&lt;/td&gt;&lt;td&gt;服务B&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; OTEL_LOG_LEVEL&lt;/td&gt;&lt;td&gt;信息&lt;/td&gt;&lt;td&gt;信息&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;OTEL_EXPORTER_OTLP_PROTOCOL&lt;/td&gt;&lt;td&gt; http/protobuf&lt;/td&gt;&lt;td&gt; http/protobuf&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;p&gt;让我们回顾一下&lt;code&gt;service.yaml&lt;/code&gt;文件，我们在其中设置容器启动顺序并指示运行状况检查探针。&lt;/p&gt;&lt;div class="code-snippet code-snippet__mini"&gt;&lt;div class="lang-toolbar__mini"&gt; &lt;span class="code-clipboard"&gt;&lt;button&gt;&lt;img alt="将代码复制到剪贴板" class="code-clipboard__icon" height="13" src="https://grafana.com/media/images/icons/icon-copy-small-2.svg" width="14" /&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="code-snippet code-snippet__border"&gt;&lt;pre&gt;&lt;code class="language-none"&gt;apiVersion: serving.knative.dev/v1 kind: Service metadata: annotations: run.googleapis.com/launch-stage: BETA name: grafana-o11y-otel labels: cloud.googleapis.com/location: &amp;quot;europe-west9&amp;quot; spec: template: metadata: annotations: #The following line aims to set a container start order run.googleapis.com/container-dependencies: &amp;#39;{&amp;quot;servicea&amp;quot;:[&amp;quot;otelcollector&amp;quot;], &amp;quot;serviceb&amp;quot;:[&amp;quot;otelcollector&amp;quot;]}&amp;#39; spec: containers: - image: &amp;quot;europe-west9-docker.pkg.dev/blog-grafana-o11y-otel/grafana-o11y-otel/servicea:latest&amp;quot; name: servicea env: - name: OTEL_SERVICE_NAME value: &amp;quot;ServiceA&amp;quot; - name: OTEL_PROPAGATORS value: &amp;quot;tracecontext&amp;quot; - name: OTEL_LOG_LEVEL value: &amp;quot;info&amp;quot; - name: OTEL_EXPORTER_OTLP_PROTOCOL value: &amp;quot;http/protobuf&amp;quot; ports: - containerPort: 8080 - image: &amp;quot;europe-west9-docker.pkg.dev/blog-grafana-o11y-otel/grafana-o11y-otel/serviceb:latest&amp;quot; name: serviceb env: - name: PORT value: &amp;quot;5050&amp;quot; - name: OTEL_SERVICE_NAME value: &amp;quot;ServiceB&amp;quot; - name: OTEL_PROPAGATORS value: &amp;quot;tracecontext&amp;quot; - name: OTEL_LOG_LEVEL value: &amp;quot;info&amp;quot; - name: OTEL_EXPORTER_OTLP_PROTOCOL value: &amp;quot;http/protobuf&amp;quot; #The following lines define the health-check probe configuration - image: &amp;quot;europe-west9-docker.pkg.dev/blog-grafana-o11y-otel/grafana-o11y-otel/otelcollector:latest&amp;quot; name: otelcollector startupProbe: httpGet: path: / port: 13133 resources: limits: cpu: 1000m memory: 512Mi&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;让我们部署 Cloud Run 服务。&lt;/p&gt;&lt;div class="code-snippet code-snippet__mini"&gt;&lt;div class="lang-toolbar__mini"&gt; &lt;span class="code-clipboard"&gt;&lt;button&gt;&lt;img alt="将代码复制到剪贴板" class="code-clipboard__icon" height="13" src="https://grafana.com/media/images/icons/icon-copy-small-2.svg" width="14" /&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="code-snippet code-snippet__border"&gt;&lt;pre&gt;&lt;code class="language-none"&gt; gcloud run services replace service.yaml&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;我们应该有以下输入，其中&lt;code&gt;URL&lt;/code&gt;是要调用的 URL。&lt;/p&gt;&lt;div class="code-snippet code-snippet__mini"&gt;&lt;div class="lang-toolbar__mini"&gt; &lt;span class="code-clipboard"&gt;&lt;button&gt;&lt;img alt="将代码复制到剪贴板" class="code-clipboard__icon" height="13" src="https://grafana.com/media/images/icons/icon-copy-small-2.svg" width="14" /&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="code-snippet code-snippet__border"&gt;&lt;pre&gt;&lt;code class="language-none"&gt;Applying new configuration to Cloud Run service [grafana-o11y-otel] in project [blog-grafana-o11y-otel] region [europe-west9] ✓ Deploying... Done. ✓ Creating Revision... ✓ Routing traffic... Done. New configuration has been applied to service [grafana-o11y-otel]. URL: https://grafana-o11y-otel-xscqzsykua-od.a.run.app&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;部署完成后，您可以通过运行以下命令来获取并保存服务 URL，其中&lt;code&gt;$SERVICE_NAME&lt;/code&gt;是 YAML 文件中服务的名称 ( &lt;code&gt;grafana-o11y-otel&lt;/code&gt; )， &lt;code&gt;$REGION&lt;/code&gt;是我们之前设置的区域 ( &lt;code&gt;europe-west9&lt;/code&gt; ）：&lt;/p&gt;&lt;div class="code-snippet code-snippet__mini"&gt;&lt;div class="lang-toolbar__mini"&gt; &lt;span class="code-clipboard"&gt;&lt;button&gt;&lt;img alt="将代码复制到剪贴板" class="code-clipboard__icon" height="13" src="https://grafana.com/media/images/icons/icon-copy-small-2.svg" width="14" /&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="code-snippet code-snippet__border"&gt;&lt;pre&gt;&lt;code class="language-none"&gt;gcloud run services describe $SERVICE_NAME --platform managed --region $REGION --format &amp;#39;value(status.url)&amp;#39;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;使用 Cloud Run 控制台，我们可以确认我们的 Cloud Run 服务以及所有三个容器已成功部署。此外，我们可以观察到环境变量已更新。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/google-cloud-run-otel-app-olly/google_cloud_run_app_olly_cloudconsole.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="GCP 控制台的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="GCP 控制台的屏幕截图。" src="https://grafana.com/media/blog/google-cloud-run-otel-app-olly/google_cloud_run_app_olly_cloudconsole.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;您现在可以发出一些请求来生成跟踪数据。让我们使用循环每五秒发出一个请求（完成后不要忘记停止脚本）：&lt;/p&gt;&lt;div class="code-snippet code-snippet__mini"&gt;&lt;div class="lang-toolbar__mini"&gt; &lt;span class="code-clipboard"&gt;&lt;button&gt;&lt;img alt="将代码复制到剪贴板" class="code-clipboard__icon" height="13" src="https://grafana.com/media/images/icons/icon-copy-small-2.svg" width="14" /&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="code-snippet code-snippet__border"&gt;&lt;pre&gt;&lt;code class="language-none"&gt;while true; do curl &amp;quot;https://grafana-o11y-otel-xscqzsykua-od.a.run.app&amp;quot;; sleep 5; done;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;h2 id="analyze-data-with-grafana-cloud-application-observability"&gt;使用 Grafana Cloud 应用程序可观察性分析数据&lt;/h2&gt;&lt;p&gt;现在一切都按预期运行，让我们在 Grafana Cloud 中打开应用程序可观察性：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;导航到堆栈：https://&amp;lt;your-stack-name.&amp;gt;grafana.net&lt;/li&gt;&lt;li&gt;展开 Grafana 徽标下方的左上方菜单&lt;/li&gt;&lt;li&gt;点击&lt;strong&gt;申请&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;应用程序可观察性依赖于被引入 Grafana Cloud 的跟踪生成的指标。这些指标用于在应用程序可观测性中显示速率错误持续时间 (RED) 方法信息。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/google-cloud-run-otel-app-olly/google_cloud_run_app_olly_get_started.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="Grafana Cloud UI 的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="Grafana Cloud UI 的屏幕截图。" src="https://grafana.com/media/blog/google-cloud-run-otel-app-olly/google_cloud_run_app_olly_get_started.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;要完成设置，请单击&lt;strong&gt;“启用应用程序可观察性”&lt;/strong&gt; 。&lt;/p&gt;&lt;p&gt;&lt;em&gt;注意：生成指标和显示图表可能最多需要五分钟。&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;服务清单&lt;/strong&gt;页面列出了向 Grafana Cloud 发送分布式跟踪的所有服务。您可以看到我们能够捕获服务 A 和服务 B。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/google-cloud-run-otel-app-olly/google_cloud_run_app_olly_services_inventory.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="服务清单页面的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="服务清单页面的屏幕截图。" src="https://grafana.com/media/blog/google-cloud-run-otel-app-olly/google_cloud_run_app_olly_services_inventory.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;我们还可以检查&lt;strong&gt;“服务地图”&lt;/strong&gt;页面，以获取高级别相关服务和运行状况指标的图表。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/google-cloud-run-otel-app-olly/google_cloud_run_app_olly_service_map_page.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="服务地图页面的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="服务地图页面的屏幕截图。" src="https://grafana.com/media/blog/google-cloud-run-otel-app-olly/google_cloud_run_app_olly_service_map_page.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;让我们导航到每项服务（服务 A 和服务 B）的&lt;strong&gt;服务概述&lt;/strong&gt;页面。此页面提供了健康状况概述以及 RED 指标：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;服务本身&lt;/li&gt;&lt;li&gt;相关上下游服务&lt;/li&gt;&lt;li&gt;对服务执行的操作&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;以下是服务 A 的服务概述页面：&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/google-cloud-run-otel-app-olly/google_cloud_run_app_olly_service_overview_serviceA.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="服务 A 的服务概述页面的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="服务 A 的服务概述页面的屏幕截图。" src="https://grafana.com/media/blog/google-cloud-run-otel-app-olly/google_cloud_run_app_olly_service_overview_serviceA.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;这是服务 B 的同一页面：&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/google-cloud-run-otel-app-olly/google_cloud_run_app_olly_service_overview_serviceB.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="服务 B 的服务概述页面的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="服务 B 的服务概述页面的屏幕截图。" src="https://grafana.com/media/blog/google-cloud-run-otel-app-olly/google_cloud_run_app_olly_service_overview_serviceB.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;&lt;strong&gt;跟踪&lt;/strong&gt;视图提供与我们的服务相关的所有跟踪的视图。默认情况下，应用程序可观察性按服务和服务命名空间过滤跟踪。有两种自定义搜索查询的方法：&lt;/p&gt;&lt;ul&gt;&lt;li&gt; TraceQL 使用 Trace 查询语言&lt;/li&gt;&lt;li&gt;单击&lt;strong&gt;“搜索”&lt;/strong&gt;以使用可视化 TraceQL 查询生成器&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这是服务 A 的跟踪视图：&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/google-cloud-run-otel-app-olly/google_cloud_run_app_olly_traces_view_serviceA.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="服务 A 的跟踪视图的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="服务 A 的跟踪视图的屏幕截图。" src="https://grafana.com/media/blog/google-cloud-run-otel-app-olly/google_cloud_run_app_olly_traces_view_serviceA.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;这是服务 B 的 Traces 视图：&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/google-cloud-run-otel-app-olly/google_cloud_run_app_olly_traces_view_serviceB.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="服务 B 的跟踪视图的屏幕截图。" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="服务 B 的跟踪视图的屏幕截图。" src="https://grafana.com/media/blog/google-cloud-run-otel-app-olly/google_cloud_run_app_olly_traces_view_serviceB.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;h2 id="let-us-know-what-you-think"&gt;让我们知道您的想法！&lt;/h2&gt;&lt;p&gt;总之，OpenTelemetry 使自动检测 Node.js 应用程序变得非常简单。这涉及安装必要的 Node.js 包以进行自动检测，并设置 OTel Collector 以收集遥测数据并将其发送到 Grafana Cloud。&lt;/p&gt;&lt;p&gt;通过结合 OpenTelemetry 的数据收集功能和 Grafana Cloud 应用程序可观测性的可视化和分析功能，组织可以实现全面的可观测性。这使团队能够主动识别和解决问题，并优化其性能和可靠性——即使在可见性可能成为挑战的无服务器环境中也是如此。&lt;/p&gt;&lt;p&gt;我们致力于持续改进，您的反馈在此过程中非常宝贵。如果您使用 OTel 和 Grafana Cloud 进行无服务器观测，请与我们分享您的想法和经验。您可以在 #opentelemetry 频道的&lt;a href="https://slack.grafana.com/" rel="noopener noreferrer" target="_blank"&gt;Grafana Labs 社区 Slack&lt;/a&gt;中找到我们的团队。&lt;/p&gt;&lt;p&gt; &lt;em&gt;&lt;a href="https://grafana.com/products/cloud/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana Cloud&lt;/a&gt;是开始使用指标、日志、跟踪和仪表板的最简单方法。我们最近在慷慨的永久免费套餐中添加了新功能，包括允许三个用户访问所有企业插件。另外，每个用例都有相应的计划。 &lt;a href="https://grafana.com/auth/sign-up/create-user?pg=blog-application-observability-ga&amp;amp;plcmt=in-txt"&gt;立即注册免费帐户！&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;</description><pubDate>Thu, 23 May 2024 12:47:00 GMT</pubDate><guid isPermaLink="true">https://grafana.com/blog/2024/05/23/serverless-observability-how-to-monitor-google-cloud-run-with-opentelemetry-and-grafana-cloud/</guid></item><item><title>【How to visualize Amazon CloudWatch metrics in Grafana】如何在 Grafana 中可视化 Amazon CloudWatch 指标</title><link>https://grafana.com/blog/2024/05/22/how-to-visualize-amazon-cloudwatch-metrics-in-grafana/</link><description>&lt;p&gt;在广阔的可观察性领域中，您有多种选择来可视化 Amazon CloudWatch 收集的指标。正因为如此，您经常需要做出很多决定——关于成本、配置、灵活性等等。在 Grafana Labs，我们坚持“大帐篷”理念，这意味着我们不会强迫您做出决定，甚至不会告诉您必须将 CloudWatch 指标引入 Grafana Cloud。&lt;/p&gt;&lt;p&gt;这种灵活性很棒，但它常常让我们的用户想知道哪个选项适合他们。因此，我们撰写这篇博文来帮助您了解在 Grafana 中可视化 AWS 指标的四个主要选项：&lt;/p&gt;&lt;ol&gt;&lt;li&gt; Grafana Labs &lt;a href="https://grafana.com/docs/grafana/latest/datasources/aws-cloudwatch/?pg=blog&amp;amp;plcmt=body-txt"&gt;Amazon CloudWatch 数据源&lt;/a&gt;&lt;/li&gt;&lt;li&gt;使用&lt;a href="https://grafana.com/solutions/cloud-monitoring-aws/?pg=blog&amp;amp;plcmt=body-txt"&gt;AWS Observability 应用程序&lt;/a&gt;的&lt;a href="https://grafana.com/docs/grafana-cloud/monitor-infrastructure/aws/cloudwatch-metrics/?pg=blog&amp;amp;plcmt=body-txt"&gt;AWS Observability CloudWatch 指标&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://grafana.com/docs/alloy/latest/reference/components/prometheus.exporter.cloudwatch/?pg=blog&amp;amp;plcmt=body-txt"&gt;使用 CloudWatch 导出器运行 Grafana Alloy&lt;/a&gt;&lt;/li&gt;&lt;li&gt;运行&lt;a href="https://github.com/nerdswords/yet-another-cloudwatch-exporter" rel="noopener noreferrer" target="_blank"&gt;Yet-another-cloudwatch-exporter&lt;/a&gt; (YACE)，这是一个用于 CloudWatch 的开源 Prometheus 导出器&lt;/li&gt;&lt;/ol&gt;&lt;h2 id="visualizing-the-different-deployment-models"&gt;可视化不同的部署模型&lt;/h2&gt;&lt;p&gt;在我们深入比较之前，让我们看一下每个选项的标准部署，以便您可以很好地直观地了解每个选项的作用。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/cloudwatch-metrics-options/cloudwatch-data-source.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="Amazon CloudWatch 数据源模型" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="Amazon CloudWatch 数据源模型" src="https://grafana.com/media/blog/cloudwatch-metrics-options/cloudwatch-data-source.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/cloudwatch-metrics-options/AWS-observability-app.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="AWS 可观测性应用程序模型" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="AWS 可观测性应用程序模型" src="https://grafana.com/media/blog/cloudwatch-metrics-options/AWS-observability-app.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;如果您对 Grafana Labs 如何将 Alloy 作为 AWS Observability 应用程序的一部分进行操作感兴趣，请在接下来的几周内关注即将发布的博客文章，该文章将深入介绍这一点。&lt;/p&gt;&lt;/blockquote&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/cloudwatch-metrics-options/Alloy-cloudwatch.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="Grafana合金模型" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="Grafana合金模型" src="https://grafana.com/media/blog/cloudwatch-metrics-options/Alloy-cloudwatch.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/cloudwatch-metrics-options/YACE-approach.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="YACE模型" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="YACE模型" src="https://grafana.com/media/blog/cloudwatch-metrics-options/YACE-approach.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;h2 id="which-approach-is-right-for-you"&gt;哪种方法适合您？&lt;/h2&gt;&lt;p&gt;在本文的其余部分，我们将重点讨论各种方法之间的相似点和差异。确切的配合将取决于您的系统和团队的需求，并且需要考虑许多因素。但在我们讨论所有这些之前，我们想指出一个事实，即开始观察您的系统的最简单方法AWS环境是Grafana Cloud。这是一个 TL;DR 决策树*，它应该可以帮助您指明正确的方向：&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/cloudwatch-metrics-options/config-decision-tree.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="应如何为 AWS 决策树配置 Grafana Cloud" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="应如何为 AWS 决策树配置 Grafana Cloud" src="https://grafana.com/media/blog/cloudwatch-metrics-options/config-decision-tree.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt; &lt;em&gt;*您可以在 Grafana Cloud 中使用 YACE 模型，但不建议这样做，因为我们将无法通过&lt;a href="https://grafana.com/docs/grafana-cloud/account-management/support/?pg=blog&amp;amp;plcmt=body-txt"&gt;标准支持票流程&lt;/a&gt;提供支持。&lt;/em&gt;&lt;/p&gt;&lt;h2 id="how-are-they-all-the-same"&gt;它们怎么都一样呢？&lt;/h2&gt;&lt;p&gt;此处概述的所有选项均使用 Amazon CloudWatch API（ &lt;a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_ListMetrics.html" rel="noopener noreferrer" target="_blank"&gt;ListMetrics&lt;/a&gt;和&lt;a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_GetMetricData.html" rel="noopener noreferrer" target="_blank"&gt;GetMetricData&lt;/a&gt; ）使数据在 Grafana 中可用。这是一件好事，因为它确保所有选项都能够生成相同的数据。 （您还应该注意，调用这些 API 会在您的 AWS 账户上产生费用。）&lt;/p&gt;&lt;p&gt;此外，每个选项还提供对各种 CloudWatch 命名空间的支持，包括通过自定义命名空间对&lt;a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/publishingMetrics.html" rel="noopener noreferrer" target="_blank"&gt;自定义指标&lt;/a&gt;的支持。&lt;/p&gt;&lt;p&gt;这里有一些您可能不知道的事情：除了 Amazon CloudWatch 数据源之外，此处列出的所有选项实际上只是不同包装器中的 YACE！我们非常重视“&lt;a href="https://grafana.com/oss/?pg=blog&amp;amp;plcmt=body-txt"&gt;开源是我们的 DNA&lt;/a&gt; ”这一理念，因此我们为改进 CloudWatch 指标解决方案所做的和继续做的所有工作都已融入 YACE。 &lt;a href="https://github.com/search?q=repo%3Anerdswords%2Fyet-another-cloudwatch-exporter&amp;#43;author%3Akgeckhart&amp;#43;author%3Acristiangreco&amp;#43;author%3Athepalbi&amp;#43;author%3Ajeschkies&amp;#43;author%3Aandriikushch&amp;#43;author%3Anikosmeds&amp;#43;author%3Atristanburgess&amp;amp;type=pullrequests" rel="noopener noreferrer" target="_blank"&gt;Grafana Labs 员工已发布 200 多个 PR&lt;/a&gt; ，主要功能包括：&lt;/p&gt;&lt;ul&gt;&lt;li&gt; &lt;a href="https://github.com/nerdswords/yet-another-cloudwatch-exporter/issues/821" rel="noopener noreferrer" target="_blank"&gt;用于将资源与 CloudWatch 指标匹配的改进算法&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://github.com/nerdswords/yet-another-cloudwatch-exporter/issues/921" rel="noopener noreferrer" target="_blank"&gt;AWS 开发工具包 v2 支持&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://github.com/nerdswords/yet-another-cloudwatch-exporter/pull/1040" rel="noopener noreferrer" target="_blank"&gt;AWS DDoS 保护支持&lt;/a&gt;和其他&lt;a href="https://github.com/nerdswords/yet-another-cloudwatch-exporter/pull/1222" rel="noopener noreferrer" target="_blank"&gt;CloudWatch 命名空间&lt;/a&gt;&lt;/li&gt;&lt;li&gt;大量&lt;a href="https://github.com/nerdswords/yet-another-cloudwatch-exporter/pull/1092" rel="noopener noreferrer" target="_blank"&gt;性能增强&lt;/a&gt;、 &lt;a href="https://github.com/nerdswords/yet-another-cloudwatch-exporter/pull/438" rel="noopener noreferrer" target="_blank"&gt;错误修复&lt;/a&gt;和&lt;a href="https://github.com/nerdswords/yet-another-cloudwatch-exporter/pull/1289" rel="noopener noreferrer" target="_blank"&gt;代码质量改进&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 id="how-are-they-different"&gt;它们有何不同？&lt;/h2&gt;&lt;p&gt;尽管有相似之处，但还是存在一些显着的差异，我们将在这里将其分为三个主要领域：存储、保真度和操作复杂性。&lt;/p&gt;&lt;h3 id="where-the-data-is-stored"&gt;数据存储位置&lt;/h3&gt;&lt;p&gt;第一个关键区别是 Amazon CloudWatch 数据源将数据保留在 AWS 中，并让您可以直接查询访问它。这是一种非常经济高效的解决方案，可在 Grafana 中实现 CloudWatch 数据的可视化。您根据查询数据的频率付费。由于它尝试镜像许多 Clo​​udWatch 功能，因此您可以访问&lt;a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/using-metric-math.html" rel="noopener noreferrer" target="_blank"&gt;度量数学&lt;/a&gt;和&lt;a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/query_with_cloudwatch-metrics-insights.html" rel="noopener noreferrer" target="_blank"&gt;Metrics Insight 查询&lt;/a&gt;等高级功能。&lt;/p&gt;&lt;p&gt;基于 YACE 的选项（AWS Observability 应用程序和 Grafana Alloy CloudWatch 导出器）均从 CloudWatch 中提取数据，将其转换为与 Prometheus 兼容的格式，并使其在集中式数据存储中可用。此方法侧重于从 CloudWatch 镜像原始数据，不允许使用度量数学或 Metrics Insights 查询等高级功能。&lt;/p&gt;&lt;p&gt;当然，这引出了一个问题：为什么要付费从 CloudWatch 中提取这些数据并将其存储在其他地方？这个模型的一个巨大卖点是，它使您能够利用 PromQL 的强大功能构建跨账户、跨区域和跨服务的仪表板、警报和查询。让我们看看查找两个账户和两个区域的 CPU 利用率的查询是什么样的，以及使用 PromQL 与 Amazon CloudWatch 数据源的比较。&lt;/p&gt;&lt;p&gt;首先，我们来看看如何使用 Amazon CloudWatch 数据源来查询 CloudWatch 中的数据。从下面 Grafana 中探索模式的屏幕截图中可以看出，您必须为每个账户设置一个 Amazon CloudWatch 数据源，并且使用手动构建器一次只能查询一个区域。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/cloudwatch-metrics-options/cloudwatch-explore.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="探索用户界面" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="探索用户界面" src="https://grafana.com/media/blog/cloudwatch-metrics-options/cloudwatch-explore.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;或者，使用 PromQL，您只需要使用过滤器运行这个非常基本的查询：&lt;/p&gt;&lt;div class="code-snippet code-snippet__mini"&gt;&lt;div class="lang-toolbar__mini"&gt; &lt;span class="code-clipboard"&gt;&lt;button&gt;&lt;img alt="将代码复制到剪贴板" class="code-clipboard__icon" height="13" src="https://grafana.com/media/images/icons/icon-copy-small-2.svg" width="14" /&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="code-snippet code-snippet__border"&gt;&lt;pre&gt;&lt;code class="language-none"&gt;aws_ec2_cpuutilization_maximum{account_id=~&amp;quot;974410390816|account2&amp;quot;, region=~&amp;quot;us-east-1|us-east-2&amp;quot;}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;h3 id="data-fidelity"&gt;数据保真度&lt;/h3&gt;&lt;p&gt;Amazon CloudWatch 数据源仅与 AWS 的 CloudWatch API 交互，因此，它只能为您提供 CloudWatch 中可用维度内的原始 CloudWatch 指标和统计数据。除非您牢记 EC2 实例 ID，否则这些信息本身通常不足以做出可行的决策。 （我知道我不知道！）&lt;/p&gt;&lt;p&gt;鉴于 CloudWatch 中这一难以填补的空白，基于 YACE 的选项包括一个称为“资源标签关联”的额外功能。此功能还需要调用 AWS 资源标记 API 并将这些标签与 CloudWatch 指标相关联。使用 CloudWatch 指标查询标签数据的功能使得在出现问题时更容易获得可操作的数据。让我们看看带有标签的 CPU 利用率查询是什么样子的：&lt;/p&gt;&lt;div class="code-snippet code-snippet__mini"&gt;&lt;div class="lang-toolbar__mini"&gt; &lt;span class="code-clipboard"&gt;&lt;button&gt;&lt;img alt="将代码复制到剪贴板" class="code-clipboard__icon" height="13" src="https://grafana.com/media/images/icons/icon-copy-small-2.svg" width="14" /&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="code-snippet code-snippet__border"&gt;&lt;pre&gt;&lt;code class="language-none"&gt;aws_ec2_cpuutilization_maximum{account_id=~&amp;quot;974410390816|account2&amp;quot;, region=~&amp;quot;us-east-1|us-east-2&amp;quot;} + on (name) group_left(tag_Application, tag_Name) aws_ec2_info&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;&lt;br /&gt;请注意，这利用了 PromQL 的&lt;code&gt;group_left&lt;/code&gt; ，它更高级一些。但如果您不是 Prometheus 专家，请不要担心：我们为您提供了 AWS Observability 应用程序，您可以在其中使用标签观察所有 EC2 和 RDS 资源 — 无需查询。查看 play.grafana.com 上的示例：&lt;/p&gt;&lt;ul&gt;&lt;li&gt; &lt;a href="https://play.grafana.org/a/grafana-aws-app/dashboard/ec2?var-datasource=grafanacloud-prom&amp;amp;var-allTagsMultipleOptions=tag_Application&amp;amp;var-metrics=aws_ec2_cpuutilization_average&amp;amp;var-metrics=aws_ec2_cpuutilization_maximum&amp;amp;var-metrics=aws_ec2_status_check_failed_sum" rel="noopener noreferrer" target="_blank"&gt;亚马逊EC2&lt;/a&gt;&lt;/li&gt;&lt;li&gt; &lt;a href="https://play.grafana.org/a/grafana-aws-app/dashboard/rds?var-datasource=bdi6x8p7vm29sd&amp;amp;var-region=$__all&amp;amp;var-account=$__all&amp;amp;var-scrape_job=$__all" rel="noopener noreferrer" target="_blank"&gt;亚马逊RDS&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;如果您想完全避免&lt;code&gt;group_left&lt;/code&gt; ，基于 YACE 的选项（AWS Observability App 和 Grafana Alloy CloudWatch 导出器）有一个可用功能，允许您将&lt;a href="https://grafana.com/docs/grafana-cloud/monitor-infrastructure/aws/cloudwatch-metrics/config-cw-metrics/?pg=blog&amp;amp;plcmt=body-txt#optionally-configure-resource-tag-use-1"&gt;标签添加到 CloudWatch 指标上&lt;/a&gt;，将查询转换回原始查询：&lt;/p&gt;&lt;div class="code-snippet code-snippet__mini"&gt;&lt;div class="lang-toolbar__mini"&gt; &lt;span class="code-clipboard"&gt;&lt;button&gt;&lt;img alt="将代码复制到剪贴板" class="code-clipboard__icon" height="13" src="https://grafana.com/media/images/icons/icon-copy-small-2.svg" width="14" /&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="code-snippet code-snippet__border"&gt;&lt;pre&gt;&lt;code class="language-none"&gt;aws_ec2_cpuutilization_maximum{account_id=~&amp;quot;974410390816|account2&amp;quot;, region=~&amp;quot;us-east-1|us-east-2&amp;quot;}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;请随意在&lt;a href="https://play.grafana.org/explore?schemaVersion=1&amp;amp;panes=%7B%2244l%22:%7B%22datasource%22:%22grafanacloud-prom%22,%22queries%22:%5B%7B%22refId%22:%22A%22,%22expr%22:%22aws_ec2_cpuutilization_maximum%7Baccount_id%3D~%5C%22974410390816%7Caccount2%5C%22,%20region%3D~%5C%22us-east-1%7Cus-east-2%5C%22%7D%20%2B%20on%20%28name%29%20group_left%28tag_Application,%20tag_Name%29%20aws_ec2_info%22,%22range%22:true,%22instant%22:true,%22datasource%22:%7B%22type%22:%22prometheus%22,%22uid%22:%22grafanacloud-prom%22%7D,%22editorMode%22:%22code%22,%22legendFormat%22:%22__auto%22,%22hide%22:false%7D,%7B%22refId%22:%22B%22,%22expr%22:%22aws_ec2_cpuutilization_maximum%7Baccount_id%3D~%5C%22974410390816%7Caccount2%5C%22,%20region%3D~%5C%22us-east-1%7Cus-east-2%5C%22%7D%22,%22range%22:true,%22instant%22:true,%22datasource%22:%7B%22type%22:%22prometheus%22,%22uid%22:%22grafanacloud-prom%22%7D,%22editorMode%22:%22code%22,%22legendFormat%22:%22__auto%22,%22hide%22:true%7D%5D,%22range%22:%7B%22from%22:%22now-1h%22,%22to%22:%22now%22%7D%7D%7D&amp;amp;orgId=1" rel="noopener noreferrer" target="_blank"&gt;play.grafana.com&lt;/a&gt;上的 Explore 中尝试这两个查询版本&lt;/p&gt;&lt;h3 id="operational-complexity"&gt;操作复杂性&lt;/h3&gt;&lt;p&gt;有两个“我们可以为您运行”选项：Amazon CloudWatch 数据源和 AWS Observability 应用程序。但如果您想更好地控制您的指标体验，您始终可以选择运行&lt;a href="https://grafana.com/oss/alloy-opentelemetry-collector/"&gt;Grafana Alloy&lt;/a&gt;甚至 YACE。通过自己运行它，您可以更严格地控​​制抓取间隔，并获得更高级的 YACE 配置，例如维度过滤器。&lt;/p&gt;&lt;p&gt;还有很多细节需要考虑，但迄今为止分享的细节是最大的区别。作为帮助您消化所有这些内容并为您提供另一个快速参考的方法，这里有一个全面的功能比较网格，可帮助您与前面介绍的决策树配合。这些应该有助于指导您完成所有 CloudWatch 指标决策。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/cloudwatch-metrics-options/Feature-comparison.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="功能对比图" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="功能对比图" src="https://grafana.com/media/blog/cloudwatch-metrics-options/Feature-comparison.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;h2 id="the-tent-will-only-get-bigger"&gt;帐篷只会变得更大&lt;/h2&gt;&lt;p&gt;如果您熟悉 CloudWatch，您可能知道提取数据并不是数据传输的唯一选择。 CloudWatch 还&lt;a href="https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/CloudWatch-Metric-Streams.html?pg=blog&amp;amp;plcmt=body-txt" rel="noopener noreferrer" target="_blank"&gt;通过 Amazon Data Firehose 提供指标流&lt;/a&gt;，如果您不知道，我们最近使用该功能来帮助启动&lt;a href="https://grafana.com/blog/2024/05/07/logs-with-firehose-cost-effective-aws-log-streaming-to-grafana-cloud/"&gt;带有对 AWS Observability 应用程序的 Firehose 支持的日志&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;我们还有更多工作正在进行中。我们的路线图包括 Grafana Alloy 的指标流支持和无代理 AWS Observability 应用程序体验。我们还计划深入了解 CloudWatch for OpenTelemetry 的世界，看看我们可以做些什么来将我们对我们最喜欢的 OSS Prometheus 导出器 (YACE) 所做的改进也带给 OTel 用户。&lt;/p&gt;&lt;p&gt; &lt;em&gt;&lt;a href="https://grafana.com/products/cloud/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana Cloud&lt;/a&gt;是开始使用指标、日志、跟踪、仪表板等的最简单方法。我们为每个用例提供慷慨的永久免费套餐和计划。&lt;a href="https://grafana.com/auth/sign-up/create-user/?pg=blog&amp;amp;plcmt=body-txt"&gt;现在免费注册&lt;/a&gt;！&lt;/em&gt;&lt;/p&gt;</description><pubDate>Wed, 22 May 2024 00:00:00 GMT</pubDate><guid isPermaLink="true">https://grafana.com/blog/2024/05/22/how-to-visualize-amazon-cloudwatch-metrics-in-grafana/</guid></item><item><title>【How to use Grafana Beyla in Grafana Alloy for eBPF-based auto-instrumentation】如何在 Grafana Alloy 中使用 Grafana Beyla 进行基于 eBPF 的自动仪表</title><link>https://grafana.com/blog/2024/05/21/how-to-use-grafana-beyla-in-grafana-alloy-for-ebpf-based-auto-instrumentation/</link><description>&lt;p&gt;在上个月的 GrafanaCON 上，我们&lt;a href="https://grafana.com/blog/2024/04/09/grafana-alloy-opentelemetry-collector-with-prometheus-pipelines/"&gt;发布了 Grafana Alloy&lt;/a&gt; ，这是我们的 OpenTelemetry Collector 开源发行版。 Alloy 是一种遥测收集器，100% OTLP 兼容，并为 OpenTelemetry 和 Prometheus 遥测格式提供本机管道，支持指标、日志、跟踪和配置文件。&lt;/p&gt;&lt;p&gt;今天，我们很高兴与大家分享， &lt;a href="https://grafana.com/blog/2023/09/13/grafana-beyla-open-source-ebpf-auto-instrumentation/"&gt;Grafana Beyla&lt;/a&gt;现已在 Grafana Alloy 中作为默认的基于 eBPF 的应用程序自动检测解决方案。这样，Alloy 用户可以自动捕获正在运行的服务的指标和跟踪，并连接到现有的遥测管道。本月发布的&lt;a href="https://github.com/grafana/alloy/releases" rel="noopener noreferrer" target="_blank"&gt;Grafana Alloy 1.1&lt;/a&gt;与 Grafana Beyla 1.5 一起发布。&lt;/p&gt;&lt;p&gt;在这篇博文中，我们将介绍如何在 Grafana Alloy 中使用 Grafana Beyla 的一些示例，包括如何从正在运行的服务获取 RED 指标以及如何在 Kubernetes 中自动检测应用程序。&lt;/p&gt;&lt;h2 id="get-red-metrics-from-your-running-services"&gt;从正在运行的服务获取 RED 指标&lt;/h2&gt;&lt;p&gt;假设您有一个正在运行的服务，该服务接受 HTTP 请求并侦听端口 8080。通常，您需要将 Prometheus 客户端库添加到您的服务并检测您的代码以收集 RED 指标。&lt;/p&gt;&lt;p&gt;通过以下配置，您可以从服务获取 RED 指标，而无需更改代码：&lt;/p&gt;&lt;div class="code-snippet "&gt;&lt;div class="lang-toolbar"&gt;&lt;span class="lang-toolbar__item"&gt;合金&lt;/span&gt;&lt;span class="code-clipboard"&gt;&lt;button&gt;&lt;img alt="将代码复制到剪贴板" class="code-clipboard__icon" height="13" src="https://grafana.com/media/images/icons/icon-copy-small-2.svg" width="14" /&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;div class="lang-toolbar__border"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="code-snippet "&gt;&lt;pre&gt; &lt;code class="language-alloy"&gt;beyla.ebpf &amp;quot;default&amp;quot; { open_port = &amp;quot;8080&amp;quot; } prometheus.scrape &amp;quot;beyla&amp;quot; { targets = beyla.ebpf.default.targets forward_to = [prometheus.remote_write.demo.receiver] } prometheus.remote_write &amp;quot;demo&amp;quot; { endpoint { url = &amp;lt;PROMETHEUS_REMOTE_WRITE_URL&amp;gt; basic_auth { username = &amp;lt;USERNAME&amp;gt; password = &amp;lt;PASSWORD&amp;gt; } } }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;通过此配置， &lt;code&gt;beyla.ebpf&lt;/code&gt;组件检测侦听端口 8080 的服务。 &lt;code&gt;open_port&lt;/code&gt;参数接受一系列端口、单个端口或逗号分隔的端口列表，因此您可以一次检测多个服务。您还可以使用&lt;code&gt;executable_name&lt;/code&gt;参数指定要检测的服务的可执行文件的路径。&lt;/p&gt;&lt;p&gt; &lt;code&gt;prometheus.scrape&lt;/code&gt;组件从&lt;code&gt;beyla.ebpf&lt;/code&gt;组件中抓取指标并将其转发到 Prometheus 远程写入端点。&lt;/p&gt;&lt;p&gt;将&lt;code&gt;&amp;lt;PROMETHEUS_REMOTE_WRITE_URL&amp;gt;&lt;/code&gt; 、 &lt;code&gt;&amp;lt;USERNAME&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;PASSWORD&amp;gt;&lt;/code&gt;替换为您的 Prometheus 远程写入端点 URL、用户名和密码。&lt;/p&gt;&lt;p&gt;您需要使用&lt;code&gt;sudo&lt;/code&gt;权限运行 Alloy 才能允许基于 eBPF 的检测工作。&lt;/p&gt;&lt;p&gt;有关配置选项的更多详细信息，请参阅&lt;a href="https://grafana.com/docs/alloy/latest/reference/components/beyla.ebpf/"&gt;Grafana Alloy beyla.ebpf 组件的文档&lt;/a&gt;。&lt;/p&gt;&lt;h2 id="instrument-your-applications-automatically-in-kubernetes"&gt;在 Kubernetes 中自动检测您的应用程序&lt;/h2&gt;&lt;p&gt;随着&lt;a href="https://grafana.com/blog/2024/01/24/grafana-beyla-1.2-release-ebpf-auto-instrumentation-with-full-kubernetes-support/"&gt;Grafana Beyla 1.2 版本的发布&lt;/a&gt;，我们宣布对 Beyla 提供原生 Kubernetes 支持。现在，借助 Grafana Alloy，您可以使用 Helm 图表在 Kubernetes 集群中部署 Beyla 并自动检测您的应用程序。&lt;/p&gt;&lt;p&gt;为了演示其工作原理，让我们回顾一下&lt;a href="https://grafana.com/blog/2024/01/24/grafana-beyla-1.2-release-ebpf-auto-instrumentation-with-full-kubernetes-support/"&gt;Beyla 1.2 发布帖子&lt;/a&gt;中的示例。&lt;/p&gt;&lt;h3 id="1-prepare-the-alloy-environment-in-kubernetes"&gt; 1.在Kubernetes中准备Alloy环境&lt;/h3&gt;&lt;p&gt;您需要在 Kubernetes 集群中安装 Grafana Alloy 的 Helm 图表。&lt;/p&gt;&lt;div class="code-snippet "&gt;&lt;div class="lang-toolbar"&gt;&lt;span class="lang-toolbar__item"&gt;巴什&lt;/span&gt;&lt;span class="code-clipboard"&gt;&lt;button&gt;&lt;img alt="将代码复制到剪贴板" class="code-clipboard__icon" height="13" src="https://grafana.com/media/images/icons/icon-copy-small-2.svg" width="14" /&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;div class="lang-toolbar__border"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="code-snippet "&gt;&lt;pre&gt; &lt;code class="language-bash"&gt;helm install --namespace alloy alloy grafana/alloy&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;此命令将 Grafana Alloy Helm 图表安装在&lt;code&gt;alloy&lt;/code&gt;命名空间中。&lt;/p&gt;&lt;h3 id="2-deploy-services"&gt; 2. 部署服务&lt;/h3&gt;&lt;p&gt;您可以在 Kubernetes 集群中检测任何 HTTP、HTTPS 或 gRPC 服务。您可以使用 Grafana Beyla 存储库中的&lt;a href="https://github.com/grafana/beyla/blob/main/examples/alloy/sampleapps.yml" rel="noopener noreferrer" target="_blank"&gt;&lt;code&gt;sampleapps.yml&lt;/code&gt;文件&lt;/a&gt;，并使用命令&lt;code&gt;kubectl apply -f sampleapps.yml&lt;/code&gt;进行部署。&lt;/p&gt;&lt;h3 id="3-configure-credentials"&gt; 3. 配置凭据&lt;/h3&gt;&lt;p&gt;Alloy 可以将指标和跟踪导出到任何 OpenTelemetry 端点，以及将指标公开为 Prometheus 端点。但是，我们建议在 Grafana Cloud 中使用 Grafana Tempo 远程写入端点。 （还没有免费的 Grafana Cloud 帐户？&lt;a href="https://grafana.com/auth/sign-up/create-user"&gt;立即注册一个！&lt;/a&gt; ）&lt;/p&gt;&lt;p&gt;从 Grafana Cloud 门户中，找到&lt;strong&gt;Tempo&lt;/strong&gt;框并单击&lt;strong&gt;Send Traces&lt;/strong&gt; 。&lt;/p&gt;&lt;p&gt;使用 Grafana Cloud 凭据创建一个&lt;code&gt;secrets.yml&lt;/code&gt;文件，用于 Prometheus 和 Tempo 远程写入。使用命令&lt;code&gt;kubectl apply -f secrets.yml&lt;/code&gt;进行部署。&lt;/p&gt;&lt;div class="code-snippet "&gt;&lt;div class="lang-toolbar"&gt; &lt;span class="lang-toolbar__item"&gt;yaml&lt;/span&gt; &lt;span class="code-clipboard"&gt;&lt;button&gt;&lt;img alt="将代码复制到剪贴板" class="code-clipboard__icon" height="13" src="https://grafana.com/media/images/icons/icon-copy-small-2.svg" width="14" /&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;div class="lang-toolbar__border"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="code-snippet "&gt;&lt;pre&gt; &lt;code class="language-yaml"&gt;apiVersion: v1 kind: Secret metadata: namespace: alloy name: grafana-credentials type: Opaque stringData: tempo-rw-user: &amp;quot;tempo-user&amp;quot; tempo-rw-pwd: &amp;quot;tempo-pwd&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;h3 id="4-create-a-configmap-with-alloy-configuration"&gt; 4. 使用 Alloy 配置创建 ConfigMap&lt;/h3&gt;&lt;p&gt;将以下内容复制到文件中（例如&lt;code&gt;config.alloy&lt;/code&gt; ）并使用命令&lt;code&gt;kubectl create configmap --namespace alloy alloy-config &amp;quot;--from-file=config.alloy=./config.alloy&amp;quot;&lt;/code&gt;进行部署。&lt;/p&gt;&lt;div class="code-snippet "&gt;&lt;div class="lang-toolbar"&gt;&lt;span class="lang-toolbar__item"&gt;合金&lt;/span&gt;&lt;span class="code-clipboard"&gt;&lt;button&gt;&lt;img alt="将代码复制到剪贴板" class="code-clipboard__icon" height="13" src="https://grafana.com/media/images/icons/icon-copy-small-2.svg" width="14" /&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;div class="lang-toolbar__border"&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class="code-snippet "&gt;&lt;pre&gt; &lt;code class="language-alloy"&gt;beyla.ebpf &amp;quot;default&amp;quot; { attributes { kubernetes { enable = &amp;quot;true&amp;quot; } } discovery { services { exe_path = &amp;quot;http&amp;quot; open_ports = &amp;quot;80&amp;quot; } } output { traces = [otelcol.processor.batch.default.input] } } otelcol.processor.batch &amp;quot;default&amp;quot; { output { traces = [otelcol.exporter.otlp.grafana_cloud_tempo.input] } } otelcol.exporter.otlp &amp;quot;grafana_cloud_tempo&amp;quot; { client { endpoint = &amp;quot;tempo-us-central1.grafana.net:443&amp;quot; auth = otelcol.auth.basic.grafana_cloud_tempo.handler } } otelcol.auth.basic &amp;quot;grafana_cloud_tempo&amp;quot; { username = env(&amp;quot;TEMPO_REMOTE_WRITE_USERNAME&amp;quot;) password = env(&amp;quot;TEMPO_REMOTE_WRITE_PASSWORD&amp;quot;) }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;在此配置中，Beyla 配置为检测 Kubernetes 集群中运行的服务并将跟踪发送到 Grafana Cloud Traces。&lt;/p&gt;&lt;p&gt;参数&lt;code&gt;discovery &amp;gt; services &amp;gt; exe_path&lt;/code&gt;指定要检测的服务的可执行文件的路径。 &lt;code&gt;discovery &amp;gt; services &amp;gt; open_ports&lt;/code&gt;参数指定服务正在侦听的端口。&lt;/p&gt;&lt;p&gt;指标和跟踪可以使用运行自动检测服务的 Kubernetes 实体的元数据进行修饰。要启用此功能，请将&lt;code&gt;attributes &amp;gt; kubernetes &amp;gt; enable&lt;/code&gt;参数设置为&lt;code&gt;true&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt; Beyla 组件的&lt;code&gt;output&lt;/code&gt;部分指定应将跟踪发送到&lt;code&gt;otelcol.exporter.otlp&lt;/code&gt; 。 &lt;code&gt;otelcol.exporter.otlp&lt;/code&gt;部分配置 OTLP 导出器以将跟踪发送到 Grafana Cloud Tempo。&lt;/p&gt;&lt;h3 id="5-deploy-alloy-with-helm"&gt; 5. 使用 Helm 部署 Alloy&lt;/h3&gt;&lt;p&gt;使用 Alloy Helm 图表的配置创建&lt;code&gt;values.yaml&lt;/code&gt;文件。您可以使用 Grafana Beyla 的 GitHub 存储库中的&lt;a href="https://github.com/grafana/beyla/blob/main/examples/alloy/values.yaml" rel="noopener noreferrer" target="_blank"&gt;&lt;code&gt;values.yaml&lt;/code&gt;文件&lt;/a&gt;作为参考，然后使用命令&lt;code&gt;helm upgrade --namespace alloy alloy grafana/alloy -f values.yaml&lt;/code&gt;进行部署。&lt;/p&gt;&lt;p&gt;请注意：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;要在 DaemonSet 模式下运行，Beyla 需要访问节点中的所有进程。因此，在&lt;code&gt;controller&lt;/code&gt;部分设置&lt;code&gt;hostPID: true&lt;/code&gt; 。&lt;/li&gt;&lt;li&gt; Beyla 容器以特权运行，因为它必须执行特权操作，例如加载 BPF 程序和创建 BPF 映射。因此&lt;code&gt;privileged: true&lt;/code&gt;在&lt;code&gt;securityContext&lt;/code&gt;部分中设置。要将 Beyla 作为&lt;code&gt;unprivileged&lt;/code&gt;容器运行（即没有&lt;code&gt;privileged: true&lt;/code&gt;选项），请访问&lt;a href="https://grafana.com/docs/beyla/latest/setup/kubernetes/#deploy-beyla-unprivileged"&gt;部署 Beyla 非特权指南&lt;/a&gt;。&lt;/li&gt;&lt;li&gt; &lt;code&gt;extraEnv&lt;/code&gt;部分设置 Tempo 远程写入凭据的环境变量。&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="6-test-the-setup"&gt; 6. 测试设置&lt;/h3&gt;&lt;p&gt;在第一步中的&lt;code&gt;kubectl port-forward&lt;/code&gt;命令仍在运行的情况下，测试两个 Web 服务器实例。例如：&lt;/p&gt;&lt;div class="code-snippet code-snippet__mini"&gt;&lt;div class="lang-toolbar__mini"&gt; &lt;span class="code-clipboard"&gt;&lt;button&gt;&lt;img alt="将代码复制到剪贴板" class="code-clipboard__icon" height="13" src="https://grafana.com/media/images/icons/icon-copy-small-2.svg" width="14" /&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="code-snippet code-snippet__border"&gt;&lt;pre&gt;&lt;code class="language-none"&gt;curl http://localhost:8080 curl http://localhost:8080/foo curl http://localhost:8081 curl http://localhost:8081/foo&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;现在，转到 Grafana Cloud 中的实例，然后从左侧面板的&lt;strong&gt;“探索”&lt;/strong&gt;部分中选择跟踪的数据源（通常名为&lt;code&gt;grafanacloud-&amp;lt;your user name&amp;gt;-traces&lt;/code&gt; ）。&lt;/p&gt;&lt;p&gt;&lt;img alt="选择轨迹数据源" class="lazyload" /&gt;&lt;/p&gt;&lt;p&gt;要搜索所有跟踪，请选择查询栏中的&lt;strong&gt;“搜索”&lt;/strong&gt;框，将表单留空，然后单击&lt;strong&gt;“运行查询”&lt;/strong&gt; 。&lt;/p&gt;&lt;p&gt;&lt;img alt="搜索系统中所有痕迹" class="lazyload" /&gt;&lt;/p&gt;&lt;p&gt;这将显示&lt;code&gt;docs&lt;/code&gt;实例（端口 8081）的跟踪。您可能会看到来自您自己的服务的痕迹，但不应看到来自&lt;code&gt;website&lt;/code&gt;服务的痕迹，因为它尚未经过 Beyla 检测。&lt;/p&gt;&lt;p&gt;&lt;img alt="Grafana Cloud 跟踪列表" class="lazyload" /&gt;&lt;/p&gt;&lt;p&gt;在跟踪详细信息中，跟踪的资源属性使用运行检测服务的 Kubernetes Pod 的元数据进行修饰。&lt;/p&gt;&lt;p&gt;&lt;img alt="跟踪的详细信息" class="lazyload" /&gt;&lt;/p&gt;&lt;h2 id="whats-next"&gt;下一步是什么？&lt;/h2&gt;&lt;p&gt;在这篇博文中，我们介绍了如何在 Grafana Alloy 中使用 Grafana Beyla 从正在运行的服务获取 RED 指标，以及如何在 Kubernetes 中自动检测您的应用程序。&lt;/p&gt;&lt;p&gt;将来，我们计划向 Beyla 添加更多配置选项，以允许用户自定义其应用程序的检测。我们还计划支持更多协议来自动检测。最后，在 Beyla 的未来版本中，我们计划添加对更多基于 eBPF 的功能的支持，例如网络监控。敬请期待更多的更新！&lt;/p&gt;</description><pubDate>Tue, 21 May 2024 14:12:00 GMT</pubDate><guid isPermaLink="true">https://grafana.com/blog/2024/05/21/how-to-use-grafana-beyla-in-grafana-alloy-for-ebpf-based-auto-instrumentation/</guid></item><item><title>【Grafana OnCall: Connect to Discord, Mattermost, and more with webhooks】Grafana OnCall：使用 webhooks 连接到 Discord、Mattermost 等</title><link>https://grafana.com/blog/2024/05/20/grafana-oncall-connect-to-discord-mattermost-and-more-with-webhooks/</link><description>&lt;p&gt;采用工具时的一个重要考虑因素是它是否可以与您现有的工作流程和服务集成。每个场景都可能非常具体，这就是为什么寻找具有公共 API 或可自定义 Webhook 的工具非常重要。&lt;/p&gt;&lt;p&gt;去年， &lt;a href="https://grafana.com/products/cloud/oncall/"&gt;Grafana OnCall&lt;/a&gt;扩展了其&lt;a href="https://grafana.com/docs/grafana-cloud/alerting-and-irm/oncall/outgoing-webhooks/"&gt;Webhook 支持&lt;/a&gt;，以允许更复杂的设置，从而在警报组事件期间提供与其他服务交互的更大灵活性。&lt;/p&gt;&lt;p&gt;这些网络钩子如何工作？为了说明如何调整 Grafana OnCall 并将其与现有环境联系起来，我们将向您展示如何向其他消息传递解决方案（例如&lt;a href="https://mattermost.com/" rel="noopener noreferrer" target="_blank"&gt;Mattermost&lt;/a&gt;和&lt;a href="https://discord.com/" rel="noopener noreferrer" target="_blank"&gt;Discord）&lt;/a&gt;发送警报组通知和更新，这些解决方案尚未开箱即用，但仍然可以插入进入您的工作流程。&lt;/p&gt;&lt;p&gt;这里的目标是将 Grafana OnCall Webhooks 连接到第三方 API，建立一个简单的&lt;strong&gt;单向&lt;/strong&gt;同步（OnCall -&amp;gt; 外部服务）以保持状态信息最新，而无需编写任何代码。我们将分别介绍每个流行的 ChatOps 应用程序的流程，以表明虽然连接可能不同，但 Grafana OnCall 中的设置本质上是相同的，所以让我们看看它是如何工作的！&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;为了更完整的集成或双向同步，需要额外的逻辑和/或使用我们的&lt;a href="https://grafana.com/docs/grafana-cloud/alerting-and-irm/oncall/oncall-api-reference/"&gt;OnCall API&lt;/a&gt; 。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id="how-to-integrate-grafana-oncall-with-mattermost"&gt;如何将 Grafana OnCall 与 Mattermost 集成&lt;/h2&gt;&lt;p&gt;Mattermost 是一种流行的开源且灵活的消息传递服务，支持多种集成，您可以自行托管或用作云即服务。对于此集成，计划创建一个机器人，将警报组详细信息发布到 Mattermost 渠道，并使这些警报组的状态和信息保持最新。&lt;/p&gt;&lt;p&gt;首先，让我们创建&lt;a href="https://developers.mattermost.com/integrate/reference/bot-accounts/" rel="noopener noreferrer" target="_blank"&gt;机器人帐户&lt;/a&gt;以使用其访问令牌访问&lt;a href="https://api.mattermost.com/" rel="noopener noreferrer" target="_blank"&gt;Mattermost API&lt;/a&gt; ：&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/oncall-chatops/create-bot.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="最重要的集成菜单" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="最重要的集成菜单" src="https://grafana.com/media/blog/oncall-chatops/create-bot.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;您可能需要设置系统管理员角色以允许机器人更新消息。请参阅&lt;a href="https://developers.mattermost.com/integrate/reference/bot-accounts/#can-bot-accounts-edit-messages-through-the-restful-api" rel="noopener noreferrer" target="_blank"&gt;此 Mattermost 常见问题解答&lt;/a&gt;以了解更多信息。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;创建后您将获得一个代币；确保保留该值。&lt;/p&gt;&lt;p&gt;接下来，将机器人用户添加为您希望将通知发布到的频道中的成员，并从该频道的信息视图中获取频道 ID。要到达那里，请单击频道名称下拉列表，您将看到“查看信息”选项。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/oncall-chatops/mattermost-id-info.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="最重要的 ID 信息" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="最重要的 ID 信息" src="https://grafana.com/media/blog/oncall-chatops/mattermost-id-info.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;此时，您应该拥有一个令牌，并且能够使用该 &lt;a href="https://api.mattermost.com/#tag/authentication" rel="noopener noreferrer" target="_blank"&gt;令牌&lt;/a&gt;以及通道 ID 来访问 Mattermost API，以作为机器人在指定的 Mattermost 通道中发布消息。使用此&lt;code&gt;curl&lt;/code&gt;命令来测试我们想要在Grafana OnCall中使用的流程：&lt;/p&gt;&lt;div class="code-snippet code-snippet__mini"&gt;&lt;div class="lang-toolbar__mini"&gt; &lt;span class="code-clipboard"&gt;&lt;button&gt;&lt;img alt="将代码复制到剪贴板" class="code-clipboard__icon" height="13" src="https://grafana.com/media/images/icons/icon-copy-small-2.svg" width="14" /&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="code-snippet code-snippet__border"&gt;&lt;pre&gt;&lt;code class="language-none"&gt;$ curl -i -X POST -H &amp;#39;Content-Type: application/json&amp;#39; -d &amp;#39;{&amp;quot;channel_id&amp;quot;:&amp;quot;eorfq3i1zj89jg7pqpzpyp8rxh&amp;quot;, &amp;quot;message&amp;quot;:&amp;quot;This is a message from a bot&amp;quot;, &amp;quot;props&amp;quot;:{&amp;quot;attachments&amp;quot;: [{&amp;quot;pretext&amp;quot;: &amp;quot;Look some text&amp;quot;,&amp;quot;text&amp;quot;: &amp;quot;This is text&amp;quot;}]}}&amp;#39; -H &amp;#39;Authorization: Bearer qwd4k954qjyx3euumnbnqfa6wo&amp;#39; http://localhost:8065/api/v4/posts8065/api/v4/posts&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;它应该返回类似于以下内容的输出：&lt;/p&gt;&lt;div class="code-snippet code-snippet__mini"&gt;&lt;div class="lang-toolbar__mini"&gt; &lt;span class="code-clipboard"&gt;&lt;button&gt;&lt;img alt="将代码复制到剪贴板" class="code-clipboard__icon" height="13" src="https://grafana.com/media/images/icons/icon-copy-small-2.svg" width="14" /&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="code-snippet code-snippet__border"&gt;&lt;pre&gt;&lt;code class="language-none"&gt;HTTP/1.1 201 Created Content-Type: application/json Permissions-Policy: Referrer-Policy: no-referrer Vary: Accept-Encoding X-Content-Type-Options: nosniff X-Request-Id: mdubxdeqffffpxkcbu65fxaino X-Version-Id: 7.9.0.7.9.0.7f5ade118b6f3cf753675a3fdfaa6d40.false Date: Tue, 16 Apr 2024 17:11:46 GMT Content-Length: 725 {&amp;quot;id&amp;quot;:&amp;quot;kxi7owmor3y9proo5rkef64our&amp;quot;,&amp;quot;create_at&amp;quot;:1713287506329,&amp;quot;update_at&amp;quot;:1713287506329,&amp;quot;edit_at&amp;quot;:0,&amp;quot;delete_at&amp;quot;:0,&amp;quot;is_pinned&amp;quot;:false,&amp;quot;user_id&amp;quot;:&amp;quot;rks6to6tz7n19etm6oboe9s9zh&amp;quot;,&amp;quot;channel_id&amp;quot;:&amp;quot;eorfq3i1zj89jg7pqpzpyp8rxh&amp;quot;,&amp;quot;root_id&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;original_id&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;message&amp;quot;:&amp;quot;This is a message from a bot&amp;quot;,&amp;quot;type&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;props&amp;quot;:{&amp;quot;attachments&amp;quot;:[{&amp;quot;id&amp;quot;:0,&amp;quot;fallback&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;color&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;pretext&amp;quot;:&amp;quot;Look some text&amp;quot;,&amp;quot;author_name&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;author_link&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;author_icon&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;title&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;title_link&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;text&amp;quot;:&amp;quot;This is text&amp;quot;,&amp;quot;fields&amp;quot;:null,&amp;quot;image_url&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;thumb_url&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;footer&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;footer_icon&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;ts&amp;quot;:null}],&amp;quot;from_bot&amp;quot;:&amp;quot;true&amp;quot;},&amp;quot;hashtags&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;pending_post_id&amp;quot;:&amp;quot;&amp;quot;,&amp;quot;reply_count&amp;quot;:0,&amp;quot;last_reply_at&amp;quot;:0,&amp;quot;participants&amp;quot;:null,&amp;quot;metadata&amp;quot;:{&amp;quot;embeds&amp;quot;:[{&amp;quot;type&amp;quot;:&amp;quot;message_attachment&amp;quot;}]}}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;发出上述请求后，您应该会在 Mattermost 频道中收到一条类似于下面屏幕截图中的消息，确认凭据和频道 ID 正常，并且我们可以使用该 API。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/oncall-chatops/oncall-bot-message.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="Oncall 机器人消息" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="Oncall 机器人消息" src="https://grafana.com/media/blog/oncall-chatops/oncall-bot-message.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;回到我们使用 webhooks 创建 Grafana OnCall 集成计划的目标，我们对我们的用例的以下 Mattermost API 端点（仅供参考）感兴趣：&lt;/p&gt;&lt;ul&gt;&lt;li&gt; &lt;a href="https://api.mattermost.com/#tag/posts/operation/CreatePost" rel="noopener noreferrer" target="_blank"&gt;创建帖子&lt;/a&gt;，发布新的警报组通知&lt;/li&gt;&lt;li&gt;&lt;a href="https://api.mattermost.com/#tag/posts/operation/UpdatePost" rel="noopener noreferrer" target="_blank"&gt;更新帖子&lt;/a&gt;，以在警报组更新时更新之前发送的通知&lt;/li&gt;&lt;/ul&gt;&lt;h3 id="how-to-connect-grafana-oncall-to-mattermost"&gt;如何将 Grafana OnCall 连接到 Mattermost&lt;/h3&gt;&lt;p&gt;在 Grafana OnCall 中，我们需要配置两个 Webhook：一个用于在创建警报组时发布通知（使用“创建帖子”端点），另一个用于在警报组状态更改时更新该通知（使用“更新帖子”端点）。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/oncall-chatops/mattermost.gif"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="将 Grafana OnCall 连接到 Mattermost 的步骤" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="将 Grafana OnCall 连接到 Mattermost 的步骤" src="https://grafana.com/media/blog/oncall-chatops/mattermost.gif" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;让我们首先设置&lt;code&gt;Alert Group Created&lt;/code&gt; webhook：&lt;/p&gt;&lt;p&gt;如果您在自己的计算机上进行操作，则需要输入以下内容才能实现上面 GIF 中概述的步骤中所看到的内容：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;名称：&lt;/strong&gt; mattermost-new&lt;/li&gt;&lt;li&gt;&lt;strong&gt;启用：&lt;/strong&gt;真&lt;/li&gt;&lt;li&gt;&lt;strong&gt;触发类型：&lt;/strong&gt;已创建警报组&lt;/li&gt;&lt;li&gt;&lt;strong&gt;HTTP 方法：&lt;/strong&gt; POST&lt;/li&gt;&lt;li&gt; &lt;strong&gt;Webhook URL：&lt;/strong&gt; http://localhost:8065/api/v4/posts&lt;/li&gt;&lt;li&gt;&lt;strong&gt;授权标头：&lt;/strong&gt; Bearer [您的令牌]&lt;/li&gt;&lt;li&gt;&lt;strong&gt;全部转发：&lt;/strong&gt;错误&lt;/li&gt;&lt;li&gt;&lt;strong&gt;数据：&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div class="code-snippet code-snippet__mini"&gt;&lt;div class="lang-toolbar__mini"&gt; &lt;span class="code-clipboard"&gt;&lt;button&gt;&lt;img alt="将代码复制到剪贴板" class="code-clipboard__icon" height="13" src="https://grafana.com/media/images/icons/icon-copy-small-2.svg" width="14" /&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="code-snippet code-snippet__border"&gt;&lt;pre&gt;&lt;code class="language-none"&gt;{ &amp;quot;channel_id&amp;quot;: &amp;quot;eorfq3i1zj89jg7pqpzpyp8rxh&amp;quot;, &amp;quot;message&amp;quot;: &amp;quot;{% if alert_group.state == &amp;#39;acknowledged&amp;#39;%}:large_orange_circle:{% elif alert_group.state == &amp;#39;resolved&amp;#39;%}:large_green_circle:{% elif alert_group.state == &amp;#39;silenced&amp;#39;%}:white_circle:{% else %}:red_circle:{% endif %} **{{ alert_group.title }}**\n*{{ alert_group.state }}*\n{{ alert_payload.message }}\n*{{ integration.name }}*\n\n{% if event.type == &amp;#39;acknowledge&amp;#39; %}**Acknowledged by: {{ user.username }}**{% endif %}{% if event.type == &amp;#39;resolve&amp;#39; %}**Resolved by: {{ user.username }}**{% endif %}{% if event.type == &amp;#39;silence&amp;#39; %}**Silenced by: {{ user.username }} (until {{ event.until }})**{% endif %}\n\n[View in Grafana OnCall]({{ alert_group.permalinks.web }})&amp;quot; }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;要更新已发送的通知，您需要拥有原始消息 ID。触发我们刚刚创建的 Webhook 后，此 ID 将包含在响应中。 Grafana OnCall Webhook 维护链接到警报组的先前响应的记录，使我们能够在更新 Webhook 中 &lt;a href="https://grafana.com/docs/oncall/latest/configure/outgoing-webhooks/#using-response-data"&gt;引用&lt;/a&gt;此信息。&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/oncall-chatops/outgoing-webhook-details.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="传出 Webhook 详细信息" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="传出 Webhook 详细信息" src="https://grafana.com/media/blog/oncall-chatops/outgoing-webhook-details.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;然后，我们可以使用模板表达式&lt;code&gt;{{ responses.WHK9SLCGJBPZK5.id }}&lt;/code&gt;来引用 ID 为&lt;code&gt;WHK9SLCGJBPZK5&lt;/code&gt;的 Webhook 的上一个响应中的&lt;code&gt;id&lt;/code&gt;字段，对应于触发状态更改的同一警报组。 （这是&lt;code&gt;mattermost-new&lt;/code&gt; Webhook。您可以从 Webhooks 列表 UI 获取此 ID；请参见下文。）&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/oncall-chatops/webhooks-listing-ui.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="Webhook 列表" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="Webhook 列表" src="https://grafana.com/media/blog/oncall-chatops/webhooks-listing-ui.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;考虑到这一点，我们现在将设置&lt;code&gt;Alert Group Status Change&lt;/code&gt; Webhook。以下是配置 Webhook 时需要输入的信息：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;名称：&lt;/strong&gt; mattermost-update&lt;/li&gt;&lt;li&gt;&lt;strong&gt;启用：&lt;/strong&gt;真&lt;/li&gt;&lt;li&gt;&lt;strong&gt;触发类型：&lt;/strong&gt;警报组状态变化&lt;/li&gt;&lt;li&gt;&lt;strong&gt;HTTP 方法：&lt;/strong&gt; PUT&lt;/li&gt;&lt;li&gt; &lt;strong&gt;Webhook URL：（&lt;/strong&gt;&lt;em&gt;请改用您的 thingmost-new webhook ID。&lt;/em&gt; ）http://localhost:8065/api/v4/posts/{{response.WHK9SLCGJBPZK5.id }}&lt;/li&gt;&lt;li&gt;&lt;strong&gt;授权标头：&lt;/strong&gt; Bearer [您的令牌]&lt;/li&gt;&lt;li&gt;&lt;strong&gt;全部转发：&lt;/strong&gt;错误&lt;/li&gt;&lt;li&gt;&lt;strong&gt;数据：（&lt;/strong&gt;&lt;em&gt;请使用您最新的 webhook ID。&lt;/em&gt; ）&lt;/li&gt;&lt;/ul&gt;&lt;div class="code-snippet code-snippet__mini"&gt;&lt;div class="lang-toolbar__mini"&gt; &lt;span class="code-clipboard"&gt;&lt;button&gt;&lt;img alt="将代码复制到剪贴板" class="code-clipboard__icon" height="13" src="https://grafana.com/media/images/icons/icon-copy-small-2.svg" width="14" /&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="code-snippet code-snippet__border"&gt;&lt;pre&gt;&lt;code class="language-none"&gt;{ &amp;quot;id&amp;quot;: &amp;quot;{{ responses.WHK9SLCGJBPZK5.id }}&amp;quot;, &amp;quot;message&amp;quot;: &amp;quot;{% if alert_group.state == &amp;#39;acknowledged&amp;#39;%}:large_orange_circle:{% elif alert_group.state == &amp;#39;resolved&amp;#39;%}:large_green_circle:{% elif alert_group.state == &amp;#39;silenced&amp;#39;%}:white_circle:{% else %}:red_circle:{% endif %} **{{ alert_group.title }}**\n*{{ alert_group.state }}*\n{{ alert_payload.message }}\n*{{ integration.name }}*\n\n{% if event.type == &amp;#39;acknowledge&amp;#39; %}**Acknowledged by: {{ user.username }}**{% endif %}{% if event.type == &amp;#39;resolve&amp;#39; %}**Resolved by: {{ user.username }}**{% endif %}{% if event.type == &amp;#39;silence&amp;#39; %}**Silenced by: {{ user.username }} (until {{ event.until }})**{% endif %}\n\n[View in Grafana OnCall]({{ alert_group.permalinks.web }})&amp;quot; }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;就是这样！如果您发送&lt;a href="https://grafana.com/docs/oncall/latest/set-up/get-started/#send-a-demo-alert"&gt;演示警报&lt;/a&gt;，您应该会收到类似于以下内容的通知：&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/oncall-chatops/incident-firing.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="Grafana Oncall 中的事件触发消息" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="Grafana Oncall 中的事件触发消息" src="https://grafana.com/media/blog/oncall-chatops/incident-firing.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;确认后，将更新为：&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/oncall-chatops/incident-acknowledged.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="来自 Grafana Oncall 的事件确认消息" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="来自 Grafana Oncall 的事件确认消息" src="https://grafana.com/media/blog/oncall-chatops/incident-acknowledged.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;blockquote&gt;&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;由于我们没有设置任何&lt;a href="https://grafana.com/docs/oncall/latest/configure/outgoing-webhooks/#integrations"&gt;集成&lt;/a&gt;作为过滤依据，因此将为堆栈中的每个警报组触发 Webhooks。&lt;/p&gt;&lt;/blockquote&gt;&lt;h2 id="how-to-integrate-grafana-oncall-with-discord"&gt;如何将 Grafana OnCall 与 Discord 集成&lt;/h2&gt;&lt;p&gt;Discord 是一个即时消息和 VoIP 社交平台，支持语音通话、视频通话、短信以及媒体和文件。对于此集成，计划创建一个机器人，将警报组详细信息发布到频道，并使这些警报组的状态和信息保持最新。&lt;/p&gt;&lt;p&gt;在本例中，我们将使用&lt;a href="https://support.discord.com/hc/en-us/articles/228383668-Intro-to-Webhooks" rel="noopener noreferrer" target="_blank"&gt;Discord webhooks&lt;/a&gt;来实现通知：&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/oncall-chatops/new-webhook.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="不和谐集成 UI" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="不和谐集成 UI" src="https://grafana.com/media/blog/oncall-chatops/new-webhook.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;通过 webhook URL 我们可以进行&lt;a href="https://discord.com/developers/docs/resources/webhook" rel="noopener noreferrer" target="_blank"&gt;多种操作&lt;/a&gt;。出于我们的目的，我们感兴趣的是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt; &lt;a href="https://discord.com/developers/docs/resources/webhook#execute-webhook" rel="noopener noreferrer" target="_blank"&gt;创建消息&lt;/a&gt;，发布新的警报组通知&lt;/li&gt;&lt;li&gt;&lt;a href="https://discord.com/developers/docs/resources/webhook#edit-webhook-message" rel="noopener noreferrer" target="_blank"&gt;编辑消息&lt;/a&gt;，以在更新警报组时更新先前发送的通知&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;注意：创建消息时，我们需要设置&lt;code&gt;?wait=true&lt;/code&gt;查询参数以获取包含创建的消息信息的响应，稍后我们需要更新该消息。&lt;/p&gt;&lt;h3 id="how-to-connect-grafana-oncall-to-discord"&gt;如何将 Grafana OnCall 连接到 Discord&lt;/h3&gt;&lt;p&gt;与我们为 Mattermost 所做的类似，我们需要按照链接的 API 规范创建 Grafana OnCall Webhook：&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/oncall-chatops/discord.gif"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="在 Grafana Oncall 中连接到 Discord 的步骤" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="在 Grafana Oncall 中连接到 Discord 的步骤" src="https://grafana.com/media/blog/oncall-chatops/discord.gif" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;您需要输入以下内容才能实现上面 GIF 中概述的步骤中所看到的内容：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;名称：&lt;/strong&gt; discord-新&lt;/li&gt;&lt;li&gt;&lt;strong&gt;启用：&lt;/strong&gt;真&lt;/li&gt;&lt;li&gt;&lt;strong&gt;触发类型：&lt;/strong&gt;已创建警报组&lt;/li&gt;&lt;li&gt;&lt;strong&gt;HTTP 方法：&lt;/strong&gt; POST&lt;/li&gt;&lt;li&gt; &lt;strong&gt;Webhook URL：&lt;/strong&gt; [您的 Discord webhook URL]？wait=true&lt;/li&gt;&lt;li&gt;&lt;strong&gt;全部转发：&lt;/strong&gt;错误&lt;/li&gt;&lt;li&gt;&lt;strong&gt;数据：&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div class="code-snippet code-snippet__mini"&gt;&lt;div class="lang-toolbar__mini"&gt; &lt;span class="code-clipboard"&gt;&lt;button&gt;&lt;img alt="将代码复制到剪贴板" class="code-clipboard__icon" height="13" src="https://grafana.com/media/images/icons/icon-copy-small-2.svg" width="14" /&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="code-snippet code-snippet__border"&gt;&lt;pre&gt;&lt;code class="language-none"&gt;{ &amp;quot;content&amp;quot;: &amp;quot;{% if alert_group.state == &amp;#39;acknowledged&amp;#39;%}:orange_circle:{% elif alert_group.state == &amp;#39;resolved&amp;#39;%}:green_circle:{% elif alert_group.state == &amp;#39;silenced&amp;#39;%}:white_circle:{% else %}:red_circle:{% endif %} **{{ alert_group.title }}**\n*{{ alert_group.state }}*\n{{ alert_payload.message }}\n*{{ integration.name }}*\n\n{% if event.type == &amp;#39;acknowledge&amp;#39; %}**Acknowledged by: {{ user.username }}**{% endif %}{% if event.type == &amp;#39;resolve&amp;#39; %}**Resolved by: {{ user.username }}**{% endif %}{% if event.type == &amp;#39;silence&amp;#39; %}**Silenced by: {{ user.username }} (until {{ event.until }})**{% endif %}\n\n[View in Grafana OnCall]({{ alert_group.permalinks.web }})&amp;quot; }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;对于更新 webhook，我们将使用 URL 路径中之前的&lt;code&gt;discord-new&lt;/code&gt;响应中的消息&lt;code&gt;id&lt;/code&gt; ：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;名称：&lt;/strong&gt;不和谐更新&lt;/li&gt;&lt;li&gt;&lt;strong&gt;启用：&lt;/strong&gt;真&lt;/li&gt;&lt;li&gt;&lt;strong&gt;触发类型：&lt;/strong&gt;警报组状态变化&lt;/li&gt;&lt;li&gt;&lt;strong&gt;HTTP 方法：&lt;/strong&gt;补丁&lt;/li&gt;&lt;li&gt;&lt;strong&gt;Webhook URL：（&lt;/strong&gt;&lt;em&gt;请改用您的 Discord 新 Webhook ID。&lt;/em&gt; ）[您的 Discord Webhook URL]/messages/{{response.WH5PXWNJ7MT9Y5.id }}&lt;/li&gt;&lt;li&gt;&lt;strong&gt;全部转发：&lt;/strong&gt;错误&lt;/li&gt;&lt;li&gt;&lt;strong&gt;数据：&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div class="code-snippet code-snippet__mini"&gt;&lt;div class="lang-toolbar__mini"&gt; &lt;span class="code-clipboard"&gt;&lt;button&gt;&lt;img alt="将代码复制到剪贴板" class="code-clipboard__icon" height="13" src="https://grafana.com/media/images/icons/icon-copy-small-2.svg" width="14" /&gt;&lt;span&gt;复制&lt;/span&gt;&lt;/button&gt;&lt;/span&gt;&lt;/div&gt;&lt;div class="code-snippet code-snippet__border"&gt;&lt;pre&gt;&lt;code class="language-none"&gt;{ &amp;quot;content&amp;quot;: &amp;quot;{% if alert_group.state == &amp;#39;acknowledged&amp;#39;%}:orange_circle:{% elif alert_group.state == &amp;#39;resolved&amp;#39;%}:green_circle:{% elif alert_group.state == &amp;#39;silenced&amp;#39;%}:white_circle:{% else %}:red_circle:{% endif %} **{{ alert_group.title }}**\n*{{ alert_group.state }}*\n{{ alert_payload.message }}\n*{{ integration.name }}*\n\n{% if event.type == &amp;#39;acknowledge&amp;#39; %}**Acknowledged by: {{ user.username }}**{% endif %}{% if event.type == &amp;#39;resolve&amp;#39; %}**Resolved by: {{ user.username }}**{% endif %}{% if event.type == &amp;#39;silence&amp;#39; %}**Silenced by: {{ user.username }} (until {{ event.until }})**{% endif %}\n\n[View in Grafana OnCall]({{ alert_group.permalinks.web }})&amp;quot; }&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;p&gt;让我们触发一个&lt;a href="https://grafana.com/docs/oncall/latest/set-up/get-started/#send-a-demo-alert"&gt;演示警报&lt;/a&gt;并查看通知的外观：&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/oncall-chatops/discord-incident-firing.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="事件触发消息" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="事件触发消息" src="https://grafana.com/media/blog/oncall-chatops/discord-incident-firing.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;然后在确认后更新：&lt;/p&gt;&lt;figure class="figure-wrapper figure-wrapper__lightbox w-100p "&gt; &lt;a class="lightbox-link" href="https://grafana.com/media/blog/oncall-chatops/discord-incident-acknowledged.png"&gt;&lt;div class="img-wrapper w-100p h-auto"&gt;&lt;img alt="事件确认消息" class="lazyload " /&gt;&lt;noscript&gt;&lt;img alt="事件确认消息" src="https://grafana.com/media/blog/oncall-chatops/discord-incident-acknowledged.png" /&gt;&lt;/noscript&gt;&lt;/div&gt;&lt;/a&gt;&lt;/figure&gt;&lt;h2 id="set-up-webhooks-programmatically"&gt;以编程方式设置 Webhooks&lt;/h2&gt;&lt;p&gt;作为奖励，我制作了几个脚本来使用 Grafana OnCall API 创建/更新 OnCall webhooks。 （我们是否提到过 API 很有用？）这些脚本使迭代&lt;a href="https://grafana.com/docs/grafana-cloud/alerting-and-irm/oncall/configure/outgoing-webhooks/#outgoing-webhook-templates"&gt;通知模板&lt;/a&gt;变得更简单，直到获得所需的输出。您应该能够使用&lt;a href="https://registry.terraform.io/providers/grafana/grafana/latest/docs/resources/oncall_outgoing_webhook" rel="noopener noreferrer" target="_blank"&gt;Terraform&lt;/a&gt;进行类似的设置。&lt;/p&gt;&lt;ul&gt;&lt;li&gt; &lt;a href="https://gist.github.com/matiasb/69e8c41e4418ed30ab672b940cf9800b" rel="noopener noreferrer" target="_blank"&gt;Mattermost 的脚本&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://gist.github.com/matiasb/957e04bbe42ddee1f7a32e4b4d5d10f0" rel="noopener noreferrer" target="_blank"&gt;不和谐的脚本&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 id="going-further"&gt;更进一步&lt;/h2&gt;&lt;p&gt;对&lt;a href="https://github.com/grafana/oncall/issues/2683" rel="noopener noreferrer" target="_blank"&gt;Microsoft Teams&lt;/a&gt;或&lt;a href="https://github.com/grafana/oncall/issues/298" rel="noopener noreferrer" target="_blank"&gt;Google Chat&lt;/a&gt;等其他 ChatOps 服务采用类似的方法可能是可行的。如果您尝试，请告诉我们！&lt;/p&gt;&lt;p&gt;另一个值得探索的增强功能是根据&lt;a href="https://grafana.com/docs/oncall/latest/manage/on-call-schedules/"&gt;OnCall 时间表&lt;/a&gt;通知用户的能力。这可以通过使用&lt;a href="https://grafana.com/docs/oncall/latest/configure/outgoing-webhooks/#escalation-step"&gt;升级步骤&lt;/a&gt;webhook 结合&lt;a href="https://grafana.com/docs/grafana-cloud/alerting-and-irm/oncall/configure/outgoing-webhooks/#users_to_notify"&gt;&lt;code&gt;users_to_notify&lt;/code&gt;&lt;/a&gt;字段中的信息来实现。&lt;/p&gt;&lt;p&gt;此外，我们正在考虑对 Mattermost 和 Discord 进行更全面的集成，我们很乐意帮助任何愿意为此&lt;a href="https://github.com/grafana/oncall/issues/96" rel="noopener noreferrer" target="_blank"&gt;做出贡献的&lt;/a&gt;人。请随时通过我们的&lt;a href="https://grafana.slack.com/archives/C02LSUUSE2G" rel="noopener noreferrer" target="_blank"&gt;Community Slack&lt;/a&gt;与我们联系。&lt;/p&gt;&lt;p&gt; &lt;em&gt;&lt;a href="https://grafana.com/products/cloud/?pg=blog&amp;amp;plcmt=body-txt"&gt;Grafana Cloud&lt;/a&gt;是开始使用指标、日志、跟踪、仪表板等的最简单方法。我们为每个用例提供慷慨的永久免费套餐和计划。&lt;a href="https://grafana.com/auth/sign-up/create-user/?pg=blog&amp;amp;plcmt=body-txt"&gt;现在免费注册&lt;/a&gt;！&lt;/em&gt;&lt;/p&gt;</description><pubDate>Mon, 20 May 2024 00:00:00 GMT</pubDate><guid isPermaLink="true">https://grafana.com/blog/2024/05/20/grafana-oncall-connect-to-discord-mattermost-and-more-with-webhooks/</guid></item></channel></rss>