<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>CNCF - 博客</title><link>https://www.cncf.io/blog/</link><description>CNCF - 博客 - RSSHub 用爱制作(https://github.com/DIYgod/RSSHub)</description><lastBuildDate>Sat, 30 Mar 2024 01:23:44 GMT</lastBuildDate><generator>rfeed v1.1.1</generator><docs>https://github.com/svpino/rfeed/blob/master/README.md</docs><item><title>从 Kyverno 策略生成 Kubernetes ValidatingAdmissionPolicies</title><link>https://www.cncf.io/blog/2024/03/29/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/</link><description>&lt;p&gt;&lt;em&gt;项目帖子最初由 Mariam Fahmy 发布在&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;Kyverno 的博客&lt;/a&gt;上&lt;/em&gt;&lt;/p&gt;&lt;p&gt;在&lt;a href="https://kyverno.io/blog/2023/11/13/using-cel-expressions-in-kyverno-policies/"&gt;上一篇博文&lt;/a&gt;中，我们讨论了在 Kyverno 策略中编写&lt;a href="https://github.com/google/cel-spec"&gt;通用表达式语言 (CEL)&lt;/a&gt;表达式以进行资源验证。 CEL 最初被引入 Kubernetes，用于 CustomResourceDefinitions 的验证规则，然后在 1.26 中被 Kubernetes ValidatingAdmissionPolicies 使用。&lt;/p&gt;&lt;p&gt; ValidatingAdmissionPolicies 提供了一种声明式的进程内替代方案来验证准入 Webhook。&lt;/p&gt;&lt;p&gt; ValidatingAdmissionPolicies 使用通用表达式语言 (CEL) 来声明策略的验证规则。验证准入策略是高度可配置的，使策略作者能够定义可以根据集群管理员的需要进行参数化和限定资源范围的策略。&lt;/p&gt;&lt;p&gt;这篇文章将向您展示如何从 Kyverno 策略生成 Kubernetes ValidatingAdmissionPolicies 及其绑定。&lt;/p&gt;&lt;h2 class="wp-block-heading" id="prerequisite"&gt;先决条件&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/#prerequisite"&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;生成 Kubernetes ValidatingAdmissionPolicies 需要以下内容：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;具有 Kubernetes 1.26 或更高版本的集群。&lt;/li&gt;&lt;li&gt;启用&lt;code&gt;ValidatingAdmissionPolicy&lt;/code&gt;&lt;a href="https://kubernetes.io/docs/reference/command-line-tools-reference/feature-gates/"&gt;功能门&lt;/a&gt;。&lt;/li&gt;&lt;li&gt;为v1.28和v1.29启用&lt;code&gt;admissionregistration.k8s.io/v1beta1&lt;/code&gt; API。或者 为 v1.26 和 v1.27 启用&lt;code&gt;admissionregistration.k8s.io/v1alpha1&lt;/code&gt; API。&lt;/li&gt;&lt;li&gt;在 Kyverno 准入控制器中设置&lt;code&gt;--generateValidatingAdmissionPolicy&lt;/code&gt;标志。&lt;/li&gt;&lt;li&gt;授予准入控制器服务帐户生成 ValidatingAdmissionPolicies 及其绑定所需的权限。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;在这篇文章中，我们将使用 Kubernetes 1.29 的测试版。&lt;/p&gt;&lt;h2 class="wp-block-heading" id="installation--setup"&gt;安装与设置&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/#installation--setup"&gt;&lt;/a&gt;&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;创建本地集群&lt;/li&gt;&lt;/ol&gt;&lt;pre class="wp-block-code"&gt;&lt;code class=""&gt;kind create cluster --image &amp;quot;kindest/node:v1.28.0&amp;quot; --config - &amp;lt;&amp;lt;EOF kind: Cluster apiVersion: kind.x-k8s.io/v1alpha4 featureGates: ValidatingAdmissionPolicy: true runtimeConfig: admissionregistration.k8s.io/v1beta1: true admissionregistration.k8s.io/v1alpha1: true nodes: - role: control-plane - role: worker EOF&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;巴什&lt;/p&gt;&lt;ol start="2"&gt;&lt;li&gt;添加 Kyverno Helm 存储库。&lt;/li&gt;&lt;/ol&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;helm repo add kyverno https://kyverno.github.io/kyverno/ helm repo update&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;巴什&lt;/p&gt;&lt;ol start="3"&gt;&lt;li&gt;创建一个新文件来覆盖图表中的值。&lt;/li&gt;&lt;/ol&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;cat &amp;lt;&amp;lt; EOF &amp;gt; new-values.yaml features: generateValidatingAdmissionPolicy: enabled: true admissionController: rbac: clusterRole: extraResources: - apiGroups: - admissionregistration.k8s.io resources: - validatingadmissionpolicies - validatingadmissionpolicybindings verbs: - create - update - delete - list EOF&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;巴什&lt;/p&gt;&lt;ol start="4"&gt;&lt;li&gt;部署 Kyverno&lt;/li&gt;&lt;/ol&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;helm install kyverno kyverno/kyverno -n kyverno --create-namespace --version v3.1.4 --values new-values.yaml&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;巴什&lt;/p&gt;&lt;p&gt;我们现在准备从 Kyverno 策略生成 Kubernetes ValidatingAdmissionPolicies。&lt;/p&gt;&lt;h2 class="wp-block-heading" id="generating-kubernetes-validatingadmissionpolicies"&gt;生成 Kubernetes ValidatingAdmissionPolicies &lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/#generating-kubernetes-validatingadmissionpolicies"&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;在本节中，我们将创建一个 Kyverno 策略，确保没有主机路径卷用于部署，然后我们将查看生成的 ValidatingAdmissionPolicy 及其绑定。最后，我们将创建一个违反策略的 Deployment。&lt;/p&gt;&lt;p&gt;让我们从创建 Kyverno 策略开始。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;kubectl apply -f - &amp;lt;&amp;lt;EOF apiVersion: kyverno.io/v1 kind: ClusterPolicy metadata: name: disallow-host-path spec: validationFailureAction: Enforce background: false rules: - name: host-path match: any: - resources: kinds: - Deployment validate: cel: expressions: - expression: &amp;quot;!has(object.spec.template.spec.volumes) || object.spec.template.spec.volumes.all(volume, !has(volume.hostPath))&amp;quot; message: &amp;quot;HostPath volumes are forbidden. The field spec.template.spec.volumes[*].hostPath must be unset.&amp;quot; EOF&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;巴什&lt;/p&gt;&lt;p&gt;您可以从 Kyverno 策略状态检查是否生成了 ValidatingAdmissionPolicy。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;$ kubectl get cpol disallow-host-path -o jsonpath=&amp;#39;{.status}&amp;#39; { &amp;quot;autogen&amp;quot;:{ }, &amp;quot;conditions&amp;quot;:[ { &amp;quot;lastTransitionTime&amp;quot;:&amp;quot;2023-09-12T11:42:13Z&amp;quot;, &amp;quot;message&amp;quot;:&amp;quot;Ready&amp;quot;, &amp;quot;reason&amp;quot;:&amp;quot;Succeeded&amp;quot;, &amp;quot;status&amp;quot;:&amp;quot;True&amp;quot;, &amp;quot;type&amp;quot;:&amp;quot;Ready&amp;quot; } ], &amp;quot;ready&amp;quot;:true, &amp;quot;rulecount&amp;quot;:{ &amp;quot;generate&amp;quot;:0, &amp;quot;mutate&amp;quot;:0, &amp;quot;validate&amp;quot;:1, &amp;quot;verifyimages&amp;quot;:0 }, &amp;quot;validatingadmissionpolicy&amp;quot;:{ &amp;quot;generated&amp;quot;:true, &amp;quot;message&amp;quot;:&amp;quot;&amp;quot; } }&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;巴什&lt;/p&gt;&lt;p&gt;让我们尝试获取 ValidatingAdmissionPolicy 及其绑定。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;$ kubectl get validatingadmissionpolicy NAME VALIDATIONS PARAMKIND AGE disallow-host-path 1 &amp;lt;unset&amp;gt; 8m12s $ kubectl get validatingadmissionpolicybindings NAME POLICYNAME PARAMREF AGE disallow-host-path-binding disallow-host-path &amp;lt;unset&amp;gt; 8m30s&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;巴什&lt;/p&gt;&lt;p&gt;您可能会注意到，ValidatingAdmissionPolicy 和 ValidatingAdmissionPolicyBinding 与它们源自的 Kyverno 策略共享相同的名称，并且绑定具有“-binding”后缀。&lt;/p&gt;&lt;p&gt;让我们详细了解一下 ValidatingAdmissionPolicy 及其绑定。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;$ kubectl get validatingadmissionpolicy disallow-host-path -o yaml apiVersion: admissionregistration.k8s.io/v1beta1 kind: ValidatingAdmissionPolicy metadata: creationTimestamp: &amp;quot;2023-09-12T11:42:13Z&amp;quot; generation: 1 labels: app.kubernetes.io/managed-by: kyverno name: disallow-host-path ownerReferences: - apiVersion: kyverno.io/v1 kind: ClusterPolicy name: disallow-host-path uid: e540d96b-c683-4380-a84f-13411384241a resourceVersion: &amp;quot;11294&amp;quot; uid: 9f3e0161-d010-4a6f-bd28-bf9c87151795 spec: failurePolicy: Fail matchConstraints: matchPolicy: Equivalent namespaceSelector: {} objectSelector: {} resourceRules: - apiGroups: - apps apiVersions: - v1 operations: - CREATE - UPDATE resources: - deployments scope: &amp;#39;*&amp;#39; validations: - expression: &amp;#39;!has(object.spec.template.spec.volumes) || object.spec.template.spec.volumes.all(volume, !has(volume.hostPath))&amp;#39; message: HostPath volumes are forbidden. The field spec.template.spec.volumes[*].hostPath must be unset. variables: null status: observedGeneration: 1 typeChecking: {}&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;巴什&lt;/p&gt;&lt;pre class="wp-block-code"&gt;&lt;code class=""&gt;$ kubectl get validatingadmissionpolicybindings disallow-host-path-binding -o yaml apiVersion: admissionregistration.k8s.io/v1beta1 kind: ValidatingAdmissionPolicyBinding metadata: creationTimestamp: &amp;quot;2023-09-12T11:42:13Z&amp;quot; generation: 1 labels: app.kubernetes.io/managed-by: kyverno name: disallow-host-path-binding ownerReferences: - apiVersion: kyverno.io/v1 kind: ClusterPolicy name: disallow-host-path uid: e540d96b-c683-4380-a84f-13411384241a resourceVersion: &amp;quot;11292&amp;quot; uid: 2fec35c3-8a8c-42a7-8a02-a75e8882a01e spec: policyName: disallow-host-path validationActions: - Deny&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;巴什&lt;/p&gt;&lt;p&gt;现在，让我们尝试部署一个使用 hostPath 的应用程序：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;kubectl apply -f - &amp;lt;&amp;lt;EOF apiVersion: apps/v1 kind: Deployment metadata: name: nginx spec: replicas: 2 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx-server image: nginx volumeMounts: - name: udev mountPath: /data volumes: - name: udev hostPath: path: /etc/udev EOF&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;巴什&lt;/p&gt;&lt;p&gt;正如预期的那样，部署创建被 API 服务器拒绝，而不是被 Kyverno 准入控制器拒绝。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;The deployments &amp;quot;nginx&amp;quot; is invalid: ValidatingAdmissionPolicy &amp;#39;disallow-host-path&amp;#39; with binding &amp;#39;disallow-host-path-binding&amp;#39; denied request: HostPath volumes are forbidden. The field spec.template.spec.volumes[*].hostPath must be unset.&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;巴什&lt;/p&gt;&lt;p&gt;如果 ValidatingAdmissionPolicy 或绑定由于某种原因被删除/更新，则控制器负责恢复它。&lt;/p&gt;&lt;p&gt;让我们尝试删除 ValidatingAdmissionPolicy。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;$ kubectl delete validatingadmissionpolicy disallow-host-path validatingadmissionpolicy.admissionregistration.k8s.io &amp;quot;disallow-host-path&amp;quot; deleted $ kubectl get validatingadmissionpolicy NAME VALIDATIONS PARAMKIND AGE disallow-host-path 1 &amp;lt;unset&amp;gt; 11s&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;巴什&lt;/p&gt;&lt;p&gt;此外，您可以更新Kyverno策略，控制器将相应地重新生成ValidatingAdmissionPolicy。例如，您也可以更改 Kyverno 策略以匹配有状态集。&lt;/p&gt;&lt;p&gt;补丁.yaml：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;spec: rules: - name: host-path match: any: - resources: kinds: - Deployment - StatefulSet validate: cel: expressions: - expression: &amp;quot;!has(object.spec.template.spec.volumes) || object.spec.template.spec.volumes.all(volume, !has(volume.hostPath))&amp;quot; message: &amp;quot;HostPath volumes are forbidden. The field spec.template.spec.volumes[*].hostPath must be unset.&amp;quot;&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt; YAML&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;kubectl patch cpol disallow-host-path --type merge --patch-file patch.yaml&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;巴什&lt;/p&gt;&lt;p&gt;ValidatingAdmissionPolicy 也将更新以匹配 StatefulSet。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;apiVersion: admissionregistration.k8s.io/v1beta1 kind: ValidatingAdmissionPolicy metadata: creationTimestamp: &amp;quot;2023-09-12T12:54:48Z&amp;quot; generation: 2 labels: app.kubernetes.io/managed-by: kyverno name: disallow-host-path ownerReferences: - apiVersion: kyverno.io/v1 kind: ClusterPolicy name: disallow-host-path uid: e540d96b-c683-4380-a84f-13411384241a resourceVersion: &amp;quot;29208&amp;quot; uid: 9325e2b7-9131-4ff4-9e56-244129cb625e spec: failurePolicy: Fail matchConstraints: matchPolicy: Equivalent namespaceSelector: {} objectSelector: {} resourceRules: - apiGroups: - apps apiVersions: - v1 operations: - CREATE - UPDATE resources: - deployments - statefulsets scope: &amp;#39;*&amp;#39; validations: - expression: &amp;#39;!has(object.spec.template.spec.volumes) || object.spec.template.spec.volumes.all(volume, !has(volume.hostPath))&amp;#39; message: HostPath volumes are forbidden. The field spec.template.spec.volumes[*].hostPath must be unset. variables: null status: observedGeneration: 2 typeChecking: {}&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt; YAML&lt;/p&gt;&lt;h2 class="wp-block-heading" id="conclusion"&gt;结论&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/#conclusion"&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;在本博客中，我们讨论了如何从 Kyverno 策略生成 Kubernetes ValidatingAdmissionPolicies。您可以在 Kyverno 策略中使用 CEL 表达式通过 Kyverno 引擎或 API 服务器验证资源。在下一篇博客中，我们将讨论如何为 ValidatingAdmissionPolicies 生成后台扫描报告。 &lt;/p&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;</description><pubDate>Thu, 28 Mar 2024 16:00:00 GMT</pubDate><guid isPermaLink="true">https://www.cncf.io/blog/2024/03/29/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/</guid></item><item><title>Kelsey Hightower 和 Alex Saroyan 的 2024 年云计算趋势</title><link>https://www.cncf.io/blog/2024/03/28/the-2024-trends-on-cloud-computing-by-kelsey-hightower-and-alex-saroyan/</link><description>&lt;p&gt;&lt;em&gt;会员帖子最初发布于&lt;a href="https://www.netris.io/the-2024-trends-on-cloud-computing-by-kelsey-hightower-and-alex-saroyan/"&gt;Netris 的博客&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&lt;p&gt;公共云基本上变得相同。大多数公司为&lt;strong&gt;云基础设施&lt;/strong&gt;支付的费用远远高于应有的费用。简而言之，这些陈述总结了&lt;strong&gt;&lt;a href="https://www.netris.io/recap-of-tech-trends-in-2023-and-predictions-for-2024-virtual-roundtable/"&gt;Kelsey Hightower 最近主持的 Netris 圆桌讨论&lt;/a&gt;&lt;/strong&gt;中有关云计算现状的关键要点。&lt;/p&gt;&lt;p&gt;但简洁的总结很难准确反映 Hightower 和其他与会者在活动期间分享的见解 - 因此，为了那些无法现场参加的人，我们想解开我们探索的云计算趋势以及他们对云的未来发展提出了重要观点。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;趋势一：公有云平台差异缩小&lt;/h3&gt;&lt;p&gt;在讨论初期，Hightower 发表了一个听起来很直白，但却很难反驳的声明：“截至 2024 年，大多数云提供商的核心产品看起来都是一样的。”&lt;/p&gt;&lt;p&gt;他指的是这样一个事实：所有主要的公共云平台——&lt;strong&gt;亚马逊网络服务、微软Azure和谷歌云平台&lt;/strong&gt;——现在都提供或多或少相同的核心服务集。诚然，他们实施这些服务的方式存在差异。例如， &lt;strong&gt;Amazon EC2&lt;/strong&gt;提供的特定云服务器实例配置与&lt;strong&gt;Azure 虚拟机&lt;/strong&gt;上的配置不同。但抛开细微的差异不谈，大型公共云竞争对手如今都提供几乎相同的服务。&lt;/p&gt;&lt;p&gt;活动参与者一致认为，公共云之间界限的模糊并不是一件坏事。相反，这意味着企业可以不再专注于选择适合自己需求的公有云，同时使用多个云将成为未来的常态&lt;/p&gt;&lt;p&gt;然而，Hightower 和其他人指出的一个症结是，每个公共云供应商提供的本机工具之间仍然存在重要差异。例如，成为 AWS IAM 专家并不一定意味着您有资格在 Azure 上管理 IAM，因为每个云的 IAM 框架涉及不同的概念和工具。&lt;/p&gt;&lt;p&gt;因此，对于想要跨云工作的无缝体验的团队来说，寻找简化工具集和管理流程的方法非常重要，尽管云本身现在都做几乎相同的事情。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;趋势 2：本地云和公有云的界限已经模糊&lt;/h3&gt;&lt;p&gt;Hightower 又做出了一项大胆的声明，他宣称，到 2024 年，本地环境和公共云环境之间的差异基本上不再重要。&lt;/p&gt;&lt;p&gt;他表示，如今企业应该“&lt;strong&gt;减少对云计算和本地部署的关注，而更多地关注这两个世界如何融合&lt;/strong&gt;。”&lt;/p&gt;&lt;p&gt;这是一个大胆的声明，因为在很多方面，本地云和公共云之间确实仍然存在重要差异。例如，与在云中运行的服务器相比，裸机本地服务器为您提供了更多的控制权。从基础设施管理和安全性等角度来看，每种类型的环境也有很大不同。&lt;/p&gt;&lt;p&gt;但 Hightower 并不意味着本地云和公共云实际上已经变得相同。相反，他指的是这样一个事实：现代工具（例如&lt;strong&gt;Netris&lt;/strong&gt; ，它将&lt;strong&gt;公共云网络管理的简单性带入任何环境&lt;/strong&gt;，包括本地）已经使您的工作负载实现非常相似的管理体验，无论它们运行本地或云端。&lt;/p&gt;&lt;p&gt;为了让大家明白这一点，Hightower 还指出，“我讨厌混合云这个词，因为它只会造成混乱。没有任何混合体。只有数据中心。”&lt;/p&gt;&lt;p&gt;这听起来可能有点奇怪，因为混合云（将公共云服务与私有基础设施结合在一起）和其他类型的云平台之间存在架构差异。但 Hightower 并不是说​​混合云实际上不存在。他的意思是，使用现代工具，管理混合云环境与管理本地或公共云环境实际上没有任何不同。&lt;/p&gt;&lt;p&gt;底线：组织应该少担心谁拥有托管给定工作负载的数据中心，而更多地关注确保他们能够有效管理该工作负载。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;趋势三：云成本管理的大胆想法&lt;/h3&gt;&lt;p&gt;随着越来越多的企业寻找控制云支出的方法，FinOps 意味着云成本优化的实践，多年来一直是一个热门话题。优化 AWS 成本、GCP 成本和其他云支出长期以来一直是一个优先事项。&lt;/p&gt;&lt;p&gt;通常，FinOps 建议归结为一些策略，例如选择能够在成本和性能之间实现最佳权衡的云服务器实例。但 Netris 圆桌会议上的人们就如何减少云中的负担提出了一些其他更大胆的想法。&lt;/p&gt;&lt;p&gt; Hightower 走得更远，他建议数据出口（企业为将数据移出云环境而支付的费用）应该免费。 “出口正在杀死公司，”他说，并补充说，想要吸引更多客户的云提供商应该取消出口费用。&lt;/p&gt;&lt;p&gt;我们并不是说您应该要求云提供商为您提供免费出口。他们可能会说不，因为到目前为止，出口收费仍然是标准且普遍存在的。但我们喜欢 Hightower 雄心勃勃的想法，即通过消除云客户早已接受的一些费用，使云从根本上更具成本效益。&lt;/p&gt;&lt;p&gt; Hightower 还指出，在许多情况下，具有可预测工作负载的企业最好通过将其保留在本地来获得最佳服务，这一指导意见违背了“立即将所有内容迁移到云端！”的原则。过去十年或更长时间主导 IT 行业的建议。他指出，虽然云在您不知道需要多少容量的情况下很有用，但“大多数企业确实知道他们必须支持多少客户以及他们需要什么”——因此，他们无法从云的内置可扩展性中获得太多好处。&lt;/p&gt;&lt;p&gt;我们还将提到，这也是当今使用一致工具管理任何环境的能力如此重要的另一个原因。当您的工具集和管理流程在所有环境中都相同时，您可以将工作负载放置在最有意义的地方，而无需为您支持的每个环境投资不同的管理策略。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;趋势4：VPC正在成为常态&lt;/h3&gt;&lt;p&gt;尽管所有讨论都涉及云平台和架构之间的模糊界限，但圆桌会议与会者确实同意，在云环境中仍然存在一种非常重要的独特环境类型：虚拟私有云或 VPC。&lt;/p&gt;&lt;p&gt; &lt;strong&gt;VPC 是云中的一种网络结构&lt;/strong&gt;，可创建隔离的环境，换句话说，就是虚拟私有云。每个云用户可以创建至少一个VPC。&lt;/p&gt;&lt;p&gt;除了隔离之外，VPC 还包括设计和管理网络所需的基本结构（例如 DHCP、IP 子网、路由、NAT、负载均衡器、访问组和网络访问控制）。因此，当工程师谈论 VPC 时，他们通常不仅指隔离技术，还指 VPC 提供的一套基本网络构造。&lt;/p&gt;&lt;p&gt; VPC 已在主要公共云平台上存在多年，但 Hightower 认为现在是本地、边缘和裸机环境也利用 VPC 的时候了。 “&lt;strong&gt;让世界规范 VPC 的概念非常重要，&lt;/strong&gt;这样我们就可以对网络进行抽象 - 类似于容器对计算的作用，”他说。换句话说，Hightower 认为更多的企业应该利用 VPC 来简化和标准化其公共云和私有云工作负载的网络。&lt;/p&gt;&lt;p&gt; Netris 首席执行官兼联合创始人 Alex Saroyan 补充说，借助 Netris 等工具，管理 VPC 网络变得比以往更加容易。 “我们为他们提供了与云非常相似的 API 和用户体验，而在后端我们会自动处理详细的网络配置，”他解释道。&lt;/p&gt;&lt;p&gt; Hightower 表示同意，并指出 Netris 等工具可用于将公共云中的 VPC 网络与私有云和其他环境中的 VPC 网络统一起来。 &lt;strong&gt;Netris 自动处理大部分复杂的网络工程&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;简而言之，我们期望看到越来越多的组织采用 VPC 作为其私有和公共云战略的一部分。我们还希望他们能够利用 Netris 等工具在其环境的各个方面提供一致的网络管理体验。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;结论：重新思考云战略&lt;/h3&gt;&lt;p&gt;底线是：多年来一直处于云计算中心的许多争论感觉越来越无关紧要。如今，企业需要回答的最重要问题不再是选择哪个公共云平台或将哪些工作负载保留在本地。现代云工具和网络抽象使各种环境更加相似，这意味着将工作负载从一个环境转移到另一个环境已更多地成为业务驱动的决策，而不再是工程麻烦。&lt;/p&gt;&lt;p&gt;因此， &lt;strong&gt;2024 年云战略的首要任务是确保企业能够有效管理其工作负载，无论其托管在何处&lt;/strong&gt;。团队不应再担心他们在云架构或环境上贴上哪些标签，而应该更多地担心他们是否尽可能高效、可靠地管理云的所有组件。 &lt;/p&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;</description><pubDate>Wed, 27 Mar 2024 16:00:00 GMT</pubDate><guid isPermaLink="true">https://www.cncf.io/blog/2024/03/28/the-2024-trends-on-cloud-computing-by-kelsey-hightower-and-alex-saroyan/</guid></item><item><title>错过了 KubeCon + CloudNativeCon Europe 2024？这是您需要了解的一切</title><link>https://www.cncf.io/blog/2024/03/28/missed-kubecon-cloudnativecon-europe-2024-heres-everything-you-need-to-know/</link><description>&lt;p&gt;超过 12,000 人参加了我们在巴黎举行的&lt;a href="https://events.linuxfoundation.org/kubecon-cloudnativecon-europe/"&gt;KubeCon + CloudNativeCon Europe 2024&lt;/a&gt; ，虽然我们讨论了从人工智能到可持续计算的所有内容，但最大的收获是社区令人难以置信的力量。该社区推动了 Kubernetes 和云原生运动的发生，而该社区现在正在推动人工智能、平台工程甚至“绿色”计算计划的采用。&lt;/p&gt;&lt;p&gt;请继续阅读每日精彩内容（如果您想观看演示，可以在我们的&lt;a href="https://www.youtube.com/@cncf/videos"&gt;YouTube 频道&lt;/a&gt;上观看视频。）&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;同期举办活动&lt;/h2&gt;&lt;p&gt;KubeCon + CloudNativeCon Europe 2024 的同期活动始终是非常受欢迎的演示，可以深入探讨特定项目、技术或流程。今年，同一地点举行的活动继续吸引了众多参加者，对于那些新参加会议的人来说，这是与同行会面和建立联系的快速而简单的方式。&lt;a href="https://www.youtube.com/@cncf/playlists"&gt;所有同地举办的活动&lt;/a&gt;均可在 YouTube 上观看（此链接将带您前往每个同地举办的活动的播放列表……点击“查看完整播放列表”即可享受！）。或者， &lt;a href="https://www.cncf.io/blog/2024/03/19/kubecon-cloudnativecon-europe-2024-day-one-co-located-events-and-announcements-recap/"&gt;快速浏览一下&lt;/a&gt;欧洲云原生人工智能日、欧洲平台工程日、欧洲 AppDeveloperCon、云原生创业节等等。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;第一天：云原生如何推动人工智能运动&lt;/h2&gt;&lt;p&gt;毫不奇怪，在 KubeCon + CloudNativeCon Europe 2024 的第一天，人工智能“无处不在”。从人工智能中心的主题演讲到无数的操作演示，以及如何利用云原生充分利用人工智能的讨论– 反之亦然 – 速度又快又激烈，更不用说非常令人兴奋了。深入了解&lt;a href="https://www.youtube.com/@cncf/search?query=AI"&gt;YouTube 上的所有 AI 内容&lt;/a&gt;或&lt;a href="https://www.cncf.io/blog/2024/03/20/kubecon-cloudnativecon-europe-2024-day-two-how-cloud-native-is-powering-the-ai-movement-and-other-news/"&gt;探索精选的精彩内容&lt;/a&gt;。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;第二天：可持续计算的力量&lt;/h2&gt;&lt;p&gt;云原生能够并且将会帮助改善我们的环境足迹，这就是 KubeCon + CloudNativeCon Europe 2024 当天的主题。从负责任的创新到绿色 IT 和云原生架构的革命，全天的主题演讲和其他演讲都讨论了这一重要主题。&lt;a href="https://www.youtube.com/@cncf/search?query=sustainability%202024"&gt;通过视频探索我们所有的可持续发展演示&lt;/a&gt;，或深入&lt;a href="https://www.cncf.io/blog/2024/03/21/kubecon-cloudnativecon-europe-2024-day-three-the-power-of-sustainable-computing/"&gt;阅读当天的内容&lt;/a&gt;。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;第三天：Kubernetes 和云原生的过去与未来&lt;/h2&gt;&lt;p&gt;要结束一场令人难以置信的会议，还有什么比回顾云原生和 Kubernetes 已经取得的进展并展望即将发生的事情更好的方式呢？我们取得了如此多的进展，我们将努力实现更多目标——从日益增长的多样性和包容性到应用程序开发的未来——所有演讲者都发人深省，也令人放心。查看&lt;a href="https://www.youtube.com/@cncf/search?query=cloud%20native%20future%202024"&gt;面向未来的视频演示&lt;/a&gt;，或阅读&lt;a href="https://www.cncf.io/blog/2024/03/22/kubecon-cloudnativecon-europe-2024-day-four-how-cloud-native-is-powering-the-ai-movement-and-other-news/"&gt;当天的亮点&lt;/a&gt;。 &lt;/p&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;</description><pubDate>Wed, 27 Mar 2024 16:00:00 GMT</pubDate><guid isPermaLink="true">https://www.cncf.io/blog/2024/03/28/missed-kubecon-cloudnativecon-europe-2024-heres-everything-you-need-to-know/</guid></item><item><title>Kubernetes 上的 WebAssembly：实践指南（第 02 部分）</title><link>https://www.cncf.io/blog/2024/03/28/webassembly-on-kubernetes-the-practice-guide-part-02/</link><description>&lt;p&gt;&lt;em&gt;&lt;a href="https://github.com/cr7258"&gt;七成&lt;/a&gt;的社区帖子&lt;/em&gt;| &lt;a href="https://www.cncf.io/blog/2024/03/12/webassembly-on-kubernetes-from-containers-to-wasm-part-01/"&gt;在这里查看第一部分&lt;/a&gt;&lt;/p&gt;&lt;p&gt;在上一篇文章中，我概述了 Wasm 的特性和优势。我还解释了如何在容器环境中运行 Wasm 模块。在本文中，我将指导您在云原生生态系统中构建和部署 Wasm 应用程序。你需要：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;登录 Docker Hub（您还可以调整演练以使用不同的容器映像注册表。&lt;/li&gt;&lt;li&gt; Rust 开发环境（本文告诉您如何查找安装说明）。&lt;/li&gt;&lt;li&gt;运行 Debian、Ubuntu 或基于 Debian 的类似 Linux 发行版的 PC。&lt;br /&gt; PC 应具有 AMD64 或兼容的 CPU。&lt;br /&gt;同样，如果您使用不同风格的 Linux 或不同类型的 CPU，您可以调整建议。如果您使用不同的操作系统（不是 Linux），请在虚拟机内设置本地 Linux 环境。&lt;/li&gt;&lt;/ul&gt;&lt;h2 class="wp-block-heading"&gt;使用 Rust 和 WebAssembly 编写示例应用程序&lt;/h2&gt;&lt;p&gt;应用程序是否可以编译为 Wasm 在很大程度上取决于所使用的编程语言。 Rust、C、C++等语言对 Wasm 提供了很好的支持，Go 从 1.21 版本开始对 WASI 提供了初步支持。在此之前，需要使用tinygo等第三方工具进行编译。由于 Rust 对 Wasm 的一流支持，我在本文中使用 Rust 来开发 Wasm 应用程序。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;安装 Rust&lt;/h3&gt;&lt;p&gt;请参考&lt;a href="https://www.rust-lang.org/tools/install"&gt;Rust 安装说明&lt;/a&gt;来安装 Rust。&lt;br /&gt;确保安装 Cargo（Rust 的包管理器）以及 Rust 本身。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;为 Rust 添加 wasm32-wasi 目标&lt;/h3&gt;&lt;p&gt;前面提到，WASI 是 WebAssembly 的系统级接口，旨在促进各种环境下 WebAssembly 与主机系统之间的交互。它提供了一种标准化方法，使 WebAssembly 能够访问文件 I/O、网络和系统调用等系统级功能。&lt;/p&gt;&lt;p&gt; Rustc 是一个跨平台编译器，具有许多编译目标，包括&lt;em&gt;wasm32-wasi&lt;/em&gt; 。该目标将 Rust 代码编译成遵循 WASI 标准的 Wasm 模块。将 Rust 代码编译到 wasm32-wasi 目标可以将 Rust 的功能和安全性集成到 WebAssembly 环境中，同时利用 wasm32-wasi 提供的标准化系统接口与主机系统进行交互。&lt;/p&gt;&lt;p&gt;将 wasm32-wasi 目标添加到 Rust 编译器。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;rustup target add wasm32-wasi&lt;/code&gt;&lt;/pre&gt;&lt;h3 class="wp-block-heading"&gt;编写 Rust 程序&lt;/h3&gt;&lt;p&gt;使用 Cargo new 命令创建一个名为 http-server 的新 Rust 项目：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;cargo new http-server&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;编辑 Cargo.toml 文件以添加下面列出的依赖项。 &lt;a href="https://crates.io/crates/warp_wasi"&gt;&lt;em&gt;warp_wasi&lt;/em&gt;&lt;/a&gt;是专门为 WASI 设计的，构建在&lt;a href="https://docs.rs/warp/latest/warp/"&gt;&lt;em&gt;Warp&lt;/em&gt;&lt;/a&gt;框架之上，Warp 框架是一个轻量级 Web 服务器框架，用于开发高性能异步 Web 应用程序。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;[dependencies]&lt;br /&gt; tokio_wasi = { version = &amp;quot;1&amp;quot;, features = [&amp;quot;rt&amp;quot;, &amp;quot;macros&amp;quot;, &amp;quot;net&amp;quot;, &amp;quot;time&amp;quot;, &amp;quot;io-util&amp;quot;]}&lt;br /&gt; warp_wasi = &amp;quot;0.3&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建一个简单的 HTTP 服务器，在端口 8080 上公开服务并返回“Hello, World!”当收到请求时。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;use warp::Filter;&lt;br /&gt;&lt;br /&gt; #[tokio::main(flavor = &amp;quot;current_thread&amp;quot;)]&lt;br /&gt; async fn main() {&lt;br /&gt;    let hello = warp::get()&lt;br /&gt;        .and(warp::path::end())&lt;br /&gt;        .map(|| &amp;quot;Hello, World!&amp;quot;);&lt;br /&gt;&lt;br /&gt;    println!(&amp;quot;Listening on http://0.0.0.0:8080&amp;quot;);&lt;br /&gt;    warp::serve(hello).run(([0, 0, 0, 0], 8080)).await;&lt;br /&gt; }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将该文件作为 main.rs 保存到您的 PC 上。&lt;br /&gt;将程序编译成Wasm模块，会写入项目的target/wasm32-wasi/release目录下。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;cargo build --target wasm32-wasi --release&lt;/code&gt;&lt;/pre&gt;&lt;h3 class="wp-block-heading"&gt;安装 WasmEdge&lt;/h3&gt;&lt;p&gt;编译后的 Wasm 模块需要适当的 Wasm 运行时才能执行。流行的选择包括 WasmEdge、Wasmtime 和 Wasmer 等。&lt;/p&gt;&lt;p&gt;在本文中，我使用&lt;a href="https://wasmedge.org/docs/"&gt;&lt;em&gt;WasmEdge&lt;/em&gt;&lt;/a&gt; ，这是一个轻量级、高性能且可扩展的 WebAssembly 运行时。&lt;/p&gt;&lt;p&gt;通过运行以下命令安装 WasmEdge：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;# Running scripts directly via curl | bash has security implications.&lt;br /&gt; # Carefully examine the script content and only execute if you completely understand and trust the source.&lt;br /&gt; curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使已安装的二进制文件在当前会话中可用：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;source $HOME/.wasmedge/env&lt;/code&gt;&lt;/pre&gt;&lt;h3 class="wp-block-heading"&gt;运行 Wasm 模块&lt;/h3&gt;&lt;p&gt;您可以使用 wasmedge 命令来运行 Wasm 模块：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;wasmedge target/wasm32-wasi/release/http-server.wasm&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;向本地运行的服务发送请求：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;curl http://localhost:8080&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出是：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;Hello, World!&lt;/code&gt;&lt;/pre&gt;&lt;h2 class="wp-block-heading"&gt;在 Linux 容器中运行 Wasm 模块&lt;/h2&gt;&lt;p&gt;在当前容器生态系统中无缝运行 Wasm 模块的最简单方法是将 Wasm 模块嵌入到 Linux 容器镜像中。接下来，我将演示如何实现这一点。&lt;/p&gt;&lt;p&gt;使用编译的 Wasm 模块构建 Linux 容器映像。我将解释如何使用 Docker 来实现这一点，这是制作容器映像的一种非常常见的方法。在 http-server 项目的根目录中创建一个名为 Dockerfile-wasmedge-slim 的&lt;em&gt;Dockerfile&lt;/em&gt; 。在 Dockerfile 中，将 Wasm 模块包含在安装了 wasmedge 的 slim Linux 映像中，并使用 wasmedge 命令执行 Wasm 模块。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;FROM wasmedge/slim-runtime:0.10.1&lt;br /&gt; COPY target/wasm32-wasi/release/http-server.wasm /&lt;br /&gt; CMD [&amp;quot;wasmedge&amp;quot;, &amp;quot;--dir&amp;quot;, &amp;quot;.:/&amp;quot;, &amp;quot;/http-server.wasm&amp;quot;]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;构建容器镜像：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;# replace cr7258 with your own Docker Hub repository name&lt;br /&gt; docker build -f Dockerfile-wasmedge-slim -t cr7258/wasm-demo-app:slim .&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了在本地测试代码，我将使用 Docker 运行容器：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;docker run -itd -p 8080:8080 \&lt;br /&gt; --name wasm-demo-app \&lt;br /&gt; docker.io/cr7258/wasm-demo-app:slim&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;向本地测试容器中运行的服务发送请求：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;curl http://localhost:8080&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出是：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;Hello, World!&lt;/code&gt;&lt;/pre&gt;&lt;h2 class="wp-block-heading"&gt;在支持 Wasm 的容器运行时中运行 Wasm 模块&lt;/h2&gt;&lt;p&gt;在上一节中，我展示了如何将 Wasm 模块嵌入到 Linux 容器中来运行 Wasm 模块。接下来，我将从低级和高级容器运行时的角度演示如何使用支持 Wasm 的容器运行时直接运行 Wasm 模块。这种方法提供了更好的安全性和性能。&lt;/p&gt;&lt;p&gt;在运行 Wasm 模块之前，请将其构建到没有 Linux 操作系统的映像中。 &lt;em&gt;scrap&lt;/em&gt;是 Docker 中保留的最小基础镜像。 Dockerfile 看起来像这样：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;FROM scratch&lt;br /&gt; COPY target/wasm32-wasi/release/http-server.wasm /&lt;br /&gt; CMD [&amp;quot;/http-server.wasm&amp;quot;]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;构建容器镜像。这次创建的镜像大约只有之前构建的 wasm-demo-app:slim 镜像大小的 1/4。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;# replace cr7258 with your own Docker Hub repository name&lt;br /&gt; docker build -t docker.io/cr7258/wasm-demo-app:v1 .&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了方便后面的demo使用，请将镜像推送到Docker Hub。将存储库替换为您自己的存储库。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;# replace cr7258 with your own Docker Hub repository name&lt;br /&gt; docker push docker.io/cr7258/wasm-demo-app:v1&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下来，我将单独演示如何通过低级和高级容器运行时运行 Wasm 模块。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;通过低级容器运行时运行 Wasm 模块&lt;/h3&gt;&lt;p&gt;&lt;a href="https://github.com/containers/crun"&gt;&lt;em&gt;Crun&lt;/em&gt;&lt;/a&gt;是一个用 C 语言编写的快速且轻量级的 OCI 容器运行时，它内置了对 WasmEdge 的支持。在本节中，我将演示如何利用 crun 使用提供的 config.json 和 rootfs 文件直接启动 Wasm 模块，而不依赖于高级容器运行时。&lt;/p&gt;&lt;p&gt; 💡 确保您已按照“安装 WasmEdge”部分中的说明&lt;a href="https://docs.google.com/document/d/1eM-iK_0s-Z7daLe1w_8TKujj5cxHl4S6/edit#bookmark=id.gjdgxs"&gt;安装了 WasmEdge&lt;/a&gt; 。&lt;/p&gt;&lt;p&gt;安装编译所需的依赖项。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;apt update&lt;br /&gt; apt install -y make git gcc build-essential pkgconf libtool \&lt;br /&gt;    libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev \&lt;br /&gt;    go-md2man libtool autoconf python3 automake&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;配置、构建和安装包含 WasmEdge 支持的 crun 二进制文件：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;git clone https://github.com/containers/crun&lt;br /&gt; cd crun&lt;br /&gt; ./autogen.sh&lt;br /&gt; ./configure --with-wasmedge&lt;br /&gt; make&lt;br /&gt; make install&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行crun -v 检查安装是否成功。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;crun -v&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看到+WASM:wasmedge表示crun中已经安装了WasmEdge。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;crun version 1.8.5.0.0.0.23-3856&lt;br /&gt; commit: 385654125154075544e83a6227557bfa5b1f8cc5&lt;br /&gt; rundir: /run/crun&lt;br /&gt; spec: 1.0.0&lt;br /&gt; +SYSTEMD +SELINUX +APPARMOR +CAP +SECCOMP +EBPF +WASM:wasmedge +YAJL&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建一个目录，用于存储运行容器所需的文件和目录（config.json和rootfs），&lt;br /&gt;然后复制到根文件系统：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;mkdir test-crun&lt;br /&gt; cd test-crun&lt;br /&gt; mkdir rootfs&lt;br /&gt; # Copy the compiled Wasm module to the rootfs directory, replace it with the appropriate directory path for your system.&lt;br /&gt; cp ~/hands-on-lab/wasm/runtime/http-server/target/wasm32-wasi/release/http-server.wasm rootfs&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行 crun spec 命令生成默认的 config.json 配置文件，然后进行以下修改：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;将 args 字段中的 sh 替换为 /http-server.wasm。&lt;/li&gt;&lt;li&gt;在注释字段中添加“module.wasm.image/variant”:“compat”以表明这是一个没有客户操作系统的 Wasm 应用程序。&lt;/li&gt;&lt;li&gt;在网络命名空间中添加“path”：“/proc/1/ns/net”，以允许程序与宿主机共享网络命名空间。这将使我们能够在本地访问容器。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;修改后的配置文件应如下所示：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;{ &amp;quot;ociVersion&amp;quot;: &amp;quot;1.0.0&amp;quot;, &amp;quot;process&amp;quot;: { &amp;quot;terminal&amp;quot;: true, &amp;quot;user&amp;quot;: { &amp;quot;uid&amp;quot;: 0, &amp;quot;gid&amp;quot;: 0 }, &amp;quot;args&amp;quot;: [ &amp;quot;/http-server.wasm&amp;quot; ], &amp;quot;env&amp;quot;: [ &amp;quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&amp;quot;, &amp;quot;TERM=xterm&amp;quot; ], &amp;quot;cwd&amp;quot;: &amp;quot;/&amp;quot;, &amp;quot;capabilities&amp;quot;: { &amp;quot;bounding&amp;quot;: [ &amp;quot;CAP_AUDIT_WRITE&amp;quot;, &amp;quot;CAP_KILL&amp;quot;, &amp;quot;CAP_NET_BIND_SERVICE&amp;quot; ], &amp;quot;effective&amp;quot;: [ &amp;quot;CAP_AUDIT_WRITE&amp;quot;, &amp;quot;CAP_KILL&amp;quot;, &amp;quot;CAP_NET_BIND_SERVICE&amp;quot; ], &amp;quot;inheritable&amp;quot;: [ ], &amp;quot;permitted&amp;quot;: [ &amp;quot;CAP_AUDIT_WRITE&amp;quot;, &amp;quot;CAP_KILL&amp;quot;, &amp;quot;CAP_NET_BIND_SERVICE&amp;quot; ], &amp;quot;ambient&amp;quot;: [ &amp;quot;CAP_AUDIT_WRITE&amp;quot;, &amp;quot;CAP_KILL&amp;quot;, &amp;quot;CAP_NET_BIND_SERVICE&amp;quot; ] }, &amp;quot;rlimits&amp;quot;: [ { &amp;quot;type&amp;quot;: &amp;quot;RLIMIT_NOFILE&amp;quot;, &amp;quot;hard&amp;quot;: 1024, &amp;quot;soft&amp;quot;: 1024 } ], &amp;quot;noNewPrivileges&amp;quot;: true }, &amp;quot;root&amp;quot;: { &amp;quot;path&amp;quot;: &amp;quot;rootfs&amp;quot;, &amp;quot;readonly&amp;quot;: true }, &amp;quot;hostname&amp;quot;: &amp;quot;crun&amp;quot;, &amp;quot;mounts&amp;quot;: [ { &amp;quot;destination&amp;quot;: &amp;quot;/proc&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;proc&amp;quot;, &amp;quot;source&amp;quot;: &amp;quot;proc&amp;quot; }, { &amp;quot;destination&amp;quot;: &amp;quot;/dev&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;tmpfs&amp;quot;, &amp;quot;source&amp;quot;: &amp;quot;tmpfs&amp;quot;, &amp;quot;options&amp;quot;: [ &amp;quot;nosuid&amp;quot;, &amp;quot;strictatime&amp;quot;, &amp;quot;mode=755&amp;quot;, &amp;quot;size=65536k&amp;quot; ] }, { &amp;quot;destination&amp;quot;: &amp;quot;/dev/pts&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;devpts&amp;quot;, &amp;quot;source&amp;quot;: &amp;quot;devpts&amp;quot;, &amp;quot;options&amp;quot;: [ &amp;quot;nosuid&amp;quot;, &amp;quot;noexec&amp;quot;, &amp;quot;newinstance&amp;quot;, &amp;quot;ptmxmode=0666&amp;quot;, &amp;quot;mode=0620&amp;quot;, &amp;quot;gid=5&amp;quot; ] }, { &amp;quot;destination&amp;quot;: &amp;quot;/dev/shm&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;tmpfs&amp;quot;, &amp;quot;source&amp;quot;: &amp;quot;shm&amp;quot;, &amp;quot;options&amp;quot;: [ &amp;quot;nosuid&amp;quot;, &amp;quot;noexec&amp;quot;, &amp;quot;nodev&amp;quot;, &amp;quot;mode=1777&amp;quot;, &amp;quot;size=65536k&amp;quot; ] }, { &amp;quot;destination&amp;quot;: &amp;quot;/dev/mqueue&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;mqueue&amp;quot;, &amp;quot;source&amp;quot;: &amp;quot;mqueue&amp;quot;, &amp;quot;options&amp;quot;: [ &amp;quot;nosuid&amp;quot;, &amp;quot;noexec&amp;quot;, &amp;quot;nodev&amp;quot; ] }, { &amp;quot;destination&amp;quot;: &amp;quot;/sys&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;sysfs&amp;quot;, &amp;quot;source&amp;quot;: &amp;quot;sysfs&amp;quot;, &amp;quot;options&amp;quot;: [ &amp;quot;nosuid&amp;quot;, &amp;quot;noexec&amp;quot;, &amp;quot;nodev&amp;quot;, &amp;quot;ro&amp;quot; ] }, { &amp;quot;destination&amp;quot;: &amp;quot;/sys/fs/cgroup&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;cgroup&amp;quot;, &amp;quot;source&amp;quot;: &amp;quot;cgroup&amp;quot;, &amp;quot;options&amp;quot;: [ &amp;quot;nosuid&amp;quot;, &amp;quot;noexec&amp;quot;, &amp;quot;nodev&amp;quot;, &amp;quot;relatime&amp;quot;, &amp;quot;ro&amp;quot; ] } ], &amp;quot;annotations&amp;quot;: { &amp;quot;module.wasm.image/variant&amp;quot;: &amp;quot;compat&amp;quot; }, &amp;quot;linux&amp;quot;: { &amp;quot;resources&amp;quot;: { &amp;quot;devices&amp;quot;: [ { &amp;quot;allow&amp;quot;: false, &amp;quot;access&amp;quot;: &amp;quot;rwm&amp;quot; } ] }, &amp;quot;namespaces&amp;quot;: [ { &amp;quot;type&amp;quot;: &amp;quot;pid&amp;quot; }, { &amp;quot;type&amp;quot;: &amp;quot;network&amp;quot;, &amp;quot;path&amp;quot;: &amp;quot;/proc/1/ns/net&amp;quot; }, { &amp;quot;type&amp;quot;: &amp;quot;ipc&amp;quot; }, { &amp;quot;type&amp;quot;: &amp;quot;uts&amp;quot; }, { &amp;quot;type&amp;quot;: &amp;quot;cgroup&amp;quot; }, { &amp;quot;type&amp;quot;: &amp;quot;mount&amp;quot; } ], &amp;quot;maskedPaths&amp;quot;: [ &amp;quot;/proc/acpi&amp;quot;, &amp;quot;/proc/asound&amp;quot;, &amp;quot;/proc/kcore&amp;quot;, &amp;quot;/proc/keys&amp;quot;, &amp;quot;/proc/latency_stats&amp;quot;, &amp;quot;/proc/timer_list&amp;quot;, &amp;quot;/proc/timer_stats&amp;quot;, &amp;quot;/proc/sched_debug&amp;quot;, &amp;quot;/sys/firmware&amp;quot;, &amp;quot;/proc/scsi&amp;quot; ], &amp;quot;readonlyPaths&amp;quot;: [ &amp;quot;/proc/bus&amp;quot;, &amp;quot;/proc/fs&amp;quot;, &amp;quot;/proc/irq&amp;quot;, &amp;quot;/proc/sys&amp;quot;, &amp;quot;/proc/sysrq-trigger&amp;quot; ] } }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用 crun 启动容器：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;crun run wasm-demo-app&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;向该容器中的演示服务发送请求：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;curl http://localhost:8080&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出是：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;Hello, World!&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要删除容器，可以执行以下命令：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;crun kill wasm-demo-app SIGKILL&lt;/code&gt;&lt;/pre&gt;&lt;h3 class="wp-block-heading"&gt;通过高级容器运行时运行 Wasm 模块&lt;/h3&gt;&lt;p&gt;&lt;em&gt;容器填充程序&lt;/em&gt;充当高级和低级容器运行时之间的桥梁。其主要目的是抽象低层运行时细节，实现高层运行时对各种低层运行时的统一管理。在本节中，我将使用&lt;a href="https://github.com/containerd/containerd"&gt;&lt;em&gt;containerd&lt;/em&gt;&lt;/a&gt;作为示例。 Containerd 是一个行业标准的容器运行时，强调简单性、稳健性和可移植性。&lt;/p&gt;&lt;p&gt; Containerd 可以通过两种方式管理 Wasm 模块：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;通过 crun 和 youki 等支持使用 Wasm 运行时库构建的容器运行时来管理 Wasm 模块。这两个运行时也可以运行常规 Linux 容器。 Containerd 使用containerd-shim-runc-v2 与低级容器运行时交互。&lt;/li&gt;&lt;li&gt;直接通过 Wasm 运行时管理 Wasm 模块，例如 Slight、Spin、WasmEdge 和 Wasmtime。 Containerd 使用 containerd-wasm-shim(runwasi) 与 Wasm 运行时交互。&lt;/li&gt;&lt;/ol&gt;&lt;h4 class="wp-block-heading"&gt;容器+Crun&lt;/h4&gt;&lt;p&gt;在本节中，我将演示如何将 crun 配置为 containerd 中的运行时，从而支持运行 Wasm 模块。&lt;/p&gt;&lt;p&gt; 💡 确保已按照以下部分中的说明安装了支持 Wasm 的 crun 二进制文件： &lt;a href="https://docs.google.com/document/d/1eM-iK_0s-Z7daLe1w_8TKujj5cxHl4S6/edit#bookmark=id.30j0zll"&gt;通过低级容器运行时运行 Wasm 模块&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;运行以下命令安装containerd：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;export VERSION=&amp;quot;1.7.3&amp;quot;&lt;br /&gt; sudo apt install -y libseccomp2&lt;br /&gt; sudo apt install -y wget&lt;br /&gt;&lt;br /&gt; wget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz&lt;br /&gt; wget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum&lt;br /&gt; # expected checksum: ea70faeb6c5d656fa0787dfc7d88a48daf961482c46bb22953cb5396289fd5b8&lt;br /&gt; sha256sum --check cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum&lt;br /&gt;&lt;br /&gt; sudo tar --no-overwrite-dir -C / -xzf cri-containerd-cni-${VERSION}-linux-amd64.tar.gz&lt;br /&gt; sudo systemctl daemon-reload&lt;br /&gt; sudo systemctl enable containerd --now&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;您可以通过containerd运行Wasm模块：&lt;/p&gt;&lt;ul&gt;&lt;li&gt; –runc-binary：指定使用crun作为低级运行时来启动容器。&lt;/li&gt;&lt;li&gt; –runtime：指定shim的版本和名称，由containerd转换为shim的二进制名称。例如：io.containerd.runc.v2→containerd-shim-runc-v2。 Containerd 通过运行 containerd-shim-runc-v2 二进制文件来启动 shim，该文件随后调用 crun 来启动容器。&lt;/li&gt;&lt;li&gt; –label：添加“module.wasm.image/variant”：“compat”以指示这是一个没有客户操作系统的 Wasm 应用程序。&lt;/li&gt;&lt;/ul&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;# Pull the image&lt;br /&gt; ctr i pull docker.io/cr7258/wasm-demo-app:v1&lt;br /&gt;&lt;br /&gt; # Run the container&lt;br /&gt; ctr run --rm --net-host \&lt;br /&gt; --runc-binary crun \&lt;br /&gt; --runtime io.containerd.runc.v2 \&lt;br /&gt; --label module.wasm.image/variant=compat \&lt;br /&gt; docker.io/cr7258/wasm-demo-app:v1 \&lt;br /&gt; wasm-demo-app&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;向该容器中的演示服务发送请求：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;curl http://localhost:8080&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出是：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;Hello, World!&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要删除容器，可以执行以下命令。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;ctr task kill wasm-demo-app --signal SIGKILL&lt;/code&gt;&lt;/pre&gt;&lt;h4 class="wp-block-heading"&gt; Containerd + Runwasi&lt;/h4&gt;&lt;p&gt; &lt;a href="https://github.com/containerd/runwasi"&gt;&lt;em&gt;Runwasi&lt;/em&gt;&lt;/a&gt;是一个用Rust编写的库，是containerd的子项目。使用runwasi，您可以编写一个containerd wasm shim来与Wasm运行时集成，这有助于直接运行由containerd管理的Wasm模块。有几种使用 runwasi 开发的 Containerd wasm shim，包括：&lt;/p&gt;&lt;ul&gt;&lt;li&gt; WasmEdge、Wasmtime 和 Wasmer，您可以在&lt;a href="https://github.com/containerd/runwasi/tree/main/crates"&gt;runwasi&lt;/a&gt;存储库中找到它们。&lt;/li&gt;&lt;li&gt; Spin、Slight、Wasm Workers Server 和 Lunatic，您可以在&lt;a href="https://github.com/deislabs/containerd-wasm-shims"&gt;containerd-wasm-shims&lt;/a&gt;存储库中找到它们。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在本文中，我使用 WasmEdge containerd shim 来运行 Wasm 模块。&lt;/p&gt;&lt;p&gt;克隆 runwasi 存储库。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;git clone https://github.com/containerd/runwasi.git&lt;br /&gt; cd runwasi&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装编译所需的依赖项。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;sudo apt-get -y install    \&lt;br /&gt;      pkg-config          \&lt;br /&gt;      libsystemd-dev      \&lt;br /&gt;      libdbus-glib-1-dev  \&lt;br /&gt;      build-essential     \&lt;br /&gt;      libelf-dev          \&lt;br /&gt;      libseccomp-dev      \&lt;br /&gt;      libclang-dev        \&lt;br /&gt;      libssl-dev&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;构建并安装垫片。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;make build&lt;br /&gt; sudo make install&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;指定 –runtime=io.containerd.wasmedge.v1 通过 WasmEdge shim 运行 Wasm 模块。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;ctr run --rm --net-host \&lt;br /&gt; --runtime=io.containerd.wasmedge.v1 \&lt;br /&gt; docker.io/cr7258/wasm-demo-app:v1 \&lt;br /&gt; wasm-demo-app&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;向该容器中的演示服务发送请求：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;curl http://localhost:8080&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出是：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;Hello, World!&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要删除容器，可以执行以下命令。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;ctr task kill wasm-demo-app --signal SIGKILL&lt;/code&gt;&lt;/pre&gt;&lt;h2 class="wp-block-heading"&gt;在容器管理平台上运行 Wasm 模块&lt;/h2&gt;&lt;h3 class="wp-block-heading"&gt;在 Docker Desktop 上运行 Wasm 模块&lt;/h3&gt;&lt;p&gt;当您开发软件时，您希望在本地和云端进行尝试。我将使用 Docker Desktop 作为可用于在容器内本地运行代码的工具示例。&lt;/p&gt;&lt;p&gt; Docker Desktop 还使用 runwasi 来支持 Wasm 模块。按照&lt;a href="https://docs.docker.com/desktop/wasm/#turn-on-wasm-workloads"&gt;Docker Wasm 文档&lt;/a&gt;中的说明在 Docker Desktop 上启用 Wasm 支持。&lt;/p&gt;&lt;p&gt;使用以下 docker run 命令在系统上启动 Wasm 容器。 –runtime=io.containerd.wasmedge.v1 通知 Docker 引擎您想要使用 Wasm containerd shim 而不是标准的 Linux 容器运行时。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;docker run -d -p 8080:8080 \&lt;br /&gt; --name=wasm-demo-app \&lt;br /&gt; --runtime=io.containerd.wasmedge.v1 \&lt;br /&gt; docker.io/cr7258/wasm-demo-app:v1&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;向该容器中的演示服务发送请求：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;curl http://localhost:8080&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出是：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;Hello, World!&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要删除容器，可以执行以下命令：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;docker rm -f wasm-demo-app&lt;/code&gt;&lt;/pre&gt;&lt;h3 class="wp-block-heading"&gt;在 Kubernetes 上运行 Wasm 模块&lt;/h3&gt;&lt;p&gt;要在 Kubernetes 上运行 Wasm 工作负载，工作节点需要使用 Wasm 运行时进行引导，并且 RuntimeClass 对象用于将工作负载分配给支持 Wasm 的节点。&lt;/p&gt;&lt;p&gt; &lt;a href="https://kind.sigs.k8s.io/"&gt;&lt;em&gt;Kind&lt;/em&gt;&lt;/a&gt; （Docker 中的 Kubernetes）是一种使用本地容器作为“节点”运行本地 Kubernetes 集群的工具，通常在 Docker 中。为了方便实验，我们使用kind创建一个Kubernetes集群，以供后续章节使用。运行以下命令来安装 kind：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;[ $(uname -m) = x86_64 ] &amp;amp;&amp;amp; curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64&lt;br /&gt; chmod +x ./kind&lt;br /&gt; sudo mv ./kind /usr/local/bin/kind&lt;/code&gt;&lt;/pre&gt;&lt;h4 class="wp-block-heading"&gt;手动为 Wasm 设置集群，然后在 pod 内运行应用程序&lt;/h4&gt;&lt;p&gt;在本节中，我将演示使用 WasmEdge 运行时库手动安装 crun，并调整 containerd 配置以使用 crun 作为运行时，从而在 Kubernetes 节点上启用 Wasm 支持。&lt;/p&gt;&lt;p&gt;使用kind创建单节点Kubernetes集群。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;kind create cluster --name wasm-demo&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;按种类创建的每个 Kubernetes 节点都是一个容器，通常在 Docker 中运行。您可以使用 docker exec 命令进入该节点。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;docker exec -it wasm-demo-control-plane bash&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 💡 在节点上输入 shell 后，按照以下部分中的说明进行操作： &lt;a href="https://docs.google.com/document/d/1eM-iK_0s-Z7daLe1w_8TKujj5cxHl4S6/edit#bookmark=id.30j0zll"&gt;通过低级容器运行时运行 Wasm 模块&lt;/a&gt;，以在节点上安装支持 Wasm 的 crun 二进制文件。&lt;/p&gt;&lt;p&gt;修改containerd配置文件/etc/containerd/config.toml，在最后添加以下内容：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;将 crun 配置为 containerd 的运行时处理程序。格式为 [plugins.”io.containerd.grpc.v1.cri”.containerd.runtimes.${HANDLER_NAME}]。&lt;/li&gt;&lt;li&gt; pod_annotations 允许将注释 module.wasm.image/variant 传递给 crun，该注释在 Pod 元数据中设置以识别 Wasm 工作负载。&lt;/li&gt;&lt;/ul&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;cat &amp;gt;&amp;gt; /etc/containerd/config.toml &amp;lt;&amp;lt; EOF&lt;br /&gt; [plugins.&amp;quot;io.containerd.grpc.v1.cri&amp;quot;.containerd.runtimes.crun]&lt;br /&gt;    runtime_type = &amp;quot;io.containerd.runc.v2&amp;quot;&lt;br /&gt;    pod_annotations = [&amp;quot;module.wasm.image/variant&amp;quot;]&lt;br /&gt; [plugins.&amp;quot;io.containerd.grpc.v1.cri&amp;quot;.containerd.runtimes.crun.options]&lt;br /&gt;    BinaryName = &amp;quot;crun&amp;quot;&lt;br /&gt; EOF&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;重新启动容器：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;systemctl restart containerd&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在节点上设置标签runtime=crun：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;kubectl label nodes wasm-demo-control-plane runtime=crun&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建一个名为 crun 的 RuntimeClass 资源，以使用 containerd 中预先配置的 crun 处理程序，scheduling.nodeSelector 属性将 pod 发送到带有 runtime=crun 标签的节点。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;apiVersion: node.k8s.io/v1&lt;br /&gt; kind: RuntimeClass&lt;br /&gt; metadata:&lt;br /&gt;  name: crun&lt;br /&gt; scheduling:&lt;br /&gt;  nodeSelector:&lt;br /&gt;    runtime: crun&lt;br /&gt; handler: crun&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下来，在 Kubernetes Pod 中运行 Wasm 应用程序。为 pod 设置 .spec.runtimeClassName 以将 pod 定位到 crun RuntimeClass。这将确保 pod 被分配到 crun RuntimeClass 中指定的节点和运行时。此外，设置注释 module.wasm.image/variant: compat 以通知 crun 这是一个 Wasm 工作负载。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;apiVersion: v1&lt;br /&gt; kind: Pod&lt;br /&gt; metadata:&lt;br /&gt;  name: wasm-demo-app&lt;br /&gt;  annotations:&lt;br /&gt;    module.wasm.image/variant: compat&lt;br /&gt; spec:&lt;br /&gt;  runtimeClassName: crun&lt;br /&gt;  containers:&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;名称：wasm-演示应用程序&lt;br /&gt;图片：docker.io/cr7258/wasm-demo-app:v1&lt;/li&gt;&lt;/ul&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;&lt;br /&gt;You can use `kubectl port-forward` to forward traffic from your local machine into the Kubernetes cluster:&lt;br /&gt;&lt;br /&gt; ```bash&lt;br /&gt; kubectl port-forward pod/wasm-demo-app 8080:8080&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;打开一个新终端，向服务发送请求。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;curl http://localhost:8080&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出是：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;Hello, World!&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;测试完成后，您可以通过运行以下命令来销毁集群：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;kind delete cluster --name wasm-demo&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在本文中， module.wasm.image/variant: compat 注解用于向容器运行时指示该工作负载是 Wasm 工作负载。在此&lt;a href="https://github.com/containers/crun/pull/886"&gt;PR&lt;/a&gt;中，crun 引入了一个新的注释：module.wasm.image/variant: compat-smart。&lt;/p&gt;&lt;p&gt;当使用compat-smart注解时，crun可以根据是Wasm工作负载还是OCI容器智能判断如何启动容器。这使得使用 sidecar 运行 WASM 容器成为可能。以下是包含 Wasm 容器和 Linux 容器的 Pod YAML 文件示例：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;apiVersion: v1&lt;br /&gt; kind: Pod&lt;br /&gt; metadata:&lt;br /&gt;  name: wasm-demo-app&lt;br /&gt;  annotations:&lt;br /&gt;    module.wasm.image/variant: compat-smart # Kubernetes copies Pod annotations to container runtime labels, which is why this works.&lt;br /&gt; spec:&lt;br /&gt;  runtimeClassName: crun&lt;br /&gt;  containers:&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;名称：wasm-演示应用程序&lt;br /&gt;图片：docker.io/cr7258/wasm-demo-app:v1&lt;/li&gt;&lt;li&gt;名称：linux-demo-app&lt;br /&gt;图片：nginx：1.20&lt;/li&gt;&lt;/ul&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;&lt;br /&gt;#### Set up your cluster for Wasm automatically using Kwasm, then run the app inside a pod&lt;br /&gt;&lt;br /&gt; _[Kwasm](https://kwasm.sh/)_ is a Kubernetes Operator that automatically adds WebAssembly support to your Kubernetes nodes. In this section, I will demostrate how to use Kwasm Operator to add Wasm support to Kubernetes nodes automatically.&lt;br /&gt;&lt;br /&gt; To enable Wasm support on a particular node, simply add the annotation `kwasm.sh/kwasm-node=true` on that node. This will trigger Kwasm to create a Job to deploy the necessary binary files needed to run Wasm on the node. Additionally, containerd&amp;#39;s configuration will be modified accordingly.&lt;br /&gt;&lt;br /&gt; ![02-kwasm-operator](https://hackmd.io/_uploads/HyYbqsF2p.svg)&lt;br /&gt;&lt;br /&gt;&lt;br /&gt; Create a single-node Kubernetes cluster using kind.&lt;br /&gt;&lt;br /&gt; ```bash&lt;br /&gt; kind create cluster --name kwasm-demo&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; Helm 图表可用于轻松安装 Kwasm 操作器。使用 helm 安装 Kwasm Operator，并通过添加注释 kwasm.sh/kwasm-node=true 启用对节点 kwasm-demo-control-plane 的 Wasm 支持。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;# Add Helm repository if not already done&lt;br /&gt; helm repo add kwasm http://kwasm.sh/kwasm-operator/&lt;br /&gt; # Install KWasm operator&lt;br /&gt; helm install -n kwasm --create-namespace kwasm-operator kwasm/kwasm-operator&lt;br /&gt; # Provision Nodes&lt;br /&gt; kubectl annotate node kwasm-demo-control-plane kwasm.sh/kwasm-node=true&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在节点上添加标签runtime=wasmedge。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;kubectl label nodes kwasm-demo-control-plane runtime=wasmedge&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; kwasm-node-installer 版本 v0.3.0 已删除 crun 以支持 WasmEdge shim。 WasmEdge shim 与 module.wasm.image/variant 具有相同的行为：crun + Wasmedge 的 compat-smart 注释，但不需要注释。&lt;/p&gt;&lt;p&gt;创建一个名为 wasmedge 的 RuntimeClass 资源，以使用 Kwasm 在 containerd 中自动设置的 wasmedge 处理程序，scheduling.nodeSelector 属性将 pod 发送到带有 runtime=wasmedge 标签的节点。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;apiVersion: node.k8s.io/v1&lt;br /&gt; kind: RuntimeClass&lt;br /&gt; metadata:&lt;br /&gt;  name: wasmedge&lt;br /&gt; scheduling:&lt;br /&gt;  nodeSelector:&lt;br /&gt;    runtime: wasmedge&lt;br /&gt; handler: wasmedge&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下来，在 Kubernetes Pod 中运行 Wasm 应用程序。为 pod 设置 .spec.runtimeClassName 以将 pod 定位到 wasmedge RuntimeClass。这将确保 pod 被分配到 wasmedge RuntimeClass 中指定的节点和运行时。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;apiVersion: v1&lt;br /&gt; kind: Pod&lt;br /&gt; metadata:&lt;br /&gt;  name: wasm-demo-app&lt;br /&gt; spec:&lt;br /&gt;  runtimeClassName: wasmedge&lt;br /&gt;  containers:&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;名称：wasm-演示应用程序&lt;br /&gt;图片：docker.io/cr7258/wasm-demo-app:v1&lt;/li&gt;&lt;/ul&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;&lt;br /&gt;You can use `kubectl port-forward` to forward traffic from your local machine into the Kubernetes cluster:&lt;br /&gt;&lt;br /&gt; ```bash&lt;br /&gt; kubectl port-forward pod/wasm-demo-app 8080:8080&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;打开一个新终端，向服务发送请求。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;curl http://localhost:8080&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出是：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;Hello, World!&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;测试完成后，您可以通过运行以下命令来销毁集群：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;kind delete cluster --name kwasm-demo&lt;/code&gt;&lt;/pre&gt;&lt;h2 class="wp-block-heading"&gt;结论&lt;/h2&gt;&lt;p&gt;随着 WebAssembly 的不断发展，它在 Kubernetes 中的采用标志着云原生应用程序开发向前迈出了重要一步。&lt;/p&gt;&lt;p&gt;感谢您阅读这篇文章。我希望它有助于了解 WebAssembly 的潜力以及它如何与容器生态系统配合使用。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;致谢&lt;/h2&gt;&lt;p&gt;本文包含来自 Kubernetes 项目的贡献和反馈，版权所有 © 2024 Linux 基金会。 &lt;/p&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;</description><pubDate>Wed, 27 Mar 2024 16:00:00 GMT</pubDate><guid isPermaLink="true">https://www.cncf.io/blog/2024/03/28/webassembly-on-kubernetes-the-practice-guide-part-02/</guid></item><item><title>通过 AI 驱动的 DevEx 实现工作流程自动化和管道可移植性</title><link>https://www.cncf.io/blog/2024/03/27/workflow-automation-pipeline-portability-with-ai-driven-devex/</link><description>&lt;p&gt;&lt;em&gt;会员帖子最初由 Amina Reshma 在&lt;a href="https://ozone.one/workflow-automation-&amp;amp;-pipeline-portability-with-ai-driven-devex"&gt;Ozone 博客&lt;/a&gt;上发布&lt;/em&gt;&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;与 DevEx 有什么关系？&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;破解代码：&lt;/strong&gt;曾经想过开发者体验，又名.a。开发执行？好吧，这就是整个东西——氛围、工具、仪式——基本上，是软件开发人员成功或失败的秘密武器。&lt;/p&gt;&lt;p&gt;那么，为什么衡量开发人员的生产力如此困难呢？首先，DevEx 很难描述。关于开发人员生产力的定义，存在着众多不同的观点。此外，必须考虑过程（定量）和感知（定性）指标。评估开发人员的成就感水平与衡量他们的生产力同样重要。&lt;/p&gt;&lt;p&gt;满意的开发人员更有可能留在您的组织中，并花更多时间编码和交付高质量的产品。由于 DevEx 是多方面的，没有任何一种数据能够完全捕捉到其本质。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;为什么要炒作？&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;人才磁铁：&lt;/strong&gt; DevEx 是您吸引和留住顶尖技术人才的后台通行证。这就像开发商的VIP休息室。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;有钱能使鬼推磨：&lt;/strong&gt;这不仅仅关系到快乐的程序员；还关系到快乐的程序员。这是关于钱的。 DevEx 直接影响您的开发团队的生产力，您猜对了，这会影响您的利润。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;文化俱乐部：&lt;/strong&gt; DevEx 不仅仅是一个工具箱；这是一种氛围。这是为了培育一种文化，让编码感觉就像一场精心策划的即兴演奏会。&lt;/li&gt;&lt;/ul&gt;&lt;h3 class="wp-block-heading"&gt;何必呢？&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;创新或死亡：DevEx 是创新的燃料。想要保持领先吗？更好地保持您的 DevEx 游戏的强大。&lt;/li&gt;&lt;li&gt;战略棋步：投资 DevEx 就像下棋，而不是跳棋。这是一项长期战略，为快乐、高效且极具创造力的开发团队奠定了基础。&lt;/li&gt;&lt;/ul&gt;&lt;h2 class="wp-block-heading"&gt;增强 DevEx 游戏的 6 大举措&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;标准化和容器化&lt;/strong&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;想象一下 Docker 和 Kubernetes 作为您的可靠性助手，标准化您的开发传奇。&lt;/li&gt;&lt;li&gt;不再是“它可以在我的机器上运行”——现在是“它可以在任何地方、普遍运行！”&lt;/li&gt;&lt;/ul&gt;&lt;ol start="2"&gt;&lt;li&gt;&lt;strong&gt;文档和入职培训&lt;/strong&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;让您的代码库文档保持最佳状态，并使入职流程比丝绸之路更加顺畅。&lt;/li&gt;&lt;li&gt;文档可以作为您的文化指南针 - 让它们变得全面，让它们变得像夏洛克那样聪明。&lt;/li&gt;&lt;/ul&gt;&lt;ol start="3"&gt;&lt;li&gt;&lt;strong&gt;工具链&lt;/strong&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;从 IDE 到版本控制，保持工具的完善，就像工匠最喜欢的工具包一样。&lt;/li&gt;&lt;li&gt;使用的工具应该与开发人员门户完美匹配，即使您没有，也不应该妨碍您拥有良好的 DevEx。&lt;/li&gt;&lt;/ul&gt;&lt;ol start="4"&gt;&lt;li&gt;&lt;strong&gt;代码质量&lt;/strong&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;让静态代码分析器和 linter 为您的开发人员进行质量检查探戈。&lt;/li&gt;&lt;li&gt;更少的手动审查，更少的麻烦——保持代码环境无可挑剔的干净。&lt;/li&gt;&lt;/ul&gt;&lt;ol start="5"&gt;&lt;li&gt;&lt;strong&gt;开发者自主权&lt;/strong&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;让您的开发人员在决策中拥有发言权——让他们成为主角。&lt;/li&gt;&lt;li&gt;开发人员正在修复他们的故障吗？这不是混乱；而是混乱。这就是赋权的奥秘。&lt;/li&gt;&lt;/ul&gt;&lt;ol start="6"&gt;&lt;li&gt;&lt;strong&gt;人工智能：您在发展领域的新朋友&lt;/strong&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我们已经看到人工智能 (AI) 在各个领域发挥其魔力。对于提升 DevEx 也是如此！以下是人工智能如何重塑多个行业的用户体验的快速浏览：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;医疗保健：&lt;/strong&gt;通过预测分析、个性化治疗计划和高效的患者护理系统来改变医疗保健。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;金融：&lt;/strong&gt;简化欺诈检测、自动化重复任务并提供数据驱动的见解，以改善金融领域的决策。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;制造：&lt;/strong&gt;通过预测性维护、质量控制和自主系统增强制造流程。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;客户服务：&lt;/strong&gt;人工智能驱动的聊天机器人和虚拟助理正在通过提供即时帮助和增强用户体验来改变客户服务。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;人工智能在 DevEx 中的潜力&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;提高灵活性：&lt;/strong&gt;生成式人工智能正在慢慢缩小框架之间的界限，使它们之间的转换变得轻而易举。 &lt;a href="https://ozone.one/the-role-of-large-language-models-(llms)-in-automating-pipeline-conversions-from-legacy-to-tekton"&gt;这是一篇关于如何通过使用户能够通过自动化在新时代框架和旧框架之间进行切换来重新定义用户体验的文章&lt;/a&gt;。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;简化流程：&lt;/strong&gt; Picture AI 可以自动执行重复性任务，使开发人员能够专注于工作中更复杂和更具创造性的方面。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;改进文档：&lt;/strong&gt;人工智能驱动的工具有助于创建强大的、用户友好的文档，使开发人员更容易理解和为项目做出贡献。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;我们看到的一个流行用例是 Github Copilot。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt; GitHub Copilot 是一款由 GitHub 和 OpenAI 开发的人工智能驱动的代码补全工具，处于重塑开发者体验 (DevEx) 的最前沿。 GitHub Copilot 基于 OpenAI 的 Codex 构建，显着提高了工作效率，调查显示用户的工作效率提高了 55%。这种自动代码完成工具与 Visual Studio Code 和其他 IDE 无缝集成，可根据所编写代码的上下文建议巧妙的代码片段、完整功能和常见模式。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt; GitHub Copilot 的优势&lt;/h3&gt;&lt;p&gt;GitHub Copilot 通过最大限度地减少手动编码时间、改进样板代码创建以及快速解决 IDE 中的问题，从而显着提高开发速度，从而提高部署频率。此外，它还通过快速生成测试用例和数据来提高代码质量和测试覆盖率，从而改善开发人员体验 (DevEx)。作为虚拟的第二开发人员，Copilot Chat 可以加快代码审查时间，帮助创建高质量代码，并通过解释促进彻底理解。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt; GitHub Copilot 的缺点&lt;/h3&gt;&lt;p&gt;尽管有其优势，GitHub Copilot 也遇到了挑战，特别是由于其广泛的知识库而导致潜在的许可和版权问题。该工具的局限性包括可能缺乏特定领域的知识，从而阻碍了专业领域的精确建议。 GitHub Copilot 可能会面临不太常见的语言、框架或不可定制的库的困难，造成与公共存储库或闭源数据中易受攻击的代码相关的安全问题，可能导致版权问题。此外，该工具还引发了人们对完成代码会阻碍开发人员的担忧，这些代码可能看起来正确，但可能容易受到攻击或充满安全问题，从而破坏学习过程。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;超越 GitHub Copilot 的人工智能&lt;/h2&gt;&lt;p&gt;DevOps 的一项主要挑战是新技术的无缝过渡和采用，尤其是在迁移管道方面。新技术迁移历来都是采用的瓶颈。对于拥有大量管道的团队来说，从 Jenkins、GitLab 或 Azure Pipelines 过渡到 Tekton Pipelines 具有战略意义，因为它植根于 Kubernetes 和云原生方法。 Tekton Pipelines 提供优化的工作流程，加速云原生 DevOps 并通过动态集群管理确保性能和可扩展性。 Kubernetes 原生设计符合最佳实践，提高资源效率，并简化采用云原生方法的组织的管道管理。&lt;/p&gt;&lt;p&gt; Ozone 在使管道可移植性成为人工智能的无缝用户体验方面迈出了重要一步。通过利用先进的自动化，Ozone 使用人工智能来促进管道的顺利技术转型。这解决了与新技术采用相关的历史瓶颈，为希望通过多种管道拥抱 DevOps 的团队提供了解决方案。管道转换的自动化确保了无麻烦的转变，使团队更有吸引力地采用新技术，而不会遇到通常的复杂性和挑战。通过这种方式，Ozone 结合了人工智能和 DevOps 的力量，提供了一种解决方案，彻底改变了管道迁移过程，并使团队能够无缝地采用新技术。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;为什么需要管道可移植性&lt;/h2&gt;&lt;p&gt;对于深深植根于 Kubernetes 和云原生方法的组织来说，从 Jenkins、GitLab 或 Azure Pipelines 过渡到 Tekton Pipelines 具有战略意义。 Tekton Pipelines 为以 Kubernetes 为中心的项目提供优化的工作流程，加速云原生 DevOps，并通过动态集群管理实现性能和可扩展性。通过 Kubernetes 原生设计，Tekton 与容器化和声明式配置等云原生最佳实践无缝结合。此迁移提高了资源效率并简化了采用云原生方法的组织的管道管理。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;它是如何完成的&lt;/h2&gt;&lt;h3 class="wp-block-heading"&gt;大规模自动化管道转换的工作流程&lt;/h3&gt;&lt;figure class="wp-block-image"&gt;&lt;img alt="devex ai.jpg" src="https://blogimage.ozonecloud.ai//2/devex_ai_7ad3041f49.jpg" /&gt;&lt;/figure&gt;&lt;p&gt;该工作流程的主要目标是通过利用 Prompt Engineering 使用大型语言模型 (LLM) 简化转换过程。这涉及利用聊天上下文和基于角色的提示为 LLM 模型建立上下文，使用各种平台的示例管道训练模型以定义相应的 YAML。&lt;/p&gt;&lt;p&gt;正如本博客所强调的，为了吸引顶尖技术人才、影响团队生产力并最终影响利润，必须理解和改善开发人员体验 (DevEx)。随着 Kubernetes 和云原生方法与 Tekton Pipelines 保持一致，Ozone 理解管道可移植性的战略重要性，特别是从 Jenkins、GitLab 或 Azure Pipelines 传输时。&lt;/p&gt;&lt;p&gt;将现有管道转换为可重复使用的 Tekton 管道的功能终身免费向每个用户开放，用户、构建、项目和管道不受限制。&lt;a href="https://cd.ozone.one/emailsignup"&gt;立即注册以转换您的管道！&lt;/a&gt;&lt;/p&gt;&lt;p&gt; &lt;a href="https://www.ozone.one/"&gt;Ozone&lt;/a&gt;专注于消除 DevOps 团队的各种复杂性。它简化并自动化了跨混合云和多样化区块链网络的容器化和去中心化应用程序部署。 Ozone 与 CI、CD、分析和自动化领域的主要工具无缝集成，以支持您端到端的软件交付，即使是最复杂的场景也是如此。&lt;/p&gt;&lt;p&gt;请写信给我们： &lt;a href="mailto:info@ozone.one"&gt;info@ozone.one&lt;/a&gt; &lt;/p&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;</description><pubDate>Tue, 26 Mar 2024 16:00:00 GMT</pubDate><guid isPermaLink="true">https://www.cncf.io/blog/2024/03/27/workflow-automation-pipeline-portability-with-ai-driven-devex/</guid></item><item><title>KCD 意大利 2024 标志：云原生和谐的一部分</title><link>https://www.cncf.io/blog/2024/03/26/the-kcd-italy-2024-logo-a-slice-of-cloud-native-harmony/</link><description>&lt;p&gt;&lt;em&gt;KCD 意大利团队发布的 KCD 帖子&lt;/em&gt;&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;strong&gt;呼吁协调&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;意大利 Kubernetes 社区日 (KCD) 是一项由 CNCF 支持的充满活力的活动，以全新的方式回归。 2024 年，CNCF 和 Linux 基金会要求努力协调全球所有 KCD 徽标。本文旨在讲述这一充满挑战的过程如何实现传统与全球协调的和谐融合。让我们探讨一下这种转变背后的原因、徽标的历史，以及为什么保持一致的品牌标识仍然至关重要。 KCD 意大利只是其中之一，只是一个例子（因为我们团队热爱它的历史）。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;strong&gt;原来的标志&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;KCD 意大利徽标始终是社区精神、协作和 Kubernetes 热情的象征。 &lt;a href="https://www.cncf.io/blog/2021/10/04/how-was-a-pizza-chosen-as-the-kcd-italy-2021-logo/"&gt;&lt;strong&gt;2021 年&lt;/strong&gt;，该标志的特色是在擀面杖之间放置了一块俏皮的半披萨片，让人想起 Kubernetes 舵上的转向臂&lt;/a&gt;。这种异想天开的设计抓住了意大利 KCD 的精髓：一个社区就像美味披萨中的原料一样聚集在一起，创造出比各个部分相加更伟大的东西。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;strong&gt;为什么要改变？&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;之前的 KCD Italy 徽标对我们很有帮助，但随着社区的扩大，全球&lt;a href="https://www.cncf.io/kcds/"&gt;Kubernetes 社区日计划&lt;/a&gt;也随之扩大。 CNCF 与 Linux 基金会合作，鼓励我们将我们的视觉形象与全球其他 KCD 活动保持一致。是时候进化了——创建一个能在当地和全球引起共鸣的标志。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;strong&gt;元素背后的故事&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;在无数次讨论和头脑风暴会议中，答案出现了：&lt;strong&gt;披萨&lt;/strong&gt;。还有什么比这道受人喜爱的菜肴更具有意大利特色呢？披萨体现了意大利的精髓，远销世界各地，它象征着社交、分享和简单。它连接了半岛的北部、中部和南部，将意大利人因其对奶酪、松软美味的共同热爱而团结在一起。&lt;/p&gt;&lt;p&gt;但这不仅仅是披萨。 KCD Italy 的标志是一个切片的半比萨饼，放在擀面杖之间。这些擀面杖让人想起 Kubernetes 舵的转向臂，强调了推动云原生社区的热情。这是对科技世界的一种有趣的认可，在科技世界中，工作和热情常常交织在一起。&lt;/p&gt;&lt;p&gt;让我们再次剖析一下这个标志：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;披萨&lt;/strong&gt;：向国际社会致敬。它的配料——代表不同的文化、语言和观点——无缝地融合在一起。&lt;/li&gt;&lt;li&gt; &lt;strong&gt;Slice&lt;/strong&gt; ：我们的传统。因为我们的目标是与社区分享。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;擀面杖&lt;/strong&gt;：引导我们朝着共同的目标前进。 Kubernetes 就像揉好的面团一样，将我们联系在一起。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;花彩&lt;/strong&gt;：一丝奇思妙想和庆祝，强调学生的学习和成长精神。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;锚&lt;/strong&gt;：向云原生中的航海参考致敬——锚让我们在数字海洋中航行时保持脚踏实地。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;番茄红&lt;/strong&gt;：大胆而充满活力，象征着我们对开源的热情。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;浅面团颜色&lt;/strong&gt;：提醒我们，我们的旅程既独特又滋养。&lt;/li&gt;&lt;/ol&gt;&lt;h2 class="wp-block-heading"&gt; &lt;strong&gt;KCD 计划的徽标：颜色和象征意义&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Kubernetes 社区日 (KCDs)&lt;/strong&gt;徽标是一种视觉表现形式，概括了这一社区驱动的活动的本质。让我们来分解一下它的要素：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;调色板&lt;/strong&gt;：&lt;ul&gt;&lt;li&gt;该标志主要采用蓝色和白色色调。蓝色象征着信任、稳定和技术，这与 Kubernetes 的核心原则是一致的。&lt;/li&gt;&lt;li&gt;白色背景象征着开放、透明和协作。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;图像&lt;/strong&gt;：&lt;ul&gt;&lt;li&gt;徽标中的双手传达了社区协作、知识共享和技术进步的信息。&lt;/li&gt;&lt;li&gt;它邀请参与者聚集在一起，学习并为 Kubernetes 生态系统做出贡献，背景的六边形让人想起。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;付清：&lt;/strong&gt;&lt;ul&gt;&lt;li&gt;共同成长云原生：很明显，这体现了开源创新的精神，将技术人员、采用者和爱好者聚集在一起，塑造云原生计算的未来&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;请注意，此分析基于视觉解释，实际的设计决策可能有创作者提供的其他背景&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;strong&gt;为什么它比以往任何时候都更重要&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;然后合并发生了。但为什么一致的品牌形象至关重要呢？有几个原因：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;全球认可&lt;/strong&gt;：明确定义的徽标可确保即时认可。当与会者看到 KCD Italy 标志时，他们知道自己是一个大家庭的一部分——一场全球运动。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;跨境信任&lt;/strong&gt;：一致性促进信任。世界各地的与会者会将徽标与质量、真实性和共享体验联系起来。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;统一的切片&lt;/strong&gt;：集成的标志连接了各大洲。它是对话的开始，是跨时区的握手，是与会者联系、协作和享受云原生友情的聚集点&lt;/li&gt;&lt;/ol&gt;&lt;h2 class="wp-block-heading"&gt;&lt;strong&gt;展望未来&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;KCD 徽标的转变体现了协作和适应的力量。通过拥抱变革并尊重传统，所有团队确保其品牌形象在全球范围内引起共鸣。&lt;/p&gt;&lt;p&gt;在我们热切等待 2024 年 KCD 意大利版的同时，我们邀请整个 CNCF 社区加入我们。让我们一起握手、分享故事、品尝虚拟披萨。谁知道呢？也许明年，我们会在我们的标志中添加一些配料——额外的奶酪，有人吗？对了， &lt;a href="https://sessionize.com/kcd-italy-2024/?e=310130"&gt;CFP还开放&lt;/a&gt;，还有&lt;a href="https://drive.google.com/file/d/10iHzmJUoMLYWQxmxtrYuBGsDjSEbPNNC/view?usp=sharing"&gt;赞助机会&lt;/a&gt;！&lt;/p&gt;&lt;p&gt;云原生同胞们，胃口大开！ 🍕&lt;/p&gt;&lt;hr class="wp-block-separator has-alpha-channel-opacity" /&gt;&lt;p&gt;&lt;em&gt;注：KCD Italy 徽标由充满热情的社区成员精心设计，体现了我们对包容性和共享成长的承诺，其象征意义体现了协作和乐趣的精神。&lt;/em&gt; &lt;/p&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;</description><pubDate>Mon, 25 Mar 2024 16:00:00 GMT</pubDate><guid isPermaLink="true">https://www.cncf.io/blog/2024/03/26/the-kcd-italy-2024-logo-a-slice-of-cloud-native-harmony/</guid></item><item><title>为什么您可能会从可观测性解决方案中删除关键移动数据</title><link>https://www.cncf.io/blog/2024/03/25/why-you-may-be-dropping-key-mobile-data-from-your-observability-solution/</link><description>&lt;p&gt;&lt;em&gt;Embrace 首席技术官兼联合创始人&lt;a href="https://www.linkedin.com/in/fredricnewberg/"&gt;Fredric Newberg&lt;/a&gt;的会员帖子&lt;/em&gt;&lt;/p&gt;&lt;p&gt;如果您有一个业务关键型移动应用程序，您可能会惊讶地发现您的可观测性解决方案正在丢弃大部分移动应用程序可观测性数据。这是因为来自移动设备的数据从客户端收集到服务器端摄取经常会出现延迟。但到底为什么会这样，它如何影响您的移动体验的可观察性？&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;a&gt;&lt;/a&gt;从移动设备收集数据的现实&lt;/h2&gt;&lt;p&gt;从移动设备收集数据时，您必须接受这一点——与后端可观察性不同——您无法控制整个系统。您收集数据的设备在人们手中。因此，它们是异构数据源，具有广泛不同的使用模式和网络连接。&lt;/p&gt;&lt;p&gt;后端和网络监控中的假设（即用户与可观测服务有连接）不适用于移动设备，但许多可观测工具都明确期望近乎持续的连接。然而，在移动应用程序中，人们的连接能力差异很大。&lt;/p&gt;&lt;p&gt;这让我们面临移动可观测性的严酷现实之一，即数据经常延迟。在移动设备上收集的数据可能需要数小时甚至数天的时间才能发送到后端系统。&lt;/p&gt;&lt;p&gt;从角度来看，大多数 DevOps 团队都会认为服务器离线一天并且不提供可观察性数据是非常不正常的。对于某些移动应用程序来说，这是常态而不是例外。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;a&gt;&lt;/a&gt;是什么导致了移动应用程序中的数据延迟？&lt;/h2&gt;&lt;p&gt;移动应用程序的数据延迟配置文件变化的一个关键方式是它们的使用模式。考虑在偏远地区使用健康和保健应用程序来导航路径。或者用于仓库、农业区或石油钻井平台的内部生产力应用程序。只要连接紧张，您就会看到更大的数据延迟。&lt;/p&gt;&lt;p&gt;然而，移动应用程序的一个主要好处是它们可以在任何地方使用。因此，即使是购物和手机游戏等与位置无关的应用程序，在连接状况不佳的情况下仍然会大量使用。人们在乘坐地铁或公交车时玩手机游戏。或者，他们在开车去附近的快餐店时下移动食品订单。&lt;/p&gt;&lt;p&gt;再举一个例子，在我们的客户群中（包括各个行业和类别的移动应用程序），我们只看到一小部分应用程序没有任何延迟至少一天的数据实例。&lt;/p&gt;&lt;p&gt;除了使用模式之外，iOS 和 Android 生态系统也会影响数据延迟。当应用程序在 iOS 上崩溃时，只有重新启动应用程序后才会报告崩溃。在 Android 上，情况要好一些，如果有互联网连接，大多数 Java 或 Kotlin 代码中发生的崩溃都可以在有限的延迟内报告，但本机代码中发生的崩溃要等到下一次应用程序启动时才会报告。 。因此，最终用户的行为（尤其是在 iOS 上）会影响您何时实际收到表明应用程序存在稳定性问题的数据。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;a&gt;&lt;/a&gt;为什么这些数据延迟很重要？&lt;/h2&gt;&lt;p&gt;让我们从显而易见的事情开始——您想要全面了解您的移动应用程序正在做什么。如果您的后端系统丢弃在设备上收集 3 小时后到达的任何数据，您将面临很大的可见性差距。在下图中，您可以看到丢弃延迟数据会损失多少可见性。 &lt;/p&gt;&lt;figure class="wp-block-image size-full"&gt;&lt;img alt="图像" class="wp-image-102855" height="624" src="https://www.cncf.io/wp-content/uploads/2024/03/image.png" width="936" /&gt;&lt;/figure&gt;&lt;p&gt;该数据是从数据延迟高于平均水平的客户处提取的。请注意，25% 的数据在移动设备上收集后至少 2 天内不会到达，而 100% 的数据在大约 1 周内不会到达。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;a&gt;&lt;/a&gt;为什么要丢弃延迟的数据？&lt;/h2&gt;&lt;p&gt;因此，如果这是移动应用程序的典型行为，那么这就引出了一个问题——为什么要丢弃延迟的数据？嗯，如上所述，这不是后端可观察性的典型行为。如果您的系统设计为处理来自后端应用程序的数据，那么支持延迟数据可能不是您所关心的问题。虽然在数据量适中时能够处理延迟数据的系统的修改或操作成本可能不那么高，但一旦数据量更大，您将开始遇到严峻的挑战。&lt;/p&gt;&lt;p&gt;在&lt;a href="https://embrace.io/"&gt;Embrace&lt;/a&gt; ，我们只关注移动可观测性，因此我们从第一天起就构建了我们的系统，期望我们能够获得大量延迟的数据。我们选择了能够有效存储延迟数据的构建块，并使用了容纳要存储和查询的延迟数据的数据模式，以便必须考虑的较大时间窗口不会导致查询性能的过度损失。&lt;/p&gt;&lt;p&gt;如果移动在您的组织中日益受到重视，您应该已经在计划如何大规模解决数据延迟问题。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;a&gt;&lt;/a&gt;对于延迟的数据问题，您今天可以采取什么措施？&lt;/h2&gt;&lt;p&gt;一个简单的解决方案是仅使用数据报告给可观测性服务的时间作为事件的时间。然而，这往往会导致更多的混乱而不是有帮助。让我们考虑一下这将如何影响跟踪您刚刚发布的新应用程序版本中的崩溃。&lt;/p&gt;&lt;p&gt;您的团队发现崩溃次数激增，因此您发起调查以追查根本原因，然后发布新版本。崩溃率下降了，一切都很好。&lt;/p&gt;&lt;p&gt;但是，当使用先前崩溃版本的用户（他们太沮丧而无法重新启动您的应用程序）最终决定再试一次时，会发生什么呢？他们再次启动应用程序，该应用程序会从设备发送崩溃报告。如果您的可观察性工具将这些崩溃标记为刚刚发生，您可能会认为问题仍然存在，即使您发布了修复程序。&lt;/p&gt;&lt;p&gt;那么为什么不做正确的事情并将数据映射到事件发生的时间呢？您必须在摄取或查询时（有时甚至两者兼而有之）为此付出代价。大多数以具有成本效益的价格点支持扩展的常用数据库都需要进行权衡，这使得摄取延迟数据变得非常重要。如果您采用更简单的摄取方法，您最终将在查询时付出代价，与正常情况下相比，您可能会查询更多数量级的数据，具体取决于您决定支持的延迟时间对于非延迟数据。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;a&gt;&lt;/a&gt;结束语&lt;/h2&gt;&lt;p&gt;考虑到移动应用程序产生的价值以及它们对当今许多企业的重要性，基于可观测数据子集进行操作并不是一个明智的策略。由于多种原因，传统的可观测性解决方案无法有效监控移动应用程序，其中移动数据的延迟性是一个关键因素。&lt;/p&gt;&lt;p&gt;您并不是唯一一个意识到全面了解移动可观测性数据这一挑战的人。好消息是，今天有一些解决方案，从移动优先方法到配置现有后端系统，以解决移动数据捕获的尖角问题。随着移动技术的加速发展，我们还看到开源社区和管理团体重新思考移动遥测标准应该是什么。看到移动可观测性在不久的将来会是什么样子是令人兴奋的。&lt;/p&gt;&lt;hr class="wp-block-separator has-alpha-channel-opacity" /&gt;&lt;h2 class="wp-block-heading"&gt;&lt;a&gt;&lt;/a&gt; 作者简介&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;弗雷德里克·纽伯格&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Fredric Newberg 是 Embrace 的首席技术官兼联合创始人，该解决方案帮助工程师管理移动的复杂性，以构建更好、更大胆的体验。 Wildlife、TakeTwo、GOAT、Yahoo! 等公司Fantasy Sports 和《纽约时报》使用 Embrace 来识别任何影响用户的问题以及详细的技术背景，以便立即解决这些问题。&lt;/p&gt;&lt;p&gt; Fredric 在构建后端系统来处理移动游戏分析平台所需的大量数据方面拥有丰富的经验。他是 Kontagent（现为 Upsight）的创始工程师，这是一个面向顶级游戏开发商的大型移动分析平台。他设计并构建了后端系统，可以为全球客户处理 1500 个应用程序、2.5 亿每月活跃用户以及每月 150B 起事件。随后，他成为 Rave 的创始工程师，Rave 是面向手机游戏开发者的顶级社交图谱工具包之一。 Rave 负责 2016 年 Pokemon Go 的发布。&lt;/p&gt;&lt;hr class="wp-block-separator has-alpha-channel-opacity" /&gt;&lt;p&gt;伸出手，让我们继续对话：&lt;/p&gt;&lt;p&gt;&lt;a href="mailto:fredric@embrace.io"&gt;弗雷德里克@embrace.io&lt;/a&gt;&lt;/p&gt;&lt;p&gt; &lt;a href="https://www.linkedin.com/in/fredricnewberg/"&gt;https://www.linkedin.com/in/fredricnewberg/&lt;/a&gt; &lt;/p&gt;&lt;figure class="wp-block-embed is-type-rich is-provider-twitter wp-block-embed-twitter"&gt;&lt;div class="wp-block-embed__wrapper"&gt; &lt;a class="twitter-timeline" href="https://twitter.com/fnewberg?ref_src=twsrc%5Etfw"&gt;fnewberg 的推文&lt;/a&gt;&lt;/div&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;</description><pubDate>Sun, 24 Mar 2024 16:00:00 GMT</pubDate><guid isPermaLink="true">https://www.cncf.io/blog/2024/03/25/why-you-may-be-dropping-key-mobile-data-from-your-observability-solution/</guid></item><item><title>KubeCon + CloudNativeCon Europe 2024 第四天：展望 Kubernetes 的过去和未来（以及更多新闻</title><link>https://www.cncf.io/blog/2024/03/22/kubecon-cloudnativecon-europe-2024-day-four-how-cloud-native-is-powering-the-ai-movement-and-other-news/</link><description>&lt;p&gt;今天是最后一天了，已经发生了很多事情！我们已经展示了当我们作为一个社区聚集在一起时可以创造出多么令人惊奇的事物。以下是 KubeCon + CloudNativeCon Europe 2024 第 4 天的亮点。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;开场主旨：十年了！&lt;/strong&gt;&lt;/p&gt;&lt;p&gt; Linux 基金会 (CNCF) 首席技术官 Chris Anisczcyk 在 KubeCon 的最后一天拉开帷幕，谈论 Kubernetes 的历史。从十年前的几个人到今天的 12,000 多人，Kubernetes 现在不仅是 GitHub 上最大的项目之一，也是最大的 Slack 渠道之一。 Anisczcyk 分享了即将举行的 Kubernetes 庆祝派对的详细信息、一个新的 contribcard.dev 网站，您可以在其中看到自己对 Kubernetes 的第一个贡献，以及一个名为&lt;a href="https://github.com/cncf/kubestronaut"&gt;Kubetronaut 计划&lt;/a&gt;的新教育大使计划。接下来我们要去哪里？今年秋天在盐湖城，然后在 2025 年春季在伦敦、2025 年秋季在亚特兰大、2026 年春季在阿姆斯特丹和 2026 年秋季在洛杉矶。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;主题演讲：成功并不能保证&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Heroku 首席执行官 Bob Wise 谈到了云原生的起源，并指出了我们已经走了多远。云原生之旅走过了&lt;a href="https://kccnceu2024.sched.com/event/1b0NT/keynote-success-not-guaranteed-bob-wise-ceo-heroku?iframe=no&amp;amp;w=100%&amp;amp;sidebar=yes&amp;amp;bg=no"&gt;漫长的成功之路&lt;/a&gt;。最初 Kubernetes 被限制为最多 100 个节点，但在 2016 年启动了 Kubernetes Scaling SIG，因为能够扩展它是关键。此外，他们还需要社区治理，以确保 Google 和其他公司支持开源，当然还需要 CNCF 治理。 Docker 甚至可能已经被分叉了，但幸运的是没有。换句话说，一路上做出了很多很多决定，但他们在 Kubernetes 上下了很大的赌注，10 年后就得到了回报。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;主题演讲：云原生黑客大赛的获奖者是……&lt;/strong&gt;&lt;/p&gt;&lt;p&gt; &lt;a href="https://kccnceu2024.sched.com/event/1YhKH/keynote-cloud-native-hacks-winner-announcement?iframe=yes&amp;amp;w=100%&amp;amp;sidebar=yes&amp;amp;bg=no"&gt;黑客挑战赛&lt;/a&gt;是与联合国合作发起的，目的是引入技术来帮助解决世界上一些最紧迫的问题。该黑客马拉松与 6 个联合国合作者以及来自 8 个不同国家的 22 名参与者建立了合作伙伴关系。总共发生了超过 20 个小时的黑客攻击。&lt;/p&gt;&lt;p&gt;获奖者是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;第三名——土豆队：Inhwan Hwang、Sungjin Hong、Myoenghun Yu。他们创建了最安全的步行路线，而不仅仅是最快的路线，以支持可持续城市和社区以及性别平等。&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;第二名 – 林务员团队：Radu-Stegen Zamfir、Alex-Andrei Cioc 和 George-Alexandru Tudurean 创建了一款应用程序来监测森林砍伐以及监测和报告森林火灾，以支持气候行动和陆地生命。&lt;/li&gt;&lt;li&gt;第一名 – 城市团结：Carolina Lindqvist 和 Syed Ali Raza Zaidi 创建了一款用于集体制定城市重新规划决策的应用程序，以帮助建设更加可持续的城市和社区&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;主题演讲：应用交付的未来&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;当 Docker 在 2013 年推出时，容器革命开始了，它彻底&lt;a href="https://kccnceu2024.sched.com/event/1YhKQ/keynote-a-10-year-detour-the-future-of-application-delivery-in-a-containerized-world-solomon-hykes-ceo-daggerio?iframe=yes&amp;amp;w=100%&amp;amp;sidebar=yes&amp;amp;bg=no"&gt;改变了云基础设施的设计和使用方式&lt;/a&gt;。 Dagger.io 首席执行官 Solomon Hykes 告诉观众，这一切都始于 16 年前的巴黎，当时 Docker 的第一个工作版本诞生了。那时，严肃的人不会在云上运行严肃的应用程序。这个新模型没有工具。但 PaaS 正在美国兴起，而容器是“赢得”平台大战的最佳选择。模块化是关键，最终它流行起来，然后我们转向 Docker。&lt;/p&gt;&lt;p&gt;最终，围绕容器构建的生态系统比平台更重要。但对于开发者来说，体验仍然不完美。我们还没有完成，现在我们需要找到办法，让开发者的生活变得更好。这是下一个目标，工厂模型是最好的模型，将其视为我们拥有工厂的制造模型，它是一个集成的过程。&lt;/p&gt;&lt;p&gt;但现在有了AI，Kubernetes还有用吗？是的，您仍然需要应用程序和平台，而我们正在做这一切。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;主题小组讨论：多元化中的统一：云原生社区包容性增长的十年&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Stéphane Este-Gracias，云原生支持催化剂、ITQ、CNCF 大使 | CNCF 法语术语表贡献者 |云原生卢森堡组织者&lt;/li&gt;&lt;li&gt;Andrea Giardini，独立云原生顾问/培训师&lt;/li&gt;&lt;li&gt;Jinhong Brejnholt，盛宝银行首席云架构师&lt;/li&gt;&lt;li&gt;Anastasiia Gubska，BT 集团 SRE/DevOps 工程师&lt;/li&gt;&lt;li&gt;Kasper Borg Nissen，Lunar 首席平台架构师&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;该小组探讨了&lt;a href="https://kccnceu2024.sched.com/event/1YhKV/keynote-panel-discussion-unity-in-diversity-a-decade-of-inclusive-growth-in-the-cloud-native-community-kasper-borg-nissen-lunar-jinhong-brejnholt-saxo-bank-andrea-giardini-independent-anastasiia-gubska-bt-group-stephane-este-gracias-itq?iframe=yes&amp;amp;w=100%&amp;amp;sidebar=yes&amp;amp;bg=no"&gt;超越代码的各种贡献&lt;/a&gt;，认识到本地大使、术语表翻译以及 Kubernetes 社区日 (KCD) 等活动在使云原生体验在全球范围内提供的重要作用。&lt;/p&gt;&lt;p&gt;即使没有代码，每个人都可以做出贡献。例如，词汇表项目只需要翻译能力。无代码贡献的另一个选择是与制图师工作组合作。&lt;/p&gt;&lt;p&gt;对于 CNCF 团体来说，包容性是不容谈判的。我们希望让每个人都能使用云原生技术。我们希望建立一个强大且支持性的社区，尤其是一个拥抱多样性的社区。&lt;/p&gt;&lt;p&gt;另一个例子是我们大约六个月前推出的 KubeTrain，目的是通过火车将尽可能多的人从欧洲不同城市带到 KubeCon。这项倡议后来发展成为一件大事，我们能够吸引来自欧洲各地的人们参加这次活动。&lt;/p&gt;&lt;p&gt;我们如何为 CNCF 社区的人们消除更多障碍？最重要的是确保每个人都可以访问一切。当无法参加活动时，失聪和听力困难的社区通常只是呆在家里。人们可能不知道的是，手语并不是通用的，因此仅仅拥有手语是不够的。但我们创造了一个空间，聋哑人可以用他们需要的任何语言互相交谈、分享和教育，分享知识和技能，并学习新技术。 KubeCon 是极少数可供聋哑人和听力障碍人士参加的活动之一。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;主题演讲：&lt;/strong&gt;&lt;strong&gt;云原生的未来十年&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;AWS 首席工程师 Davanum Srinivas（又名 Dims）和 solo.io 开源负责人 Lin Sun 提供了 CNCF 技术监督委员会 (TOC) 的&lt;a href="https://kccnceu2024.sched.com/event/1YhKq/keynote-cloud-native-in-its-next-decade-davanum-srinivas-principal-engineer-aws-lin-sun-head-of-open-source-soloio?iframe=yes&amp;amp;w=100%&amp;amp;sidebar=yes&amp;amp;bg=no"&gt;历史、概述和最新动态&lt;/a&gt;，该委员会为云原生提供技术领导力社区。斯里尼瓦斯展示了从最小的社区到普罗米修斯，再到我们现在所处的历史。&lt;/p&gt;&lt;p&gt; Sun 根据成员的意见分享了社区未来十年的发展方向。一些预测和愿望清单包括整合、工作负载改进（例如异构工作负载、无服务器 API、可持续性）以及向云原生的转变并成为像过去的虚拟机一样的商品。人工智能愿望清单围绕工作负载的运营以及云支出的优化和可持续性。用户正在寻求人工智能的整合和更多用例。&lt;/p&gt;&lt;p&gt;是非对错，我们将在 KubeCon 2034 上揭晓！&lt;/p&gt;&lt;p&gt;&lt;strong&gt;主题演讲：最新毕业项目！&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;从毕业项目中获取&lt;a href="https://www.cncf.io/blog/2024/03/13/cncf-graduated-projects-have-been-busy-here-are-the-latest-updates/"&gt;所有令人兴奋的细节&lt;/a&gt;。 &lt;/p&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;</description><pubDate>Thu, 21 Mar 2024 16:00:00 GMT</pubDate><guid isPermaLink="true">https://www.cncf.io/blog/2024/03/22/kubecon-cloudnativecon-europe-2024-day-four-how-cloud-native-is-powering-the-ai-movement-and-other-news/</guid></item><item><title>宣布 Kubetronaut 计划</title><link>https://www.cncf.io/blog/2024/03/22/announcing-the-kubestronaut-program/</link><description>&lt;figure class="wp-block-image size-full is-resized"&gt;&lt;img alt="Kubetronaut 标志" class="wp-image-104149" height="800" src="https://www.cncf.io/wp-content/uploads/2024/03/kubestronaut-stacked-color.png" style="width: 670px; height: auto;" width="800" /&gt;&lt;/figure&gt;&lt;p&gt; CNCF 很高兴地宣布推出新的&lt;a href="https://cncf.io/training/kubestronaut"&gt;Kubetronaut 计划&lt;/a&gt;。&lt;/p&gt;&lt;p&gt; Kubetronaut 是指已通过 CNCF 全部五项 Kubernetes 相关认证的人：&lt;a href="https://www.cncf.io/training/certification/cka/"&gt;认证 Kubernetes 管理员&lt;/a&gt;(CKA)、&lt;a href="https://www.cncf.io/training/certification/ckad/"&gt;认证 Kubernetes 应用程序开发人员&lt;/a&gt;(CKAD)、&lt;a href="https://www.cncf.io/training/certification/cks/"&gt;认证 Kubernetes 安全专家&lt;/a&gt;(CKS)、 &lt;a href="https://www.cncf.io/training/certification/kcna/"&gt;Kubernetes 和云原生助理&lt;/a&gt;(KCNA) 以及&lt;a href="https://www.cncf.io/training/certification/kcsa/"&gt;Kubernetes 和云安全助理&lt;/a&gt;(KCSA)。&lt;strong&gt;并且&lt;/strong&gt;所有五项认证必须同时有效。&lt;/p&gt;&lt;p&gt;这是一项巨大的壮举，我们要向成功达到这一地位的社区成员致谢，他们获得了 Kubetronaut 的头衔和一件专属夹克！此外，Kubestronuats 还充当我们的云原生教育大使。这个特别计划将为 Kubetronauts 带来福利，例如 CNCF 活动和认证的折扣。如果您想了解有关此计划的更多信息，请查看我们的&lt;a href="https://www.cncf.io/training/kubestronaut"&gt;常见问题解答&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;还&lt;a href="https://www.cncf.io/training/"&gt;提供&lt;/a&gt;有关 CNCF 培训和认证的更多信息。 &lt;/p&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;</description><pubDate>Thu, 21 Mar 2024 16:00:00 GMT</pubDate><guid isPermaLink="true">https://www.cncf.io/blog/2024/03/22/announcing-the-kubestronaut-program/</guid></item><item><title>释放你的创造力：为 Kubernetes 设计 10 周年徽标！</title><link>https://www.cncf.io/blog/2024/03/22/unleash-your-creativity-design-the-10th-anniversary-logo-for-kubernetes/</link><description>&lt;figure class="wp-block-image size-full is-resized"&gt;&lt;img alt="HBD K8s" class="wp-image-104161" height="708" src="https://www.cncf.io/wp-content/uploads/2024/03/image-6.png" style="width: 510px; height: auto;" width="678" /&gt;&lt;/figure&gt;&lt;p&gt;在我们准备庆祝 Kubernetes 非凡的 10 年历程之际，我们很高兴地宣布为我们充满活力的社区中的创意人才提供了一个激动人心的机会。是时候捕捉十年来创新、协作和卓越的精髓了。隆重推出 Kubernetes 10 周年徽标设计大赛。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;strong&gt;为什么要有周年纪念标志？&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt; Kubernetes 多年来不断发展和壮大，成为现代容器编排的基石。在我们迈入第十个年头之际，现在是为我们心爱的平台的动态和不断发展的本质创造视觉庆祝的完美时刻。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;strong&gt;我们正在寻找什么：&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;我们正在寻找一个能够体现 Kubernetes 精神的周年纪念徽标——它的开放性、可扩展性以及推动其成功的强大社区。无论您是经验丰富的设计师还是崭露头角的艺术家，我们都鼓励每个人参与并展示他们对 Kubernetes 之旅的独特看法。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;strong&gt;比赛详情：&lt;/strong&gt;&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;提交截止日期：太平洋时间 2024 年 4 月 30 日星期二晚上 11:59&lt;/li&gt;&lt;li&gt;获奖者公告：2024 年 6 月 CNCF.io 网站上的博客文章公告&lt;/li&gt;&lt;li&gt;奖品：全球认可和免费的完全访问会议通行证，可参加您选择的 2024 年或 2025 年即将举行的 KubeCon + CloudNativeCon&lt;/li&gt;&lt;li&gt;奖品：全球认可和免费的完全访问会议通行证，可在获奖者公布后的 1 个日历年内参加即将举行的 KubeCon + CloudNativeCon。&lt;/li&gt;&lt;li&gt;请通过下面的提交页面链接查看完整的 Kubernetes 10 周年徽标条款和条件。&lt;/li&gt;&lt;/ul&gt;&lt;h2 class="wp-block-heading"&gt;&lt;strong&gt;如何参与：&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;设计：&lt;/strong&gt;创建一个周年纪念风格的全彩图像，象征 Kubernetes 10 年的历程。它可以是对当前 Kubernetes 徽标的全新诠释，也可以是一个全新的概念。虽然允许使用生成式人工智能，但请务必遵守您使用的任何人工智能工具的所有许可条款。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;理由：&lt;/strong&gt;提供一个简短的声明，解释为什么您认为这个徽标代表 Kubernetes 的整体，特别是 10 周年。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;提交：&lt;/strong&gt;在 2024 年 4 月 30 日之前提交您的参赛作品。请务必通过以下方式提供您的姓名、联系信息和设计描述：&lt;a href="https://www.linuxfoundation.org/kubernetes-10-year-logo-contest"&gt;&lt;/a&gt; &lt;a href="https://www.linuxfoundation.org/kubernetes-10-year-logo-contest" rel="noreferrer noopener" target="_blank"&gt;https://www.linuxfoundation.org/kubernetes-10-year-logo-contest&lt;/a&gt;&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;&lt;strong&gt;指南：&lt;/strong&gt;&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;提交的作品应为原创且未发表的作品。&lt;/li&gt;&lt;li&gt;设计必须可扩展并适合各种用例，包括在线和印刷材料以及丝网印刷。&lt;/li&gt;&lt;li&gt;提交内容可以采用多种格式，包括 JPEG、PNG、AI 和 SVG。虽然接受所有格式，但建议使用最小分辨率为 300 DPI 的文件。为了获得最佳打印质量，尽可能首选 SVG 文件。&lt;/li&gt;&lt;li&gt;欢迎多参赛！但为了保证公平性和多样性，每个人最多只能参赛三件。&lt;/li&gt;&lt;/ul&gt;&lt;h3 class="wp-block-heading"&gt;&lt;strong&gt;判断标准：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;由 Kubernetes 专家和设计专业人士组成的小组将根据创意、与主题的相关性和视觉吸引力对提交的作品进行评估。获奖设计将成为 Kubernetes 十周年官方标志。&lt;/p&gt;&lt;p&gt;评审团将包括：&lt;/p&gt;&lt;ul&gt;&lt;li&gt; Tim Hockin，Google Cloud 杰出软件工程师，原始 Kubernetes 徽标的设计者&lt;/li&gt;&lt;li&gt;Chris Aniszczyk，云原生计算基金会首席技术官&lt;/li&gt;&lt;li&gt;Karen Chu，Fermyon 社区负责人，Phippy 角色设计师&lt;/li&gt;&lt;li&gt;Ashley Willis，GitHub 开发者关系总监，Kubernetes 5 周年纪念标志设计师&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;发挥你的创造力，让 Kubernetes 10 周年成为一次难忘的庆祝活动！感谢您参与这个令人难以置信的旅程和社区。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;strong&gt;有疑问吗？&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;如需咨询或了解更多信息，请联系我们&lt;a href="mailto:pr@cncf.io"&gt;pr@cncf.io&lt;/a&gt; &lt;/p&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;</description><pubDate>Thu, 21 Mar 2024 16:00:00 GMT</pubDate><guid isPermaLink="true">https://www.cncf.io/blog/2024/03/22/unleash-your-creativity-design-the-10th-anniversary-logo-for-kubernetes/</guid></item></channel></rss>