<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>CNCF - 博客</title><link>https://www.cncf.io/blog/</link><description>CNCF - 博客 - RSSHub 用爱制作(https://github.com/DIYgod/RSSHub)</description><lastBuildDate>Tue, 14 May 2024 16:04:33 GMT</lastBuildDate><generator>rfeed v1.1.1</generator><docs>https://github.com/svpino/rfeed/blob/master/README.md</docs><item><title>【Announcing LitmusChaosCon 2024!】宣布 LitmusChaosCon 2024！</title><link>https://www.cncf.io/blog/2024/05/14/announcing-litmuschaoscon-2024/</link><description>&lt;p&gt;&lt;em&gt;LitmusChaos 社区领袖、CNCF 大使 Prithvi-Raj 的社区帖子&lt;/em&gt;&lt;/p&gt;&lt;figure class="wp-block-image"&gt;&lt;img alt="石蕊混沌会议" src="https://lh7-us.googleusercontent.com/oNIhMh2VQRxkwrPsEQpsAQQVUxWSrAigaLS6IuuxqjCQA6EOFoIXl68fwmfENZVaCeVW2lHl3Vsjeg-G-CkfnpWt59W8UjAknC_5w4y6O7ytQJJQAHavKiedK-MN8_lqbTIpjCD5CisR-mmgmh3eVdE" /&gt;&lt;/figure&gt;&lt;h3 class="wp-block-heading"&gt; &lt;a href="https://litmuschaos.io/"&gt;LitmusChaos&lt;/a&gt;社区很高兴地宣布召开首届社区会议&lt;a href="https://community.cncf.io/events/details/cncf-virtual-project-events-2024-hosted-by-cncf-presents-litmuschaoscon-virtual/"&gt;LitmusChaosCon 2024&lt;/a&gt; ，这是一场为期一天的虚拟会议，内容涉及 LitmusChaos 和混沌工程的所有内容，计划于 2024 年 9 月 12 日举行&lt;/h3&gt;&lt;p&gt;在您的日历上标记 2024 年 9 月 12 日，LitmusChaos 社区将宣布 LitmusChaosCon 即将举行的许多版本中的第一个版本，这是一个关于混沌工程所有内容的仅限社区的会议。&lt;/p&gt;&lt;p&gt;在第一版中，LitmusChaosCon 的目标是通过围绕&lt;a href="https://litmuschaos.io/"&gt;LitmusChaos&lt;/a&gt;工具的一系列令人兴奋的用户故事、贡献者故事、多样化的用例和演示、闪电演讲研讨会、与其他开源工具一起运行 LitmusChaos、更多混沌工程故事来吸引社区，弹性生态系统和混沌文化的最新发展为与会者提供了启动或成熟其混沌工程实践的宝贵见解。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;strong&gt;关于 LitmusChaosCon&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt; &lt;a href="https://community.cncf.io/events/details/cncf-virtual-project-events-2024-hosted-by-cncf-presents-litmuschaoscon-virtual/"&gt;LitmusChaosCon&lt;/a&gt;是一个围绕 LitmusChaos 和混沌工程所有内容的活动。它是 SRE、QA 工程师、开发人员、性能工程师和学生交流想法、经验、贡献故事和 LitmusChaos 使用的平台。如果您曾与 LitmusChaos 合作过，或者打算采用混沌工程实践，那么您可以参加这次会议，并构建恢复力之旅。&lt;/p&gt;&lt;p&gt; LitmusChaosCon 今年的主题是“&lt;strong&gt;混沌工程社区会议&lt;/strong&gt;”，反映了混沌工程对于社区在快速发展的数字世界中实现弹性目标的重要性。&lt;/p&gt;&lt;p&gt;会议组织了来自混沌工程专家、供应商和从业者社区的论文征集 (CFP) 计划，以创建一系列令人兴奋的会议，通过这些会议，围绕最佳实践创造学习机会，以开始混沌工程并扩大规模有效地练习。&lt;/p&gt;&lt;p&gt;虚拟会议还举办了现场研讨会，提供运行混沌实验和与专家互动的实践经验。前几届研讨会都非常成功。&lt;/p&gt;&lt;p&gt;该活动适合所有角色，但 SRE、DevOps 工程师、性能工程师、开发人员、QA 工程师和学生特别感兴趣。对于第一场活动，我们希望有来自以下项目的参加者：LitmusChaos、Chaos Mesh、Keptn、Chaos Blade、Argo、Flux、Krkn、OpenTelementry。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;提交 LitmusChaosCon 2024 的演讲&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;会议正在接受演讲者提交的材料。如果您想在分组会议、闪电演讲、研讨会或小组讨论中分享您对混沌工程的专业知识或观点，现在就是您的机会。&lt;a href="https://sessionize.com/litmuschaoscon/"&gt;演讲者申请&lt;/a&gt;开放至 2024 年 6 月 23 日！&lt;/p&gt;&lt;p&gt;非常感谢&lt;a href="https://sessionize.com/"&gt;Sessionize&lt;/a&gt;主办今年会议的论文征集活动。&lt;/p&gt;&lt;p&gt;征文应包括：&lt;br /&gt; 1. 使用案例（预览 LitmusChaos 在您的环境中的部署方式、挑战以及成功之路）&lt;br /&gt; 2. 集成（预览 LitmusChaos 如何与其他 CNCF 工具集成或与您的基础设施集成），&lt;br /&gt; 3. 贡献故事（先睹为快，了解您作为社区成员或受训者如何为 LitmusChaos 做出贡献），&lt;br /&gt; 4. 社区故事（提供您从社区中学到的知识的先睹为快），&lt;br /&gt; 5. 操作（让您快速了解如何在您的环境中运行 LitmusChaos）&lt;/p&gt;&lt;p&gt;&lt;strong&gt;注册 LitmusChaosCon 2024&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;该会议仅以虚拟方式由 CNCF 支持，可免费参加， &lt;a href="https://community.cncf.io/events/details/cncf-virtual-project-events-2024-hosted-by-cncf-presents-litmuschaoscon-virtual/"&gt;注册现已开放&lt;/a&gt;。假设您是 SRE、开发人员、QA 工程师、DevOps 从业者、CTO、基础设施工程师、云架构师、产品经理或任何可以将弹性作为实践的角色。在这种情况下，本次会议适合您。&lt;/p&gt;&lt;p&gt;欲了解更多信息，请发送电子邮件至 prithvi.raj@harness.io&lt;/p&gt;&lt;p&gt;我们希望 9 月 12 日能在那里见到您！ ！&lt;/p&gt;&lt;p&gt;需要记住的重要日期：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;网站、注册和 CFP 开放：5 月 6 日当周&lt;/li&gt;&lt;li&gt;CFP 截止日期：6 月 24 日&lt;/li&gt;&lt;li&gt;程序委员会审查窗口：6 月 25 日至 7 月 8 日/活动主席构建时间表 7 月 8 日至 12 日&lt;/li&gt;&lt;li&gt;通知发言人：7 月 15 日&lt;/li&gt;&lt;li&gt;日程公布：7 月 17 日星期三&lt;/li&gt;&lt;li&gt;活动日期：9 月 12 日，星期四&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;加入 LitmusChaos 社区&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;想要获得查询、学习和 CFP 方面的帮助吗？加入 Slack 上的 LitmusChaos 社区。要加入 Slack 社区，请按照以下步骤操作！&lt;/p&gt;&lt;p&gt;&lt;br /&gt;步骤 1：使用以下链接加入 Kubernetes slack： &lt;a href="https://slack.k8s.io/"&gt;https://slack.k8s.io/&lt;br /&gt;&lt;/a&gt;步骤 2：加入 Kubernetes slack 上的#litmus 频道或加入 Kubernetes slack 后使用此链接： &lt;a href="https://slack.litmuschaos.io/"&gt;https://slack.litmuschaos.io/&lt;/a&gt;&lt;/p&gt;&lt;p&gt;以下是一些重要的链接供您参考，&lt;br /&gt; LitmusChaos 网站： &lt;a href="https://litmuschaos.io/"&gt;https://litmuschaos.io/&lt;br /&gt;&lt;/a&gt; LitmusChaos GitHub 存储库： &lt;a href="https://github.com/litmuschaos/litmus"&gt;https://github.com/litmuschaos/litmus&lt;br /&gt;&lt;/a&gt; LitmusChaos 文档： &lt;a href="https://docs.litmuschaos.io/"&gt;https://docs.litmuschaos.io/&lt;br /&gt;&lt;/a&gt; LitmusChaos YouTube 频道： &lt;a href="https://www.youtube.com/channel/UCa57PMqmz_j0wnteRa9nCaw"&gt;https://www.youtube.com/channel/UCa57PMqmz_j0wnteRa9nCaw&lt;/a&gt; &lt;/p&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;</description><pubDate>Mon, 13 May 2024 16:00:00 GMT</pubDate><guid isPermaLink="true">https://www.cncf.io/blog/2024/05/14/announcing-litmuschaoscon-2024/</guid></item><item><title>【A step-by-step guide to securely upgrading your EKS clusters】安全升级 EKS 集群的分步指南</title><link>https://www.cncf.io/blog/2024/05/13/a-step-by-step-guide-to-securely-upgrading-your-eks-clusters/</link><description>&lt;p&gt;&lt;em&gt;会员帖子最初由 Stevie Caldwell 发表在&lt;a href="https://www.fairwinds.com/blog/guide-securely-upgrading-eks-clusters"&gt;Fairwinds 博客&lt;/a&gt;上&lt;/em&gt;&lt;/p&gt;&lt;p&gt;作为一个敏捷的开源项目，Kubernetes 不断发展，云计算领域也是如此。对于许多组织来说，跟上最新版本是不切实际的，并且有充分的理由不跟上最新版本，特别是在发布后的前几周。尽管如此，落后太远并不是一个好主意，不仅因为您可能会错过重要的安全性、兼容性和性能更新，而且还因为对旧版本的支持结束了。例如，如果您使用的是&lt;a href="https://aws.amazon.com/eks/"&gt;Amazon Elastic Kubernetes Service&lt;/a&gt; (EKS)，则对 1.24 的标准支持将于 2024 年 1 月 31 日结束，1.25 将于 2024 年 5 月 1 日结束，随后的 1.26 于 6 月 11 日结束，1.27 于 7 月 24 日结束。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;如何升级 EKS 集群&lt;/h2&gt;&lt;p&gt;EKS 是 Amazon 的一项托管 Kubernetes 服务，许多组织使用它来部署、管理和扩展容器化应用程序。本指南将逐步介绍升级 EKS 集群所需执行的步骤。它包括有关何时以及如何完成这些升级的指南以及可以让您更轻松地安全可靠地升级的工具。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;多久升级一次 Kubernetes&lt;/h2&gt;&lt;p&gt; Kubernetes 社区遵循 N-2 支持政策，这意味着他们为最新的三个小版本提供安全修复和错误补丁。他们每年大约发布 3 次新的次要版本，次要版本通常在发布后的前 14 个月内受到标准支持（针对 Amazon EKS）。此后，次要版本将进入接下来 12 个月的扩展支持（按集群小时收取额外费用）。扩展支持期结束后，您的 EKS 集群将自动升级到当前支持的最旧的扩展版本。这种情况远非理想，因为它为您提供了有关升级过程的很少选择，并且您仍然需要在不久的将来升级到&lt;a href="https://kubernetes.io/releases/"&gt;较新的版本&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;以下是接下来几个 Kubernetes 版本的时间表： &lt;/p&gt;&lt;figure class="wp-block-image"&gt;&lt;img alt="Amazon EKS Kubernetes 发布日历" src="https://www.fairwinds.com/hs-fs/hubfs/AmazonEKSKubernetesReleaseCalendar.png?width=800&amp;amp;height=237&amp;amp;name=AmazonEKSKubernetesReleaseCalendar.png" /&gt;&lt;/figure&gt;&lt;p&gt;&lt;em&gt;来源：&lt;/em&gt; &lt;a href="https://docs.aws.amazon.com/eks/latest/userguide/kubernetes-versions.html"&gt;Amazon EKS Kubernetes 版本&lt;/a&gt;&lt;/p&gt;&lt;p&gt;对于大多数组织来说，希望定期评估新的 Kubernetes 版本。许多团队在不同环境中管理多个版本。例如，您可以在开发环境中测试新版本至少一两周，并在测试和登台环境中遵循该流程。在将新版本投入生产之前，请确保您至少拥有一周的数据，这样您就知道在上线时不会遇到意外的障碍。&lt;/p&gt;&lt;p&gt;每个Kubernetes版本都包含控制平面和数据平面；确保您的控制平面和数据平面运行相同的 Kubernetes 次要版本。 Kubernetes 允许&lt;a href="https://kubernetes.io/releases/version-skew-policy/#supported-versions"&gt;版本之间存在一定偏差&lt;/a&gt;，但支持因 Kubernetes 组件和不同集群开发工具而异。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;控制平面&lt;/strong&gt;— 在 EKS 集群中，控制平面由 AWS 管理。您可以使用 AWS API 开始升级到控制平面版本。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;数据平面&lt;/strong&gt;——就我们的目的而言，数据平面版本是指在节点上运行的 kubelet 的版本。即使在同一个集群中，不同的节点也可能运行不同的版本。您可以使用 kubectl getnodes 命令查找所有节点的版本。&lt;/li&gt;&lt;/ul&gt;&lt;h2 class="wp-block-heading"&gt;分阶段 EKS 升级&lt;/h2&gt;&lt;p&gt;出于升级目的，这是正确的升级顺序。但是，我们建议您的开发/阶段/测试集群在典型的日常操作中都尽可能接近生产环境。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;更新开发集群&lt;/h3&gt;&lt;p&gt;您需要首先升级您的开发环境。这可确保您及时了解最新的 K8s 更新。如果您在最新版本中遇到严重问题，您可以在将最新 EKS 版本推送到暂存之前快速识别问题并找到解决方案。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;推送至暂存区&lt;/h3&gt;&lt;p&gt;下一个要升级的环境通常是您的临时环境。这是应该捕获开发环境中尚未解决的任何剩余问题的地方。这是生产前的最后一步，因此通常最好为此处的更改留出“浸泡时间”——我们允许一到两周。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;准备生产&lt;/h3&gt;&lt;p&gt;目标是使您的生产版本尽可能与登台保持一致。这使开发人员的生活变得更轻松，因为他们无需担心维护太多版本的代码。在约定的“浸泡时间”之后，升级生产环境的风险应该很小，因此请及时升级。不要因为担心将其转移到生产而陷入未完成升级周期的陷阱。&lt;/p&gt;&lt;h4 class="wp-block-heading"&gt;&lt;em&gt;关于小版本升级的注意事项&lt;/em&gt;&lt;/h4&gt;&lt;p&gt;一些从业者建议在补丁 .2 之前不要安装最新的次要版本。换句话说，他们可能建议等待安装最新的 Kubernetes 版本，例如 1.30.0，直到 1.30.2 可用。从那里，您可以开始升级过程，从开发阶段转移到登台阶段，然后再转移到生产阶段。这一建议源于多年的经验——到 .2 版本时，广泛的测试已经完成，主要问题已经被发现和解决。通常，一旦您完成了开发升级并将其推出到暂存阶段，.3 版本就可用了。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;共同责任模型&lt;/h2&gt;&lt;p&gt;EKS 客户负责启动集群控制平面和数据平面的升级。当 AWS 处理控制平面升级时，您负责数据平面，包括 Fargate Pod 和附加组件。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;集群升级&lt;/h3&gt;&lt;p&gt;EKS 支持就地集群升级，从而保持资源和配置的一致性。它最大限度地减少用户中断并保留有关现有工作负载和资源的信息。您一次只能升级一个小版本。&lt;/p&gt;&lt;p&gt;如果您需要进行多个版本更新，则必须进行顺序升级。这种方法会增加停机风险。在这种情况下，请考虑评估&lt;a href="https://aws.amazon.com/blogs/containers/kubernetes-cluster-upgrade-the-blue-green-deployment-strategy/"&gt;蓝/绿集群升级&lt;/a&gt;策略，其中一个环境（蓝色）运行当前的 Kubernetes 版本，另一个环境（绿色）运行新的 Kubernetes 版本。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt; AWS EKS 升级管理&lt;/h2&gt;&lt;p&gt;AWS 管理 EKS 控制平面升级流程，以确保从一个 Kubernetes 版本无缝过渡到下一个版本。以下是 AWS 升级 EKS 控制平面所执行的步骤：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;升级前检查：&lt;/strong&gt; AWS 执行升级前检查，评估当前集群状态并评估新版本与您的工作负载的兼容性。如果检测到任何问题，升级过程将停止。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;备份和快照：&lt;/strong&gt;接下来，AWS 备份您现有的控制平面并创建 etcd 数据存储的快照，以确保数据一致性并使您能够在升级失败时进行回滚。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;新的控制平面：&lt;/strong&gt; AWS 现在使用新的 Kubernetes 版本创建新的控制平面；这与您现有的控制平面并行运行。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;兼容性测试：&lt;/strong&gt;接下来，AWS 测试新的控制平面与您的工作负载的兼容性，运行自动化测试以验证您的应用程序是否继续按预期运行。它分析应用程序的运行状况，而不是可能已弃用或删除的 API。 （&lt;a href="https://www.fairwinds.com/blog/pluto-finds-deprecated-kubernetes-api-versions-3-questions"&gt;Pluto&lt;/a&gt;是一个开源实用程序，可以在代码存储库和 Helm 版本中查找已弃用的 Kubernetes API 版本。）&lt;/li&gt;&lt;li&gt;&lt;strong&gt;切换控制平面终端节点：&lt;/strong&gt;此时，AWS 将控制平面终端节点（API 服务器）切换到新的控制平面。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;终止旧的控制平面：&lt;/strong&gt;完成升级后，AWS 将终止旧的控制平面并清理与其关联的所有资源。&lt;/li&gt;&lt;/ul&gt;&lt;h2 class="wp-block-heading"&gt;升级顺序&lt;/h2&gt;&lt;p&gt;要升级 EKS 集群，我们建议您执行以下步骤：&lt;/p&gt;&lt;ol&gt;&lt;li&gt; &lt;a href="https://aws.github.io/aws-eks-best-practices/upgrades/#use-the-eks-documentation-to-create-an-upgrade-checklist"&gt;查看 Kubernetes 和 EKS 的发行说明。&lt;/a&gt;&lt;/li&gt;&lt;li&gt; &lt;a href="https://aws.github.io/aws-eks-best-practices/upgrades/#upgrade-add-ons-and-components-using-the-kubernetes-api"&gt;检查您的附加组件的兼容性。&lt;/a&gt;升级您的 Kubernetes 插件和自定义控制器； &lt;a href="https://www.fairwinds.com/blog/gonogo-checks-kubernetes-add-ons"&gt;GoNoGo&lt;/a&gt;是一个检查 Kubernetes 附加组件的开源工具。&lt;/li&gt;&lt;li&gt; &lt;a href="https://aws.github.io/aws-eks-best-practices/upgrades/#identify-and-remediate-removed-api-usage-before-upgrading-the-control-plane"&gt;识别并修复工作负载中已弃用和已删除的 API 的使用情况。&lt;/a&gt;冥王星可以帮助你完成这个过程。&lt;/li&gt;&lt;li&gt; &lt;a href="https://docs.aws.amazon.com/eks/latest/userguide/update-managed-node-group.html" rel="noreferrer noopener" target="_blank"&gt;确保（如果您使用它们）托管&lt;/a&gt;&lt;a href="https://docs.aws.amazon.com/eks/latest/userguide/update-managed-node-group.html"&gt;节点&lt;/a&gt;&lt;a href="https://docs.aws.amazon.com/eks/latest/userguide/update-managed-node-group.html" rel="noreferrer noopener" target="_blank"&gt;组与控制平面位于相同的 K8s 版本上。&lt;/a&gt; EKS 托管节点组和 EKS Fargate 配置文件创建的任何节点仅支持数据平面和控制平面上的一种次要版本偏差。&lt;/li&gt;&lt;li&gt; &lt;a href="https://aws.github.io/aws-eks-best-practices/upgrades/#backup-the-cluster-before-upgrading"&gt;备份集群（如果需要）。&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://docs.aws.amazon.com/eks/latest/userguide/update-cluster.html"&gt;更新控制平面。&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://docs.aws.amazon.com/eks/latest/userguide/update-cluster.html"&gt;升级集群数据平面&lt;/a&gt;。升级您的节点，使它们与升级后的集群具有相同的 Kubernetes 次要版本。&lt;/li&gt;&lt;li&gt;&lt;a href="https://docs.aws.amazon.com/eks/latest/userguide/install-kubectl.html"&gt;更新 kubectl.&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;h2 class="wp-block-heading"&gt;创建 EKS 升级清单&lt;/h2&gt;&lt;p&gt;EKS Kubernetes&lt;a href="https://docs.aws.amazon.com/eks/latest/userguide/kubernetes-versions.html"&gt;版本文档&lt;/a&gt;提供了每个版本的详细更改列表，您应该使用该列表为每次升级构建清单。有关特定 EKS 版本升级的指导，请查看文档以确定每个版本的重要更改和注意事项。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;升级关键附加组件和组件&lt;/h3&gt;&lt;p&gt;在开始集群升级之前，请确保您了解正在使用的 Kubernetes 组件的版本。清点集群组件，特别是直接与 Kubernetes API 交互的组件。您的典型集群包含多个依赖 Kubernetes API 的工作负载，这些工作负载提供了重要的功能。这些集群组件通常包括：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;集群自动缩放器&lt;/li&gt;&lt;li&gt;容器网络接口&lt;/li&gt;&lt;li&gt;容器存储驱动程序&lt;/li&gt;&lt;li&gt;持续交付系统&lt;/li&gt;&lt;li&gt;入口控制器&lt;/li&gt;&lt;li&gt;监控和记录代理&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;确保检查是否有任何其他直接与 Kubernetes API 交互的工作负载或附加组件。有时，您可以通过查看以 *-system 结尾的命名空间来识别关键集群组件。接下来，参考这些关键组件的文档来评估版本兼容性以及是否有升级的前提条件。某些组件可能要求您在升级集群之前进行更新或调整配置。&lt;/p&gt;&lt;p&gt;以下是一些常见的附加组件（链接到升级文档）：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://docs.aws.amazon.com/eks/latest/userguide/managing-vpc-cni.html"&gt;用于 Kubernetes 自我管理附加组件的 Amazon VPC CNI 插件&lt;/a&gt;。如果您将其安装为 Amazon EKS 插件，则一次只能升级一个次要版本。&lt;/li&gt;&lt;li&gt; &lt;a href="https://docs.aws.amazon.com/eks/latest/userguide/managing-kube-proxy.html"&gt;Kubernetes kube-proxy 自我管理插件&lt;/a&gt;。&lt;/li&gt;&lt;li&gt; &lt;a href="https://docs.aws.amazon.com/eks/latest/userguide/managing-coredns.html"&gt;CoreDNS 自我管理插件&lt;/a&gt;。&lt;/li&gt;&lt;li&gt; &lt;a href="https://docs.aws.amazon.com/eks/latest/userguide/aws-load-balancer-controller.html"&gt;AWS 负载均衡器控制器&lt;/a&gt;&lt;strong&gt;。&lt;/strong&gt; AWS 负载均衡器控制器必须与您部署的 EKS 版本兼容。&lt;/li&gt;&lt;li&gt; &lt;a href="https://docs.aws.amazon.com/eks/latest/userguide/managing-ebs-csi.html"&gt;Amazon Elastic Block Store (Amazon EBS) 容器存储接口 (CSI) 驱动程序&lt;/a&gt;。&lt;/li&gt;&lt;li&gt; &lt;a href="https://docs.aws.amazon.com/eks/latest/userguide/efs-csi.html"&gt;Amazon Elastic File System (Amazon EFS) CSI 驱动程序&lt;/a&gt;。&lt;/li&gt;&lt;li&gt; &lt;a href="https://kubernetes-sigs.github.io/metrics-server/"&gt;Kubernetes 指标服务器&lt;/a&gt;。&lt;/li&gt;&lt;li&gt; &lt;a href="https://github.com/kubernetes/autoscaler/releases"&gt;Kubernetes Cluster Autoscaler&lt;/a&gt; Cluster Autoscaler 与 Kubernetes 调度程序紧密耦合，并且在升级集群时始终需要升级。查找与您的 Kubernetes 次要版本对应的最新版本的地址。&lt;/li&gt;&lt;li&gt;&lt;a href="https://karpenter.sh/v0.27.3/faq/#which-versions-of-kubernetes-does-karpenter-support"&gt;卡彭特。&lt;/a&gt;&lt;/li&gt;&lt;li&gt;服务网格，例如&lt;a href="https://github.com/linkerd/linkerd2"&gt;Linkerd2&lt;/a&gt;或&lt;a href="https://github.com/istio/istio"&gt;Istio&lt;/a&gt; 。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;一些附加组件（例如 VPC CNI 插件和 kube-proxy）可以通过 Amazon EKS 附加组件安装，这提供了通过 EKS API 进行附加组件管理的替代方法。您可能会考虑以这种方式管理这些插件，因为这种方法使您可以使用单个命令更新插件版本。例如：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;aws eks update-addon —cluster-name my-cluster —addon-name vpc-cni —addon-version version-number \&lt;br /&gt;&lt;br /&gt; --service-account-role-arn arn:aws:iam::111122223333:role/role-name —configuration-values &amp;#39;{}&amp;#39; —resolve-conflicts PRESERVE&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要检查您是否有任何 EKS 附加组件，请输入：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;aws eks list-addons --cluster-name &amp;lt;cluster name&amp;gt; --output table&lt;/code&gt;&lt;/pre&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;— — — — — — — — —&lt;br /&gt; |   ListAddons   |&lt;br /&gt; +----------------+&lt;br /&gt; || addons ||&lt;br /&gt; |+--------------+|&lt;br /&gt; ||  coredns ||&lt;br /&gt; ||  kube-proxy  ||&lt;br /&gt; ||  vpc-cni ||&lt;br /&gt; |+--------------+|&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;注意：&lt;/em&gt;&lt;/strong&gt;在控制平面升级期间，Amazon 不会自动升级 EKS 附加组件。您必须启动 EKS 附加更新并选择要更新到的版本。确保使用&lt;a href="https://aws.github.io/aws-eks-best-practices/upgrades/#upgrade-add-ons-and-components-using-the-kubernetes-api"&gt;有关附加版本兼容性的指南从所有可用版本中选择兼容版本。&lt;/a&gt;请记住，您一次只能升级 Amazon EKS 插件一个次要版本。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;验证 EKS 要求&lt;/h2&gt;&lt;p&gt;AWS 需要您账户中的多个特定资源来升级控制平面，包括：&lt;/p&gt;&lt;ul&gt;&lt;li&gt; &lt;strong&gt;IP 地址：&lt;/strong&gt; Amazon EKS 要求您在创建集群时指定的子网中最多有五个可用的 IP 地址。&lt;br /&gt;&lt;br /&gt;确保您的子网有足够的 IP 地址来升级集群：&lt;br /&gt;&lt;br /&gt; &lt;code&gt;CLUSTER=&amp;lt;cluster name&amp;gt;&lt;br /&gt; aws ec2 describe-subnets --subnet-ids \&lt;br /&gt; $(aws eks describe-cluster --name ${CLUSTER} \&lt;br /&gt; --query &amp;#39;cluster.resourcesVpcConfig.subnetIds&amp;#39; \&lt;br /&gt; --output text) \&lt;br /&gt; --query &amp;#39;Subnets[*].[SubnetId,AvailabilityZone,AvailableIpAddressCount]&amp;#39; \&lt;br /&gt; --output table&lt;br /&gt; ----------------------------------------------------&lt;br /&gt;&lt;br /&gt; |              DescribeSubnets             |&lt;br /&gt;&lt;br /&gt; +---------------------------+--------------+-------+&lt;br /&gt;&lt;br /&gt; |  subnet-0ce25bacdb030ce4f |  us-west-2a  |  8136 |&lt;br /&gt;&lt;br /&gt; |  subnet-0c173097d592e96e4 |  us-west-2c  |  8051 |&lt;br /&gt;&lt;br /&gt; |  subnet-06a36d93ad471d420 |  us-west-2b  |  8127 |&lt;br /&gt;&lt;br /&gt; +---------------------------+--------------+-------+&lt;/code&gt; （您可以使用&lt;a href="https://github.com/aws/amazon-vpc-cni-k8s/blob/master/cmd/cni-metrics-helper/README.md"&gt;VPC CNI Metrics Helper&lt;/a&gt;为 Virtual Private Cloud (VPC) 指标创建 CloudWatch 仪表板。）&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt; &lt;strong&gt;EKS IAM：&lt;/strong&gt;控制平面身份访问管理 (IAM) 角色必须位于具有必要权限的账户中。&lt;/li&gt;&lt;li&gt; &lt;strong&gt;EKS 安全组：&lt;/strong&gt;控制平面主安全组必须在具有所需访问规则的账户中可用。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;集群 IAM 角色权限：&lt;/strong&gt;如果您在集群中启用了秘密加密，请确保集群 IAM 角色有权使用 AWS Key Management Service (AWS KMS) 密钥。&lt;/li&gt;&lt;/ul&gt;&lt;h2 class="wp-block-heading"&gt;用于 EKS 升级的开源工具&lt;/h2&gt;&lt;p&gt;&lt;a href="http://cncf.io/"&gt;云原生生态系统&lt;/a&gt;不断扩展和成熟，因此有很多开源工具可帮助团队导航 Kubernetes 升级也就不足为奇了。以下是一些可帮助您进行 EKS 升级的选项，以及一些示例和说明。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;冥王星&lt;/h3&gt;&lt;p&gt;&lt;a href="https://pluto.docs.fairwinds.com/"&gt;Pluto&lt;/a&gt;是 Fairwinds 的开源工具，用于查找已弃用的 apiVersions 的使用情况。 Pluto 支持扫描实时集群、清单文件和 helm 图表。它还提供了一个 GitHub Action，您可以将其包含在 CI 流程中。 Pluto 会告诉您是否可以针对 API 路径安全升级，检查您是否在配置或 Helm 图表中调用已弃用或已删除的 API 路径。您可以使用以下命令针对本地文件运行 Pluto：&lt;/p&gt;&lt;p&gt; &lt;code&gt;pluto detect-files&lt;/code&gt;&lt;/p&gt;&lt;p&gt;您还可以使用以下命令检查 Helm：&lt;/p&gt;&lt;p&gt; &lt;code&gt;pluto detect-helm -owide&lt;/code&gt;&lt;/p&gt;&lt;p&gt;将其添加到 CI 中非常容易；这对于管理许多集群的人很有帮助。&lt;/p&gt;&lt;h4 class="wp-block-heading"&gt; helm 和 API 资源（集群内）&lt;/h4&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;$ pluto detect-all-in-cluster -o wide 2&amp;gt;/dev/null&lt;br /&gt;&lt;br /&gt; NAME              NAMESPACE   KIND                VERSION                     REPLACEMENT            DEPRECATED   DEPRECATED IN   REMOVED   REMOVED IN&lt;br /&gt;&lt;br /&gt;  testing/viahelm   viahelm     Ingress             networking.k8s.io/v1beta1   networking.k8s.io/v1   true         v1.19.0         true      v1.22.0&lt;br /&gt;&lt;br /&gt;     webapp            default     Ingress             networking.k8s.io/v1beta1   networking.k8s.io/v1   true         v1.19.0         true      v1.22.0&lt;br /&gt;&lt;br /&gt;     eks.privileged       PodSecurityPolicy   policy/v1beta1                                     true         v1.21.0         false     v1.25.0&lt;br /&gt;&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;这结合了所有可用的集群内检测，显示 Helm 版本和 API 资源的结果。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;NAME    KIND            VERSION          REPLACEMENT   REMOVED   DEPRECATED   REPL AVAIc&lt;br /&gt; eks.privileged   PodSecurityPolicy   policy/v1beta1                 false     true         true&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一旦确定哪些工作负载和清单需要更新，您可能会发现需要更改清单文件中的资源版本（例如，将networking.k8s.io/v1beta1更改为networking.k8s.io/v1）。这可能还需要您更新资源规范。您可能需要进行额外的研究，具体取决于您要替换的资源。&lt;/p&gt;&lt;p&gt;如果资源类型保持不变，仅需要更新 API 版本，您可以使用&lt;code&gt;kubectl-convert&lt;/code&gt;命令自动转换清单文件。例如，如果要将旧的 Deployment 转换为 apps/v1，请键入以下命令：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;kubectl-convert -f &amp;lt;file&amp;gt; --output-version &amp;lt;group&amp;gt;/&amp;lt;version&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;如果您想了解更多信息，请参阅 Kubernetes 网站上的&lt;a href="https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/#install-kubectl-convert-plugin"&gt;安装 kubectl Convert 插件&lt;/a&gt;。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;诺瓦&lt;/h3&gt;&lt;p&gt;&lt;a href="https://www.fairwinds.com/blog/find-outdated-helm-charts-with-nova"&gt;Nova&lt;/a&gt;是 Fairwinds 的另一个开源实用程序，可帮助您检查 Helm 版本以查看是否需要升级。通常，CNI 和其他依赖项随 Helm 一起安装。 Nova 是一种快速方法，您可以使用它来确保您运行的是最新版本。与往常一样，请检查补丁说明以验证对您目标版本的支持。&lt;/p&gt;&lt;p&gt;安装 golang 二进制文件并针对您的集群运行它。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;$ go install github.com/fairwindsops/nova@latest&lt;br /&gt; $ nova find&lt;br /&gt; Release Name      Installed    Latest     Old       Deprecated ============      =========    ======     ===       ==========&lt;br /&gt; cert-manager      v0.11.0      v0.15.2    true      false&lt;br /&gt; insights-agent    0.21.0       0.21.1     true      false&lt;br /&gt; grafana           2.1.3        3.1.1      true      false&lt;br /&gt; metrics-server    2.8.8        2.11.1     true      false&lt;br /&gt;&lt;br /&gt; nginx-ingress     1.25.0       1.40.3     true      false&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要检查过时的容器映像而不是 helm 版本：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;$ nova find --container&lt;br /&gt; Container Name                              Current Version    Old     Latest     Latest Minor     Latest Patch&lt;br /&gt; ==============                              ===============    ===     ======     =============    =============&lt;br /&gt; k8s.gcr.io/coredns/coredns                  v1.8.0             true    v1.8.6     v1.8.6           v1.8.6&lt;br /&gt; k8s.gcr.io/etcd                             3.4.13-0           true    3.5.3-0    3.4.13-0         3.4.13-0&lt;br /&gt; k8s.gcr.io/kube-apiserver                   v1.21.1            true    v1.23.6    v1.23.6          v1.21.12&lt;br /&gt; k8s.gcr.io/kube-controller-manager          v1.21.1            true    v1.23.6    v1.23.6          v1.21.12&lt;br /&gt; k8s.gcr.io/kube-proxy                       v1.21.1            true    v1.23.6    v1.23.6          v1.21.12&lt;br /&gt; k8s.gcr.io/kube-scheduler                   v1.21.1            true    v1.23.6    v1.23.6          v1.21.12&lt;br /&gt;&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 class="wp-block-heading"&gt;库贝普格&lt;/h3&gt;&lt;p&gt;这个开源工具的正式名称为&lt;code&gt;&lt;a href="https://github.com/rikatz/kubepug"&gt;KubePug/Deprecations&lt;/a&gt;&lt;/code&gt; ，旨在帮助用户评估其 K8s 集群的运行状况和性能。它充当 kubectl 插件并包含以下功能：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;下载生成的 data.json 文件，其中包含指定 Kubernetes 版本的 API 弃用信息。&lt;/li&gt;&lt;li&gt;扫描正在运行的 Kubernetes 集群，确定是否有任何对象会受​​到折旧的影响。&lt;/li&gt;&lt;li&gt;向用户显示受影响的对象。&lt;/li&gt;&lt;/ol&gt;&lt;h4 class="wp-block-heading"&gt;特征&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;使用&lt;code&gt;kubeconfig&lt;/code&gt;或活动集群针对 Kubernetes 集群运行。&lt;/li&gt;&lt;li&gt;可以针对一组不同的清单或文件执行。&lt;/li&gt;&lt;li&gt;允许您指定用于验证的目标 Kubernetes 版本。&lt;/li&gt;&lt;li&gt;提供有关您应采用的替代 API 的信息。&lt;/li&gt;&lt;li&gt;根据目标集群版本，包含有关已弃用或删除 API 的版本的详细信息。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;运行以下命令将 kubepug 安装为 Krew 插件：&lt;/p&gt;&lt;p&gt; &lt;code&gt;kubectl krew install deprecations&lt;/code&gt;&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;埃克苏普&lt;/h3&gt;&lt;p&gt;&lt;a href="https://github.com/clowdhaus/eksup"&gt;eksup&lt;/a&gt;是一个命令行界面 (CLI)，旨在为用户提供全面的信息和工具来准备集群进行升级。它可以通过提供相关的见解和操作来帮助简化升级过程。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;A CLI to aid in upgrading Amazon EKS clusters Usage: eksup &amp;lt;COMMAND&amp;gt;&lt;br /&gt; Commands: analyze  Analyze an Amazon EKS cluster for potential upgrade issues&lt;br /&gt; create   Create artifacts using the analysis data&lt;br /&gt; help     Print this message or the help of the given subcommand(s) Options:&lt;br /&gt; -h, --help     Print help -V, --version  Print version&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h4 class="wp-block-heading"&gt;功能&lt;/h4&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;分析集群：&lt;/strong&gt;使用 eksup 根据下一个 Kubernetes 版本评估您的集群，以确定可能影响升级过程的问题。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;生成 Playbook：&lt;/strong&gt;根据集群的分析结果生成概述升级步骤的自定义 Playbook，包括必要的操作和补救措施。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;编辑 Playbook：&lt;/strong&gt;生成的 Playbook 是可编辑的，使您能够调整升级步骤，使其符合您的集群配置和业务需求。您还可以记录在升级过程中获得的见解。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;加强协作：&lt;/strong&gt;升级通常首先在非生产集群上启动，因此您可以捕获在此阶段发现的任何其他步骤或见解，并使用它们来改进生产集群的升级过程。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;保留历史文物：&lt;/strong&gt;您可以保留您的剧本作为历史参考。这有助于您确保每个升级周期都利用之前的经验教训，从而提高未来升级的效率。&lt;/li&gt;&lt;/ol&gt;&lt;h3 class="wp-block-heading"&gt;走不走&lt;/h3&gt;&lt;p&gt;&lt;a href="https://github.com/FairwindsOps/GoNoGo"&gt;GoNoGo&lt;/a&gt;是 Fairwinds 的另一个开源工具。它可以帮助您定义和发现随 Helm 安装的附加组件是否可以安全升级。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;gonogo --help The Kubernetes Add-On Upgrade Validation Bundle is a spec that can be used to define and then discover if an add-on upgrade is safe to perform.&lt;br /&gt; Usage:  gonogo [flags]  gonogo [command]&lt;br /&gt; Available Commands:  check       Check for Helm releases that can be updated  completion  Generate the autocompletion script for the specified shell  help        Help about any command  version     Prints the current version of the tool.&lt;br /&gt; Flags:&lt;br /&gt;  -h, --help      help for gonogo  -v, --v Level   number for the log level verbosity&lt;br /&gt; Use &amp;quot;gonogo [command] --help&amp;quot; for more information about a command.&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 class="wp-block-heading"&gt;维莱罗&lt;/h3&gt;&lt;p&gt;您可以使用的另一个社区支持的开源工具是&lt;a href="https://velero.io/"&gt;Velero&lt;/a&gt; ，它使您能够创建现有集群的备份，然后将备份应用到新集群。 Velero 备份中不包含 AWS 资源（包括 IAM），因此您需要重新创建它们。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;改进 EKS 升级流程的附加指南&lt;/h2&gt;&lt;h3 class="wp-block-heading"&gt;配置&lt;code&gt;PodDisruptionBudgets&lt;/code&gt;和&lt;code&gt;topologySpreadConstraints&lt;/code&gt;&lt;/h3&gt;&lt;p&gt;为了确保您的工作负载在数据平面升级期间保持可用，您需要适当配置&lt;code&gt;PodDisruptionBudgets&lt;/code&gt;和&lt;code&gt;topologySpreadConstraints&lt;/code&gt; 。请记住，并非所有工作负载都需要相同级别的可用性，因此请评估您的工作负载的规模和要求。&lt;/p&gt;&lt;p&gt;如果工作负载分布在具有拓扑分布的多个可用区和主机上，则可以提高在不中断的情况下迁移到新数据平面的可能性。&lt;/p&gt;&lt;p&gt;这是一个工作负载配置示例，可保证 80% 的副本始终可用，从而有效地将副本分布在区域和主机之间：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;# Source: basic-demo/templates/deployment.yaml apiVersion: apps/v1 kind: Deployment metadata:  name: demo-basic-demo  labels:    app.kubernetes.io/name: basic-demo    app.kubernetes.io/instance: demo spec:  selector:    matchLabels:      app.kubernetes.io/name: basic-demo      app.kubernetes.io/instance: demo  template:    metadata:      labels:        app.kubernetes.io/name: basic-demo        app.kubernetes.io/instance: demo    spec:      topologySpreadConstraints:        - maxSkew: 1          topologyKey: kubernetes.io/hostname          whenUnsatisfiable: ScheduleAnyway          - maxSkew: 1            topologyKey: zone            whenUnsatisfiable: DoNotSchedule      containers:        - name: basic-demo          image: &amp;quot;quay.io/fairwinds/docker-demo:1.2.0&amp;quot;          imagePullPolicy: Always&lt;br /&gt;          ports:            - name: http              containerPort: 8080              protocol: TCP&lt;br /&gt; # Source: basic-demo/templates/pdb.yaml apiVersion: policy/v1 kind: PodDisruptionBudget metadata:  name: demo-basic-demo spec:  minAvailable: 80%  selector:    matchLabels:      app.kubernetes.io/name: basic-demo      app.kubernetes.io/instance: demo&lt;br /&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 class="wp-block-heading"&gt; AWS 弹性中心&lt;/h3&gt;&lt;p&gt;&lt;a href="https://aws.amazon.com/resilience-hub/"&gt;AWS Resilience Hub&lt;/a&gt;现在包括&lt;a href="https://docs.aws.amazon.com/resilience-hub/latest/userguide/enabling-eks-in-arh.html"&gt;EKS&lt;/a&gt;作为受支持的资源。这提供了一个可以定义、验证和跟踪应用程序弹性的单一位置。这有助于您避免因基础设施、软件或运营中断造成的不必要的停机。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;使用托管节点组或 Karpenter&lt;/h3&gt;&lt;p&gt; Managed Node Groups 和 Karpenter 都采用不同的方法来简化节点升级。托管节点组可自动执行节点配置和生命周期管理，这意味着您可以通过单个操作创建、自动更新或终止节点。&lt;/p&gt;&lt;p&gt; Karpenter 使用最新的兼容 EKS 优化亚马逊系统映像 (AMI) 自动创建新节点。当 EKS 发布更新的 EKS 优化 AMI 或您升级集群时，Karpenter 会自动开始使用这些映像。 &lt;a href="https://aws.github.io/aws-eks-best-practices/upgrades/#enable-node-expiry-for-karpenter-managed-nodes"&gt;它还使用 Node Expiry 来更新节点。&lt;/a&gt;您可以&lt;a href="https://karpenter.sh/docs/concepts/node-templates/"&gt;将 Karpenter 配置为使用自定义 AMI&lt;/a&gt; ，但请记住，如果这样做，您就要对 kubelet 的版本负责。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;自动升级自管理节点组&lt;/h3&gt;&lt;p&gt;自我管理节点组是部署在您的账户中并附加到 EKS 服务外部集群的 Amazon Elastic Compute Cloud (EC2) 实例。通常，这些节点组由某种形式的自动化工具部署和管理，例如&lt;a href="https://eksctl.io/usage/nodegroup-upgrade/"&gt;eksctl&lt;/a&gt; 、 &lt;a href="https://kops.sigs.k8s.io/operations/updates_and_upgrades/"&gt;kOps&lt;/a&gt;和&lt;a href="https://aws-ia.github.io/terraform-aws-eks-blueprints/node-groups/#self-managed-node-groups"&gt;EKS Blueprints&lt;/a&gt; 。请参阅工具文档来升级自管理节点组。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;备份集群&lt;/h3&gt;&lt;p&gt;毫不奇怪，新版本的 Kubernetes 为您的 Amazon EKS 集群带来了重大变化。请记住，一旦升级集群，就无法降级。并且您只能为 EKS 当前支持的 Kubernetes 版本创建新集群。如果您担心此风险，您可能需要考虑在升级之前备份集群。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;随时了解 K8s 版本&lt;/h3&gt;&lt;p&gt;尽管您可能觉得自己只有时间关注 Kubernetes 的当前版本，但监控新版本并识别重大更改非常重要。例如，从 1.23 迁移到 1.24 最重要的变化是从 kubelet 中删除了 Dockershim。 Dockershim 是 Kubernetes 和 Docker 之间的适配器。此代码嵌入 kubelet 中，以允许 kubelet 与 docker 守护进程对话（即使 docker 守护进程不符合开放容器计划 (OCI)），但在 1.24 中已删除。这意味着 kubelet 现在在节点上启动和管理容器时使用容器运行时接口 (CRI) 直接与容器运行时通信。自版本 1.24 起，EKS AMI 仅将&lt;a href="https://containerd.io/"&gt;containerd&lt;/a&gt;作为运行时。为此类重大变化做准备需要额外的时间和规划。&lt;/p&gt;&lt;p&gt;查看您计划升级到的版本的所有记录的修改，记下任何所需的升级过程。请确保您还关注专为 Amazon EKS 托管集群定制的要求或流程（查看&lt;a href="https://github.com/kubernetes/kubernetes/tree/master/CHANGELOG"&gt;Kubernetes 变更日志&lt;/a&gt;）。这种方法将帮助您实现更顺畅的升级过程并最大限度地减少潜在的中断。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt; Kubernetes 的重要变化&lt;/h2&gt;&lt;p&gt;下面列出了从 v1.24 开始的 Kubernetes 版本中一些最知名的更改（其中许多是破坏性的）。这不是一个完整的列表;请参阅您的 Kubernetes 版本的发行说明。&lt;/p&gt;&lt;p&gt;库伯内特 v1.24&lt;/p&gt;&lt;ul&gt;&lt;li&gt;从 Kubelet 中删除 Dockershim。 Kubernetes 博客有一篇关于什么、如何以及为什么的精彩&lt;a href="https://kubernetes.io/blog/2022/02/17/dockershim-faq/"&gt;文章&lt;/a&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;库伯内特 v1.25&lt;/p&gt;&lt;ul&gt;&lt;li&gt;不再提供多个已弃用的 API。请参阅官方&lt;a href="https://kubernetes.io/docs/reference/using-api/deprecation-guide/#v1-25"&gt;Kubernetes 弃用 API 迁移指南&lt;/a&gt;。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;库伯内特 v1.26&lt;/p&gt;&lt;ul&gt;&lt;li&gt;不再提供多个已弃用的 API。请参阅官方&lt;a href="https://kubernetes.io/docs/reference/using-api/deprecation-guide/#v1-26"&gt;Kubernetes 弃用 API 迁移指南&lt;/a&gt;。&lt;/li&gt;&lt;li&gt; GlusterFS 树内存储驱动程序已被删除。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;库伯内特 v1.27&lt;/p&gt;&lt;ul&gt;&lt;li&gt; AWS 的树内存储提供程序（以及 EBS 存储插件）已被删除。您必须使用外部 CSI 驱动程序。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;库伯内特 v1.28&lt;/p&gt;&lt;ul&gt;&lt;li&gt;树内 CephFS 卷插件已弃用。请迁移到外部驱动程序。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;库伯内特 v1.29&lt;/p&gt;&lt;ul&gt;&lt;li&gt;只有 Kubeadm 发生变化。&lt;/li&gt;&lt;/ul&gt;&lt;h3 class="wp-block-heading"&gt; Kubernetes v1.29 的主要变化&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;ReadWriteOncePod PersistentVolume 访问模式（ &lt;a href="https://github.com/kubernetes/community/tree/master/sig-storage"&gt;SIG 存储&lt;/a&gt;）&lt;/li&gt;&lt;li&gt;节点卷扩展 秘密支持CSI驱动（ &lt;a href="https://github.com/kubernetes/community/tree/master/sig-storage"&gt;SIG存储&lt;/a&gt;）&lt;/li&gt;&lt;li&gt; KMS v2 静态加密普遍可用 ( &lt;a href="https://github.com/kubernetes/community/tree/master/sig-auth"&gt;SIG Auth&lt;/a&gt; )&lt;/li&gt;&lt;li&gt;节点生命周期与污点管理分离（ &lt;a href="https://github.com/kubernetes/community/tree/master/sig-scheduling"&gt;SIG 调度&lt;/a&gt;）&lt;/li&gt;&lt;li&gt;清理遗留的基于 Secret 的 ServiceAccount 令牌 ( &lt;a href="https://github.com/kubernetes/community/tree/master/sig-auth"&gt;SIG Auth&lt;/a&gt; )&lt;/li&gt;&lt;/ul&gt;&lt;h3 class="wp-block-heading"&gt; Kubernetes v1.30 的主要变化&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;用于动态资源分配的结构化参数（ &lt;a href="https://kep.k8s.io/4381"&gt;KEP-4381&lt;/a&gt; ）&lt;/li&gt;&lt;li&gt;节点内存交换支持 ( &lt;a href="https://kep.k8s.io/2400"&gt;KEP-2400&lt;/a&gt; )&lt;/li&gt;&lt;li&gt;支持 Pod 中的用户命名空间 ( &lt;a href="https://kep.k8s.io/127"&gt;KEP-127&lt;/a&gt; )&lt;/li&gt;&lt;li&gt;结构化授权配置（ &lt;a href="https://kep.k8s.io/3221"&gt;KEP-3221&lt;/a&gt; ）&lt;/li&gt;&lt;li&gt;基于容器资源的 Pod 自动缩放 ( &lt;a href="https://kep.k8s.io/1610"&gt;KEP-1610&lt;/a&gt; )&lt;/li&gt;&lt;li&gt;用于准入控制的 CEL ( &lt;a href="https://kep.k8s.io/3488"&gt;KEP-3488&lt;/a&gt; )&lt;/li&gt;&lt;/ul&gt;&lt;h2 class="wp-block-heading"&gt;安全升级EKS集群&lt;/h2&gt;&lt;p&gt;希望本指南中概述的信息对您有用。持续升级 Kubernetes 需要研究和努力；您需要确保有时间测试每个次要版本的环境。如果您遵循这些步骤，您应该可以很好地升级 EKS 集群。如果您在下次 EKS 升级方面需要帮助，&lt;a href="https://www.fairwinds.com/eks-migration"&gt;请联系&lt;/a&gt;。我们的团队拥有 Kubernetes 专业知识，可以让您轻松升级，同时使您的 Kubernetes 基础设施更加高效，从而节省您的时间和金钱。 &lt;/p&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;</description><pubDate>Sun, 12 May 2024 16:00:00 GMT</pubDate><guid isPermaLink="true">https://www.cncf.io/blog/2024/05/13/a-step-by-step-guide-to-securely-upgrading-your-eks-clusters/</guid></item><item><title>【A new course: how to use Dapr and WebAssembly to build scalable and secure cloud apps】新课程：如何使用 Dapr 和 WebAssembly 构建可扩展且安全的云应用程序</title><link>https://www.cncf.io/blog/2024/05/10/a-new-course-how-to-use-dapr-and-webassembly-to-build-scalable-and-secure-cloud-apps/</link><description>&lt;p&gt;如果需要扩展您的技能集并掌握相关新技术，Linux 基础培训和认证以及云原生计算基金会推出了新课程&lt;a href="https://training.linuxfoundation.org/training/dapr-with-webassembly-lfd233/"&gt;Dapr with WebAssembly (LFD233)。&lt;/a&gt;&lt;/p&gt;&lt;p&gt;在技​​术比以往任何时候都发展得更快的时代，认证对于寻求扩展技能、获得晋升甚至寻找新角色的开发人员和 IT 专业人员来说可以发挥关键作用。 &lt;a href="https://home.pearsonvue.com/About/News/2023/2023-Value-of-IT-Certification-Candidate-Report.aspx"&gt;2023 年一项关于 IT 认证价值的调查&lt;/a&gt;数据发现，37% 的受访者在获得新认证后获得加薪，27% 的受访者获得晋升。&lt;/p&gt;&lt;p&gt; Dapr 与 WebAssembly 非常适合希望深入了解开源技术如何协同工作的开发人员、云工程师和 IT 专业人员。参与者将学习如何利用 Dapr 和 WebAssembly 更高效、更安全地开发软件，着眼于创建可在不同环境中运行的尖端应用程序。&lt;/p&gt;&lt;p&gt; Dapr 与 WebAssembly 允许参与者以自己的速度进行“电子学习”，同时享有动手实验室和讨论论坛等更传统教学的所有好处。课程时长为 7 小时。&lt;/p&gt;&lt;p&gt;涵盖的主题包括：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;构建 WASM Web 服务&lt;/li&gt;&lt;li&gt;Dapr 与 WasmEdge&lt;/li&gt;&lt;li&gt;状态管理和 Pub Sub&lt;/li&gt;&lt;li&gt; Kubernetes 上的 Dapr 应用程序&lt;/li&gt;&lt;li&gt;配置与机密管理&lt;/li&gt;&lt;li&gt;输入和输出绑定&lt;/li&gt;&lt;li&gt;在 Dapr 中运行 WASM&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;成功完成课程的学生将获得证书和数字徽章。 &lt;/p&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;</description><pubDate>Thu, 09 May 2024 16:00:00 GMT</pubDate><guid isPermaLink="true">https://www.cncf.io/blog/2024/05/10/a-new-course-how-to-use-dapr-and-webassembly-to-build-scalable-and-secure-cloud-apps/</guid></item><item><title>【Kyverno 1.12 released】Kyverno 1.12 发布</title><link>https://www.cncf.io/blog/2024/05/10/kyverno-1-12-released/</link><description>&lt;p&gt;&lt;em&gt;项目帖子最初发布在&lt;/em&gt;&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/"&gt;&lt;em&gt;Kyverno 的博客&lt;/em&gt;&lt;/a&gt;上&lt;/p&gt;&lt;p&gt;Kyverno 1.12 发布了新的替代报告服务器、全局上下文条目、CLI 中的 Kyverno JSON、性能优化、增强的 ValidatingAdmissionPolicy 和 PolicyException 支持等等！ &lt;/p&gt;&lt;figure class="wp-block-image"&gt;&lt;img alt="基韦尔诺" src="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/kyverno-horizontal.png" /&gt;&lt;/figure&gt;&lt;p&gt; Kyverno 团队很高兴地宣布在 KubeCon EU 2024 之后推出 1.12 版本。我们在会议期间与 Kyverno 用户的互动非常富有洞察力，许多人对这个最新版本中引入的功能表示热切期待。合并了 330 多个拉取请求，并有 32 位新贡献者加入，我们衷心感谢 Kyverno 社区的宝贵贡献。欢迎加入我们，深入研究 1.12 版本的令人兴奋的新功能。&lt;/p&gt;&lt;h2 class="wp-block-heading" id="key-new-features-in-kyverno-112"&gt; Kyverno 1.12 中的主要新功能&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/#key-new-features-in-kyverno-112"&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;此版本引入了对策略报告替代存储的支持，将 Kyverno JSON 引入 CLI，并包括策略异常处理、ValidatingAdmissionPolicy 和 pod 安全子规则方面的各种其他增强功能。性能得到了显着改进，确保了大型系统的弹性。&lt;/p&gt;&lt;h3 class="wp-block-heading" id="reports-server---alternative-reports-storage"&gt;报告服务器 – 替代报告存储&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/#reports-server---alternative-reports-storage"&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;策略报告对于像 Kyverno 这样的工具至关重要，但在大型集群中，etcd 的存储限制可能会阻碍高效的策略管理。 Reports Server 旨在应对这些挑战并简化 Kubernetes 环境中的策略报告。报告服务器提供了用于存储策略报告和集群策略报告的可扩展解决方案。它将报告从 etcd 中移出并将其存储在 PostgreSQL 数据库实例中。&lt;/p&gt;&lt;p&gt; Reports Server 提供了一个简单的解决方案。它利用带有数据库的扩展 API 服务器与 Kubernetes 无缝集成，为存储和检索策略报告提供专用空间。 &lt;/p&gt;&lt;figure class="wp-block-image"&gt;&lt;img alt="报告服务器" src="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/report-server.png" /&gt;&lt;/figure&gt;&lt;p&gt;报表服务器的优点：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;可扩展性：克服了 etcd 的存储限制，允许在 Kubernetes 集群内实现无缝可扩展性。&lt;/li&gt;&lt;li&gt;性能：通过将策略报告存储在专用数据库中，报表服务器提高了集群性能，特别是在繁重的操作期间。&lt;/li&gt;&lt;li&gt;简化查询：与 etcd 相比，提供增强的查询功能，简化对策略报告的访问。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在 GitHub 上探索 Reports Server 并为其开发做出贡献： &lt;a href="https://github.com/kyverno/reports-server"&gt;https://github.com/kyverno/reports-server&lt;/a&gt; 。&lt;/p&gt;&lt;h3 class="wp-block-heading" id="global-context-entry"&gt;全局上下文条目&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/#global-context-entry"&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt; Kyverno 的全局上下文功能通过启用资源缓存或外部 API 调用以实现跨策略的有效引用，增强了 Kubernetes 环境中的策略执行。让我们深入研究一下此功能如何增强策略管理的灵活性和性能。&lt;/p&gt;&lt;p&gt;全局上下文的基石是全局上下文条目，这是 Kyverno 引入的自定义资源类型。通过全局上下文条目，用户可以在全局范围内声明资源或 API 调用数据，而与任何特定策略无关。然后可以根据需要在策略中轻松引用这些条目。&lt;/p&gt;&lt;h4 class="wp-block-heading" id="types-of-global-context-entries"&gt;全局上下文条目的类型&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/#types-of-global-context-entries"&gt;&lt;/a&gt;&lt;/h4&gt;&lt;h5 class="wp-block-heading" id="kubernetes-resource"&gt;库伯内特资源&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/#kubernetes-resource"&gt;&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;用户可以引用任何 Kubernetes 资源（可选地在特定命名空间内），以使用其最新状态填充缓存。这对于需要跨多个策略访问资源最新状态的场景特别有用。&lt;/p&gt;&lt;p&gt;例子：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-yaml" lang="yaml"&gt;apiVersion: kyverno.io/v2alpha1&lt;br /&gt; kind: GlobalContextEntry&lt;br /&gt; metadata:&lt;br /&gt; name: deployments&lt;br /&gt; spec:&lt;br /&gt; kubernetesResource:&lt;br /&gt; group: apps&lt;br /&gt; version: v1&lt;br /&gt; resource: deployments&lt;br /&gt; namespace: test-globalcontext&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/"&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;注意&lt;/em&gt;：处理集群范围的资源时，请将命名空间字段留空。&lt;/p&gt;&lt;h5 class="wp-block-heading" id="api-call"&gt; API调用&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/#api-call"&gt;&lt;/a&gt;&lt;/h5&gt;&lt;p&gt;用户可以定义外部 API 调用，指定 URL、用于证书验证的 CA 捆绑包以及刷新间隔，以确保缓存的数据保持最新。这使得策略能够动态地从外部源获取数据并利用它来执行。&lt;/p&gt;&lt;p&gt;例子：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-yaml" lang="yaml"&gt;apiVersion: kyverno.io/v2alpha1&lt;br /&gt; kind: GlobalContextEntry&lt;br /&gt; metadata:&lt;br /&gt; name: deployments&lt;br /&gt; spec:&lt;br /&gt; apiCall:&lt;br /&gt; urlPath: &amp;quot;/apis/apps/v1/namespaces/test-globalcontext/deployments&amp;quot;&lt;br /&gt; refreshInterval: 10s&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/"&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;注意&lt;/em&gt;：请务必注意 API 调用中潜在的数据过时情况，因为缓存会根据定义的刷新间隔定期更新。&lt;/p&gt;&lt;h4 class="wp-block-heading" id="integration-with-policies"&gt;与政策整合&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/#integration-with-policies"&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;全局上下文条目无缝集成到策略中，允许用户在其执行逻辑中利用缓存的数据。通过引用策略上下文中的全局上下文条目，用户可以利用预取的数据而无需冗余。&lt;/p&gt;&lt;p&gt;例子：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-yaml" lang="yaml"&gt;context: - name: deploymentCount globalReference: name: deployments&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/"&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;em&gt;注意&lt;/em&gt;：根据数据是源自 Kubernetes 资源还是 API 调用，用于操作数据的 JMESPath 表达式可能会有所不同。对于 Kubernetes 资源，使用&lt;code&gt;length(@)&lt;/code&gt;获取数组的长度，而对于返回列表的 API 调用，使用&lt;code&gt;items | length(@)&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;总之，Kyverno 中的 Global Context 使用户能够通过跨策略集中和重用数据来简化策略管理，从而提高 Kubernetes 环境中的效率和可维护性。&lt;/p&gt;&lt;h3 class="wp-block-heading" id="kyverno-json-in-cli"&gt; CLI 中的 Kyverno JSON&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/#kyverno-json-in-cli"&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;Kyverno JSON 与 Kyverno 1.11.0 大约同时推出，将 Kyverno 的功能扩展到 Kubernetes 之外。在最新的 1.12 版本中，Kyverno CLI 现在支持 Kyverno JSON 来验证任何 JSON 负载。&lt;/p&gt;&lt;p&gt;以下说明了如何在 Kyverno CLI 测试中使用新的&lt;code&gt;checks&lt;/code&gt;节：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-yaml" lang="yaml"&gt;&lt;em&gt;# ...&lt;/em&gt; checks: - match: resource: kind: Namespace metadata: name: hello-world-namespace policy: kind: ClusterPolicy metadata: name: sync-secret rule: name: sync-my-secret assert: status: pass&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/"&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;h3 class="wp-block-heading" id="policy-exception-enhancements"&gt;策略例外增强功能&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/#policy-exception-enhancements"&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt; PolicyExceptions 现在支持&lt;code&gt;conditions{}&lt;/code&gt;块（可选），该块使用与&lt;code&gt;preconditions&lt;/code&gt;和&lt;code&gt;deny&lt;/code&gt;规则中类似的通用表达式来查询所选资源的内容，以优化选择过程。&lt;/p&gt;&lt;p&gt;以下是检查 Pod/Deployment 是否具有特定标签的 PolicyException：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-yaml" lang="yaml"&gt;apiVersion: kyverno.io/v2beta1 kind: PolicyException metadata: name: container-exception spec: exceptions: - policyName: max-containers ruleNames: - max-two-containers - autogen-max-two-containers match: any: - resources: kinds: - Pod - Deployment conditions: any: - key: &amp;quot;{{ request.object.metadata.labels.color || &amp;#39;&amp;#39; }}&amp;quot; operator: Equals value: blue&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/"&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此外，PolicyException 可用于通过&lt;code&gt;podSecurity{}&lt;/code&gt;块定义 Pod 的豁免。它可用于定义不受策略约束的控制。&lt;/p&gt;&lt;p&gt;以下 PolicyException 使运行&lt;code&gt;nginx&lt;/code&gt;或&lt;code&gt;redis&lt;/code&gt;映像的容器免于遵循&lt;code&gt;Capabilities&lt;/code&gt;控制。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-yaml" lang="yaml"&gt;apiVersion: kyverno.io/v2beta1 kind: PolicyException metadata: name: pod-security-exception namespace: policy-exception-ns spec: exceptions: - policyName: psa ruleNames: - restricted match: any: - resources: namespaces: - delta podSecurity: - controlName: Capabilities images: - nginx* - redis*&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/"&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;此外，Kyverno CLI 支持通过使用&lt;code&gt;-e&lt;/code&gt;或&lt;code&gt;--exceptions&lt;/code&gt;标志传递策略异常清单，将 PolicyExceptions 与策略一起应用于资源。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-bash" lang="bash"&gt;kyverno apply /path/to/policy.yaml --resource /path/to/resource.yaml --exception /path/to/exception.yaml&lt;br /&gt;&lt;br /&gt;&lt;br /&gt;&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/"&gt;&lt;/a&gt;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;与给定异常匹配的资源将因此被&lt;code&gt;skip&lt;/code&gt; 。&lt;/p&gt;&lt;h3 class="wp-block-heading" id="validatingadmissionpolicy-in-cli-and-reports"&gt;在 CLI 和报告中验证录取策略&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/#validatingadmissionpolicy-in-cli-and-reports"&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;在 1.12 中，Kyverno CLI 现在支持将 ValidatingAdmissionPolicyBinding 以及策略定义应用于资源。此外，报告控制器由于应用 ValidatingAdmissionPolicy 及其与资源的绑定而生成报告。&lt;/p&gt;&lt;p&gt;以下是为 ValidatingAdmissionPolicy 及其绑定生成的报告片段：&lt;/p&gt;&lt;pre class="wp-block-code"&gt;&lt;code class=""&gt; apiVersion: wgpolicyk8s.io/v1alpha2 kind: PolicyReport metadata: labels: app.kubernetes.io/managed-by: kyverno namespace: staging-ns ownerReferences: - apiVersion: apps/v1 kind: Deployment name: deployment-3 results: - message: &amp;#39;failed expression: object.spec.replicas &amp;lt;= 5&amp;#39; policy: check-deployment-replicas properties: binding: check-deployment-replicas-binding result: fail source: ValidatingAdmissionPolicy scope: apiVersion: apps/v1 kind: Deployment name: deployment-3 namespace: staging-ns summary: error: 0 fail: 1 pass: 0 skip: 0 warn: 0&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt; YAML&lt;/p&gt;&lt;h3 class="wp-block-heading" id="fine-grained-podsecurity-validations"&gt;细粒度的 PodSecurity 验证&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/#fine-grained-podsecurity-validations"&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt; &lt;code&gt;validate.podSecurity&lt;/code&gt;子规则现在能够通过排除特定字段及其值来进一步分类排除项。这使您既可以使用简单的策略语言，又可以深入到漏斗的最低级别。例如，您可以通过这种方式强制执行 Pod 安全标准的整个基线配置文件，但仅从&lt;code&gt;initContainers&lt;/code&gt;列表中排除 Istio 和 Linkerd 的映像。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;apiVersion: kyverno.io/v1 kind: ClusterPolicy metadata: name: pod-security-standards spec: background: true validationFailureAction: Enforce rules: - name: baseline-service-mesh match: any: - resources: kinds: - Pod validate: podSecurity: level: baseline version: latest exclude: - controlName: Capabilities images: - &amp;quot;*/istio/proxyv2*&amp;quot; - &amp;quot;*/linkerd/proxy-init*&amp;quot; restrictedField: spec.initContainers[*].securityContext.capabilities.add values: - NET_ADMIN - NET_RAW&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt; YAML&lt;/p&gt;&lt;h3 class="wp-block-heading" id="increased-performance"&gt;提高性能&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/#increased-performance"&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt; Kyverno 1.12 进行了显着的性能增强，使其更适合大规模部署。让我们深入了解所面临的挑战、优化过程以及取得的令人印象深刻的成果。&lt;/p&gt;&lt;h4 class="wp-block-heading" id="facing-the-performance-bottlenecks"&gt;面对性能瓶颈&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/#facing-the-performance-bottlenecks"&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;虽然 Kyverno 在正常情况下运行良好，但在高负载下其性能会下降，从而影响大型集群。为了解决这个问题，Kyverno 团队与客户和社区合作，开始了优化性能的使命。&lt;/p&gt;&lt;h4 class="wp-block-heading" id="unveiling-the-culprits"&gt;揭开罪魁祸首&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/#unveiling-the-culprits"&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;使用 K6 进行负载测试并使用 Golang 的 pprof 工具进行分析，揭示了罪魁祸首：低效的上下文存储、重复的 JSON 操作以及事件处理期间过多的 goroutine 创建。&lt;/p&gt;&lt;h4 class="wp-block-heading" id="strategic-optimizations"&gt;战略优化&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/#strategic-optimizations"&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;有了这些见解，团队实施了有针对性的优化：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;上下文存储：用内存中的 Golang 映射替换 JSON 结构显着减少了开销。&lt;/li&gt;&lt;li&gt; JSON处理：切换到轻量级的jsoniter库提高了JSON处理效率。&lt;/li&gt;&lt;li&gt;事件处理：自定义观察程序函数优化了事件生成并最小化了 goroutine 开销。&lt;/li&gt;&lt;li&gt;策略匹配：重构匹配逻辑，优先考虑更简单的比较，从而加快处理速度。&lt;/li&gt;&lt;li&gt; Webhook 配置：细粒度配置最大限度地减少了不必要的 Kyverno 调用。&lt;/li&gt;&lt;/ul&gt;&lt;h4 class="wp-block-heading" id="the-performance-leap"&gt;性能飞跃&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/#the-performance-leap"&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;这些优化产生了显着的效果：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;平均延迟和 p95 延迟提高了 8 倍。&lt;/li&gt;&lt;li&gt;即使在高迭代次数下也能保持稳定的性能。 &lt;/li&gt;&lt;/ul&gt;&lt;figure class="wp-block-image"&gt;&lt;img alt="性能比较" src="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/perfomance-comparison.png" /&gt;&lt;/figure&gt;&lt;h4 class="wp-block-heading" id="continuous-improvement-through-automation"&gt;通过自动化持续改进&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/#continuous-improvement-through-automation"&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;为了确保这些改进的持久性，自动化 K6 负载测试现已集成到 CI/CD 管道中。这样可以及早发现潜在的回归并促进持续的性能优化。&lt;/p&gt;&lt;h4 class="wp-block-heading" id="kyverno-ready-for-large-scale-deployments"&gt; Kyverno：准备大规模部署&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/#kyverno-ready-for-large-scale-deployments"&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;这些进步巩固了 Kyverno 作为 Kubernetes 强大且可扩展的策略引擎的地位，能够轻松处理要求苛刻的工作负载。这些改进背后的协作努力体现了该项目致力于为 Kubernetes 社区提供安全高效的策略管理解决方案。&lt;/p&gt;&lt;h2 class="wp-block-heading" id="policy-reporter-ui-v2"&gt;政策报告者 UI V2 &lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/#policy-reporter-ui-v2"&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt; Policy Reporter UI v2 通过更新的技术堆栈和仪表板、详细信息页面和插件系统的完全重组开始了 alpha 阶段。&lt;/p&gt;&lt;h4 class="wp-block-heading" id="content-restructuring"&gt;内容重组&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/#content-restructuring"&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt; Policy Reporter UI v2 提供两种类型的视图：基于资源的视图和基于策略的视图。基于资源的仪表板取代了 Policy Reporter UI v1 中的旧报告视图。基于资源的仪表板的新焦点使其在更大的环境中更具可扩展性，并提高了整体性能。基于策略的仪表板是旧 UI 中仅限 Kyverno 的功能，并且只能通过额外的 Kyverno 插件使用。修订后的视图无需额外要求即可使用，并且可用于所有提供的来源。&lt;/p&gt;&lt;h4 class="wp-block-heading" id="new-plugin-system"&gt;新的插件系统&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/#new-plugin-system"&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt; 引入插件系统是为了提供额外的特定于引擎的功能，但旧的实现需要直接更改 UI 代码，这使得添加自定义插件非常困难。&lt;/p&gt;&lt;p&gt;新的插件系统需要具有预定义的 REST API（子）集的外部服务，其中每个插件都指向一个源并提供有关该源的附加信息。此附加信息会自动嵌入到现有视图中。这些工作流程使得开发和使用自定义插件成为可能，而无需在实际的用户界面上工作。&lt;/p&gt;&lt;h4 class="wp-block-heading" id="custom-boards"&gt;定制板&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/#custom-boards"&gt;&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;预定义视图的缺点之一是缺乏自定义选项。尽管它们提供了整个集群的概述，但公司内的团队通常只对命名空间和引擎报告的子集感兴趣。&lt;/p&gt;&lt;p&gt;自定义板是一种使用自定义的、特定于应用程序的视图扩展 UI 的方法，这些视图仅提供所需的信息子集。各种配置选项支持基于列表或选择器选择命名空间、选择显示的源以及激活或停用特定于集群的资源结果。&lt;/p&gt;&lt;h4 class="wp-block-heading" id="additional-features"&gt;附加功能&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/#additional-features"&gt;&lt;/a&gt;&lt;/h4&gt;&lt;ul&gt;&lt;li&gt; OpenIDConnect 和 OAuth2 身份验证支持&lt;/li&gt;&lt;li&gt;更新的前端技术堆栈：Bun、Vue 3.x、Nuxt 3.x、Vuetify 3.x、Vite 5.x&lt;/li&gt;&lt;li&gt;色盲主题&lt;/li&gt;&lt;li&gt;一般性能改进&lt;/li&gt;&lt;/ul&gt;&lt;h3 class="wp-block-heading" id="kyverno-playground"&gt;基韦尔诺游乐场&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/#kyverno-playground"&gt;&lt;/a&gt;&lt;/h3&gt;&lt;p&gt; 支持 ValidatingAdmissionPolicyBinding 的 Kyverno Playground 现在可用于新的 1.12 版本。您今天可以通过&lt;a href="https://playground.kyverno.io/next/#/"&gt;https://playground.kyverno.io/next/#/&lt;/a&gt;查看。&lt;/p&gt;&lt;h2 class="wp-block-heading" id="closing"&gt;闭幕式&lt;a href="https://kyverno.io/blog/2024/04/26/kyverno-1.12-released/#closing"&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;感谢我们令人难以置信的社区的支持和贡献，我们已经实现了另一个重要的里程碑。除了突出显示的新功能外，此版本还包括关键修复和其他重要更改。有关全面概述，请参阅 GitHub 上的完整&lt;a href="https://github.com/kyverno/kyverno/releases/tag/v1.12.0"&gt;发行说明&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;您可以在&lt;a href="https://kyverno.io/community/#slack-channel"&gt;Kubernetes Slack&lt;/a&gt;上的 Kyverno 频道中找到我们，参加我们的&lt;a href="https://kyverno.io/community/#community-meetings"&gt;社区会议&lt;/a&gt;之一来讨论您的贡献问题，或者直接在&lt;a href="https://twitter.com/kyverno"&gt;Twitter&lt;/a&gt;上关注我们。如果您已经是 Kyverno 采用者，请通过更新&lt;a href="https://github.com/kyverno/kyverno/blob/main/ADOPTERS.md"&gt;此处的&lt;/a&gt;采用者表格来注册成为正式采用者。 &lt;a href="https://github.com/kyverno/kyverno/" rel="noreferrer noopener" target="_blank"&gt;&lt;/a&gt;&lt;/p&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;</description><pubDate>Thu, 09 May 2024 16:00:00 GMT</pubDate><guid isPermaLink="true">https://www.cncf.io/blog/2024/05/10/kyverno-1-12-released/</guid></item><item><title>【Fivefold slower compared to Go? Optimizing Rust’s protobuf decoding performance】比 Go 慢五倍？优化Rust的protobuf解码性能</title><link>https://www.cncf.io/blog/2024/05/09/fivefold-slower-compared-to-go-optimizing-rusts-protobuf-decoding-performance/</link><description>&lt;p&gt;&lt;em&gt;会员帖子最初由 Lei 发布在&lt;a href="https://greptime.com/blogs/2024-04-09-rust-protobuf-performance"&gt;Greptime 博客&lt;/a&gt;上&lt;/em&gt;&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;&lt;em&gt;在优化 GreptimeDB v0.7 的写入性能时，我们发现使用 Prometheus 协议解析 Protobuf 数据的时间比 Go 实现的同类产品长了近 5 倍。这促使我们考虑优化协议层的开销。本文介绍了GreptimeDB团队尝试优化Protobuf反序列化开销的几种方法。&lt;/em&gt;&lt;/h3&gt;&lt;h2 class="wp-block-heading" id="background"&gt;&lt;a href="https://greptime.com/blogs/2024-04-09-rust-protobuf-performance#background"&gt;背景&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;在优化GreptimeDB v0.7的写入性能时，我们通过火焰图发现，解析Prometheus写入请求所花费的CPU时间约占总时间的12%。相比之下，用 Go 实现的 VictoriaMetrics 协议解析所花费的 CPU 时间仅为 5% 左右。这迫使我们开始考虑优化协议转换层的开销。&lt;/p&gt;&lt;p&gt;为了简化讨论，所有测试代码都存储在 GitHub 存储库&lt;a href="https://github.com/v0y4g3r/prom-write-request-bench" rel="noreferrer noopener" target="_blank"&gt;https://github.com/v0y4g3r/prom-write-request-bench&lt;/a&gt;中。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-bash" lang="bash"&gt;git clone https://github.com/v0y4g3r/prom-write-request-bench cd prom-write-request-bench export PROJECT_ROOT=$(pwd)&lt;/code&gt;&lt;/pre&gt;&lt;h2 class="wp-block-heading" id="optimization-steps"&gt;优化&lt;a href="https://greptime.com/blogs/2024-04-09-rust-protobuf-performance#optimization-steps"&gt;步骤&lt;/a&gt;&lt;/h2&gt;&lt;h3 class="wp-block-heading" id="step-1-reproduce"&gt;第 1 步：&lt;a href="https://greptime.com/blogs/2024-04-09-rust-protobuf-performance#step-1-reproduce"&gt;重现&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;首先，让我们使用最小的可重复基准设置基线。对应分行：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-bash" lang="bash"&gt;git checkout step1/reproduce&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; Rust相关的基准代码（ &lt;code&gt;benches/prom_decode.rs&lt;/code&gt; ）：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-rust" lang="rust"&gt;fn bench_decode_prom_request(c: &amp;amp;mut Criterion) { let mut d = std::path::PathBuf::from(env!(&amp;quot;CARGO_MANIFEST_DIR&amp;quot;)); d.push(&amp;quot;assets&amp;quot;); d.push(&amp;quot;1709380533560664458.data&amp;quot;); let data = Bytes::from(std::fs::read(d).unwrap()); let mut request_pooled = WriteRequest::default(); c.benchmark_group(&amp;quot;decode&amp;quot;) .bench_function(&amp;quot;write_request&amp;quot;, |b| { b.iter(|| { let mut request = WriteRequest::default(); let data = data.clone(); request.merge(data).unwrap(); }); }); }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;多次运行基准测试命令：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-bash" lang="bash"&gt;cargo bench -- decode/write_request&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要接收基线结果：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;decode/write_request time: [7.3174 ms 7.3274 ms 7.3380 ms] change: [+128.55% +129.11% +129.65%] (p = 0.00 &amp;lt; 0.05)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;拉取当前目录下的VictoriaMetrics代码，搭建Go性能测试环境：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-bash" lang="bash"&gt;git clone https://github.com/VictoriaMetrics/VictoriaMetrics cd VictoriaMetrics cat &amp;lt;&amp;lt;EOF &amp;gt; ./lib/prompb/prom_decode_bench_test.go package prompb import ( &amp;quot;io/ioutil&amp;quot; &amp;quot;testing&amp;quot; ) func BenchmarkDecodeWriteRequest(b *testing.B) { data, _ := ioutil.ReadFile(&amp;quot;${PROJECT_ROOT}/assets/1709380533560664458.data&amp;quot;) wr := &amp;amp;WriteRequest{} for n := 0; n &amp;lt; bN; n++ { b.StartTimer() wr.Reset() err := wr.UnmarshalProtobuf(data) if err != nil { panic(&amp;quot;failed to unmarshall&amp;quot;) } b.StopTimer() } } EOF go test github.com/VictoriaMetrics/VictoriaMetrics/lib/prompb --bench BenchmarkDecodeWriteRequest&lt;/code&gt;&lt;/pre&gt; &lt;blockquote class="wp-block-quote is-style-smaller-quote is-layout-flow wp-block-quote-is-layout-flow"&gt;&lt;p&gt;数据文件路径指向位于&lt;code&gt;prom-write-request-bench&lt;/code&gt;存储库的&lt;code&gt;assets&lt;/code&gt;目录中的&lt;code&gt;1709380533560664458.data&lt;/code&gt;文件。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;输出如下：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-bash" lang="bash"&gt;goos: linux goarch: amd64 pkg: github.com/VictoriaMetrics/VictoriaMetrics/lib/prompb cpu: AMD Ryzen 7 7735HS with Radeon Graphics BenchmarkDecodeWriteRequest-16 961 1196101 ns/op PASS ok github.com/VictoriaMetrics/VictoriaMetrics/lib/prompb 1.328s&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以看到，Rust 解析一个具有 10,000 个时间线的 Prometheus 写入请求大约需要 7.3ms，而 VictoriaMetrics 的 Go 版本只需要 1.2ms，仅为 Rust 版本时间的 1/6。&lt;/p&gt;&lt;p class="has-gray-400-background-color has-background"&gt;&lt;strong&gt;注意&lt;/strong&gt;：尽管您可能会注意到，尽管做了以下所有努力，Go 版本仍然优于 Rust 版本。这就是代码可维护性和性能之间的权衡。如果我们将所有&lt;code&gt;Bytes&lt;/code&gt;替换为&lt;code&gt;&amp;amp;[u8]&lt;/code&gt; ，那么 Rust 版本可以达到相同的性能。还值得注意的是，VictoriaMetrics 团队在使用对象池等技术来优化 Protobuf 性能方面做出了巨大的努力，他们甚至创建了&lt;a href="https://github.com/VictoriaMetrics/easyproto" rel="noreferrer noopener" target="_blank"&gt;easyproto&lt;/a&gt;来取代官方的 Protobuf 实现。&lt;/p&gt;&lt;p&gt;看到这里，你可能很快就发现了问题：&lt;strong&gt;在Go版本中，每次反序列化都使用相同的WriteRequest结构，只是在反序列化之前进行重置，以避免数据污染。相比之下，Rust 为每次反序列化使用一个新的结构。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;这是 VictoriaMetrics 对写入性能所做的优化之一 VictoriaMetrics 在其写入路径中大量利用池技术（如在&lt;code&gt;sync.Pool&lt;/code&gt;中）来降低垃圾收集的成本。如果Go版本像Rust一样为每次反序列化构建一个新的结构，那么消耗的时间将增加到10ms左右，比上面提到的Rust结果还要糟糕。&lt;/p&gt;&lt;p&gt;那么，Rust 版本中可以使用类似的池化技术吗？我们可以进行一个简单的实验： &lt;code&gt;pooled_write_request&lt;/code&gt; 。&lt;/p&gt;&lt;p&gt;测试逻辑与Go版本类似：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-rust" lang="rust"&gt;let mut request_pooled = WriteRequest::default(); c.bench_function(&amp;quot;pooled_write_request&amp;quot;, |b| { b.iter(|| { let data = data.clone(); request_pooled.clear(); request_pooled.merge(data).unwrap(); }); });&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;执行：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-bash" lang="bash"&gt;cargo bench -- decode/pooled_write_request&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结果如下：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;decode/pooled_write_request time: [7.1445 ms 7.1645 ms 7.1883 ms]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看起来性能没有显着提升。那么，这是为什么呢？&lt;/p&gt;&lt;p&gt;迄今为止的绩效评估：&lt;/p&gt;&lt;ul&gt;&lt;li&gt; Rust 基线时间：7.3ms&lt;/li&gt;&lt;li&gt; Go解析时间：1.2ms&lt;/li&gt;&lt;li&gt; Rust 当前时间：7.1ms&lt;/li&gt;&lt;/ul&gt;&lt;h3 class="wp-block-heading" id="step-2-repeatedfield"&gt;第2步：&lt;a href="https://greptime.com/blogs/2024-04-09-rust-protobuf-performance#step-2-repeatedfield"&gt;重复字段&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;对应分行：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-bash" lang="bash"&gt;git checkout step2/repeated_field&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了回答上面的问题，我们先看一下 Prometheus 的&lt;a href="https://github.com/prometheus/prometheus/blob/main/prompb/remote.proto#L22-L28" rel="noreferrer noopener" target="_blank"&gt;WriteRequest&lt;/a&gt;的数据结构： &lt;/p&gt;&lt;figure class="wp-block-image"&gt;&lt;img alt="图片1" src="https://greptime.com/blogs/2024-04-09-rust-protobuf-performance/image1.png" /&gt;&lt;/figure&gt;&lt;p&gt; &lt;code&gt;WriteRequest&lt;/code&gt;包含一个&lt;code&gt;TimeSeries&lt;/code&gt;向量，每个&lt;code&gt;TimeSeries&lt;/code&gt;又包含&lt;code&gt;Label&lt;/code&gt; 、 &lt;code&gt;Sample&lt;/code&gt;和&lt;code&gt;Exemplar&lt;/code&gt;向量。如果我们只重用最外层的 WriteRequest，那么每次清除它时，Labels、Samples 和 Exemlars 的向量也会被清除，因此我们无法重用内部结构体。&lt;/p&gt;&lt;p&gt;那么围棋呢？我们看一下&lt;a href="https://github.com/VictoriaMetrics/VictoriaMetrics/blob/c005245741fc3d7d744f258959be2a5ae388f8ec/lib/prompb/prompb.go#L19-L37" rel="noreferrer noopener" target="_blank"&gt;WriteRequest 的 Reset 方法&lt;/a&gt;：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-go" lang="go"&gt;wr.Timeseries = tss[:0]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; Go 版本没有将 TimeSeries 字段设置为 nil，而是将其设置为空切片。这意味着切片内的原始元素仍然被保留，并且不会被垃圾回收（只是 len 字段设置为 0），因此 Go 的对象重用机制可以有效避免重复的内存分配。&lt;/p&gt;&lt;p&gt; Rust 可以采用类似的机制吗？&lt;/p&gt;&lt;p&gt;这里我们引入了 Rust 生态系统中另一个流行的 Protobuf 库 rust-protobuf v2.x 中名为&lt;a href="https://docs.rs/protobuf/2.28.0/protobuf/struct.RepeatedField.html" rel="noreferrer noopener" target="_blank"&gt;RepeatedField&lt;/a&gt;的机制。&lt;/p&gt;&lt;p&gt;它旨在通过手动维护&lt;code&gt;vec&lt;/code&gt;和&lt;code&gt;len&lt;/code&gt;字段来避免&lt;code&gt;Vec::clear&lt;/code&gt;带来的开销。清除时，它仅将&lt;code&gt;len&lt;/code&gt;设置为 0，而不从&lt;code&gt;vec&lt;/code&gt;调用clear，从而确保&lt;code&gt;vec&lt;/code&gt;内的元素以及这些元素内的&lt;code&gt;vec&lt;/code&gt;不会被删除。&lt;/p&gt;&lt;p&gt;那么问题来了：如何将RepeatedField机制集成到PROST中？显然，PROST没有类似的配置选项，因此我们需要手动扩展PROST的过程宏生成的代码。&lt;/p&gt;&lt;p&gt;在这个过程中，我们发现有些字段目前在写入过程中不需要，可以跳过。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-bash" lang="bash"&gt;cargo bench -- decode/pooled_write_request&lt;/code&gt;&lt;/pre&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;decode/pooled_write_request time: [2.6941 ms 2.7004 ms 2.7068 ms] change: [-66.969% -66.417% -65.965%] (p = 0.00 &amp;lt; 0.05) Performance has improved.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;哇！通过使用&lt;code&gt;RepeatedField&lt;/code&gt;机制，我们成功地将处理时间减少到原来的36%左右。&lt;/p&gt;&lt;p&gt;但是这个时间是否可以进一步减少，我们还可以从Go的代码中学到什么东西呢？ &lt;/p&gt;&lt;blockquote class="wp-block-quote is-style-smaller-quote is-layout-flow wp-block-quote-is-layout-flow"&gt;&lt;p&gt;值得一提的是，由于&lt;code&gt;RepeatedField&lt;/code&gt;使用起来不如&lt;code&gt;Vec&lt;/code&gt;方便， &lt;a href="https://github.com/stepancheg/rust-protobuf/issues/518#issuecomment-751870333" rel="noreferrer noopener" target="_blank"&gt;所以 rust-protobuf 3.x 版本已经将其删除了&lt;/a&gt;。不过， &lt;a href="https://github.com/stepancheg/rust-protobuf/issues/503#issuecomment-1030822294" rel="noreferrer noopener" target="_blank"&gt;作者还提到&lt;/a&gt;，将来可能会有添加&lt;code&gt;RepeatedField&lt;/code&gt;选项。&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;迄今为止的绩效评估：&lt;/p&gt;&lt;ul&gt;&lt;li&gt; Rust 基线时间：7.3ms&lt;/li&gt;&lt;li&gt; Go解析时间：1.2ms&lt;/li&gt;&lt;li&gt; Rust 当前时间：2.7ms&lt;/li&gt;&lt;/ul&gt;&lt;h3 class="wp-block-heading" id="step-3-string-or-bytes"&gt;第 3 步：字符串还是字节&lt;a href="https://greptime.com/blogs/2024-04-09-rust-protobuf-performance#step-3-string-or-bytes"&gt;？&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;对应分行：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-bash" lang="bash"&gt;git checkout step3/bytes&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在 Go 中，字符串只是&lt;code&gt;[]byte&lt;/code&gt;的简单包装，并且可以通过简单地将原始缓冲区的指针和长度分配给字符串字段来完成字符串字段的反序列化。然而，Rust 的 PROST 在反序列化&lt;code&gt;String&lt;/code&gt;类型字段时，需要将数据从原始缓冲区复制到&lt;code&gt;String&lt;/code&gt;中，确保反序列化结构体的生命周期独立于原始缓冲区。然而，这会带来额外的数据复制开销。&lt;/p&gt;&lt;p&gt;那么我们可以将 Label 字段更改为&lt;code&gt;Bytes&lt;/code&gt;而不是&lt;code&gt;String&lt;/code&gt;吗？我记得&lt;a href="https://docs.rs/prost-build/latest/prost_build/struct.Config.html#method.bytes" rel="noreferrer noopener" target="_blank"&gt;&lt;code&gt;PROST_build&lt;/code&gt;中有一个&lt;code&gt;Config::bytes&lt;/code&gt;选项&lt;/a&gt;。在此 PROST 的 PR 中，添加了对生成&lt;code&gt;bytes&lt;/code&gt;类型字段作为&lt;code&gt;Bytes&lt;/code&gt;而不是默认的&lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;支持，从而实现零拷贝解析。&lt;/p&gt;&lt;p&gt;我们可以类似地将&lt;code&gt;Label&lt;/code&gt;的&lt;code&gt;name&lt;/code&gt;和&lt;code&gt;value&lt;/code&gt;字段的类型更改为&lt;code&gt;Bytes&lt;/code&gt; 。这样做的好处是不需要复制，但问题也很明显：在需要使用&lt;code&gt;Label&lt;/code&gt;的地方， &lt;code&gt;Bytes&lt;/code&gt;仍然必须转换为&lt;code&gt;String&lt;/code&gt; 。在这个转换步骤中，我们可以选择使用&lt;code&gt;String::from_utf8_unchecked&lt;/code&gt;来跳过字符串有效检查，以进一步提高性能。&lt;/p&gt;&lt;p&gt;当然，如果 GreptimeDB 实例暴露在公共互联网上，这样的操作显然是不安全的。因此，在&lt;a href="https://github.com/GreptimeTeam/greptimedb/issues/3435" rel="noreferrer noopener" target="_blank"&gt;#3435&lt;/a&gt;中，我们提到需要添加严格模式来验证字符串的合法性。&lt;/p&gt;&lt;p&gt;修改&lt;code&gt;Label::name&lt;/code&gt;和&lt;code&gt;Label::value&lt;/code&gt;的类型后，我们再次运行测试：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-bash" lang="bash"&gt;cargo bench -- decode/pooled_write_request&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结果如下：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;decode/pooled_write_request time: [3.4295 ms 3.4315 ms 3.4336 ms] change: [+26.763% +27.076% +27.383%] (p = 0.00 &amp;lt; 0.05) Performance has regressed.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;等待。为什么表现会变得更差？让我们生成一个火焰图以更好地理解根本问题。 &lt;/p&gt;&lt;figure class="wp-block-image"&gt;&lt;img alt="图片2" src="https://greptime.com/blogs/2024-04-09-rust-protobuf-performance/image2.png" /&gt;&lt;/figure&gt;&lt;p&gt;很明显，大部分 CPU 时间都花在了&lt;code&gt;copy_to_bytes&lt;/code&gt;上。从&lt;a href="https://github.com/tokio-rs/prost/blob/v0.12.4/src/encoding.rs#L989" rel="noreferrer noopener" target="_blank"&gt;PROST中解析Bytes字段的代码&lt;/a&gt;中，我们可以看到以下内容：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-rust" lang="rust"&gt;pub fn merge&amp;lt;A, B&amp;gt;( wire_type: WireType, value: &amp;amp;mut A, buf: &amp;amp;mut B, _ctx: DecodeContext, ) -&amp;gt; Result&amp;lt;(), DecodeError&amp;gt; where A: BytesAdapter, B: Buf, { check_wire_type(WireType::LengthDelimited, wire_type)?; let len = decode_varint(buf)?; &lt;em&gt;if&lt;/em&gt; len &amp;gt; buf.remaining() as u64 { &lt;em&gt;return&lt;/em&gt; Err(DecodeError::new(&amp;quot;buffer underflow&amp;quot;)); } let len = len as usize;&lt;em&gt; //...&lt;/em&gt; value.replace_with(buf.copy_to_bytes(len)); Ok(()) }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; &lt;a href="https://github.com/tokio-rs/prost/blob/v0.12.4/src/encoding.rs#L912" rel="noreferrer noopener" target="_blank"&gt;当&lt;code&gt;value&lt;/code&gt;变量的类型为&lt;code&gt;Bytes&lt;/code&gt;时， &lt;code&gt;value.replace_with&lt;/code&gt;调用将再次调用&lt;code&gt;copy_to_bytes&lt;/code&gt; 。&lt;/a&gt;&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-rust" lang="rust"&gt;impl sealed::BytesAdapter &lt;em&gt;for&lt;/em&gt; Bytes { fn replace_with&amp;lt;B&amp;gt;(&amp;amp;mut self, mut buf: B) where B: Buf, { *self = buf.copy_to_bytes(buf.remaining()); } }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们可以消除一次复制操作吗？虽然&lt;code&gt;Bytes::copy_to_bytes&lt;/code&gt;不涉及实际的数据复制，而是涉及指针操作，但其开销仍然相当大。&lt;/p&gt;&lt;p&gt;迄今为止的绩效评估：&lt;/p&gt;&lt;ul&gt;&lt;li&gt; Rust 基线时间：7.3ms&lt;/li&gt;&lt;li&gt; Go解析时间：1.2ms&lt;/li&gt;&lt;li&gt; Rust 当前时间：3.4ms&lt;/li&gt;&lt;/ul&gt;&lt;h3 class="wp-block-heading" id="step-4-eliminate-one-copy"&gt;第 4 步：消除一份&lt;a href="https://greptime.com/blogs/2024-04-09-rust-protobuf-performance#step-4-eliminate-one-copy"&gt;副本&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;对应分行：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-bash" lang="bash"&gt;git checkout step4/bytes-eliminate-one-copy&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;由于我们从&lt;code&gt;Bytes&lt;/code&gt;解析 Prometheus 的&lt;code&gt;WriteRequest&lt;/code&gt; ，因此我们可以直接将泛型参数&lt;code&gt;B: Buf&lt;/code&gt;特化为 Bytes。这样， &lt;code&gt;PROST::encoding::bytes::merge&lt;/code&gt;就变成了下面的&lt;code&gt;merge_bytes&lt;/code&gt;方法：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-rust" lang="rust"&gt;#[inline(always)] fn copy_to_bytes(data: &amp;amp;mut Bytes, len: usize) -&amp;gt; Bytes { &lt;em&gt;if&lt;/em&gt; len == data.remaining() { std::mem::replace(data, Bytes::new()) } &lt;em&gt;else&lt;/em&gt; { let ret = data.slice(0..len); data.advance(len); ret } } pub fn merge_bytes(value: &amp;amp;mut Bytes, buf: &amp;amp;mut Bytes) -&amp;gt; Result&amp;lt;(), DecodeError&amp;gt; { let len = decode_varint(buf)?; &lt;em&gt;if&lt;/em&gt; len &amp;gt; buf.remaining() as u64 { &lt;em&gt;return&lt;/em&gt; Err(DecodeError::new(format!( &amp;quot;buffer underflow, len: {}, remaining: {}&amp;quot;, len, buf.remaining() ))); } *value = copy_to_bytes(buf, len as usize); Ok(()) }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;进行替换后，再次运行基准测试：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-rust" lang="rust"&gt;cargo bench -- decode/pooled_write_request&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;结果如下：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;decode/pooled_write_request time: [2.7597 ms 2.7630 ms 2.7670 ms] change: [-19.582% -19.483% -19.360%] (p = 0.00 &amp;lt; 0.05) Performance has improved.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们可以看到有所改善，但幅度不大。看来我们只是回到了刚刚达到的性能水平。那么，我们可以更进一步吗？&lt;/p&gt;&lt;p&gt;迄今为止的绩效评估：&lt;/p&gt;&lt;ul&gt;&lt;li&gt; Rust 基线时间：7.3ms&lt;/li&gt;&lt;li&gt; Go解析时间：1.2ms&lt;/li&gt;&lt;li&gt; Rust 当前时间：2.76ms&lt;/li&gt;&lt;/ul&gt;&lt;h3 class="wp-block-heading" id="step-5-why-is-bytes-slice-so-slow"&gt;第 5 步：为什么&lt;code&gt;Bytes::slice&lt;/code&gt;这么慢&lt;a href="https://greptime.com/blogs/2024-04-09-rust-protobuf-performance#step-5-why-is-bytes-slice-so-slow"&gt;？&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;对应分行：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-bash" lang="bash"&gt;git checkout step5/bench-bytes-slice&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;主要原因是 PROST 的字段特征绑定是&lt;code&gt;BytesAdapter&lt;/code&gt; ，而反序列化&lt;code&gt;Bytes&lt;/code&gt;的特征绑定是&lt;code&gt;Buf&lt;/code&gt; 。虽然&lt;code&gt;Bytes&lt;/code&gt;实现了这两种特征，但如果要将一种类型分配给另一种类型，则需要经过两次 copy_to_bytes 过程来进行转换。在&lt;code&gt;merge&lt;/code&gt;方法中，由于&lt;code&gt;Buf&lt;/code&gt;的实际类型未知，因此首先需要使用&lt;code&gt;Buf::copy_to_bytes&lt;/code&gt;将&lt;code&gt;Buf&lt;/code&gt;转换为 Bytes。然后，它将&lt;code&gt;Bytes&lt;/code&gt;传递给&lt;code&gt;BytesAdapter::replace_with&lt;/code&gt; ，再次使用&lt;code&gt;&amp;lt;&amp;lt;Bytes as Buf&amp;gt;&amp;gt;::copy_to_bytes&lt;/code&gt;将&lt;code&gt;Buf&lt;/code&gt;转换为&lt;code&gt;Bytes&lt;/code&gt; 。最后，我们得到实现&lt;code&gt;BytesAdapter&lt;/code&gt;的具体类型： &lt;code&gt;Bytes&lt;/code&gt; 。 &lt;/p&gt;&lt;figure class="wp-block-image"&gt;&lt;img alt="图3" src="https://greptime.com/blogs/2024-04-09-rust-protobuf-performance/image3.png" /&gt;&lt;/figure&gt;&lt;p&gt;从PROST的角度来看， &lt;code&gt;Bytes::copy_to_bytes&lt;/code&gt;不涉及复制数据，因此可以认为是零复制操作。然而，这种零拷贝操作的开销并没有那么低。&lt;/p&gt;&lt;p&gt;我们来做一个简单的测试来验证一下：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-rust" lang="rust"&gt;c.benchmark_group(&amp;quot;slice&amp;quot;).bench_function(&amp;quot;bytes&amp;quot;, |b| { let mut data = data.clone(); b.iter(|| { let mut bytes = data.clone(); &lt;em&gt;for&lt;/em&gt; _ in 0..10000 { bytes = black_box(bytes.slice(0..1)); } }); });&lt;/code&gt;&lt;/pre&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-go" lang="go"&gt;func BenchmarkBytesSlice(b *testing.B) { data, _ := ioutil.ReadFile(&amp;quot;&amp;lt;any binary file&amp;gt;&amp;quot;) &lt;em&gt;for&lt;/em&gt; n := 0; n &amp;lt; bN; n++ { b.StartTimer() bytes := data &lt;em&gt;for&lt;/em&gt; i :=0; i &amp;lt; 10000; i++ { bytes = bytes[:1] } b.StopTimer() } }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; Go 中的执行时间为 2.93 微秒，而 Rust 中的执行时间为 103.31 微秒：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;goos: linux goarch: amd64 pkg: github.com/VictoriaMetrics/VictoriaMetrics/lib/prompb cpu: AMD Ryzen 7 7735HS with Radeon Graphics BenchmarkBytesSlice-16 497607 2930 ns/op PASS ok github.com/VictoriaMetrics/VictoriaMetrics/lib/prompb 6.771s&lt;/code&gt;&lt;/pre&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;slice/bytes time: [103.23 µs 103.31 µs 103.40 µs] change: [+7.6697% +7.8029% +7.9374%] (p = 0.00 &amp;lt; 0.05)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;可以观察到 Rust 中的切片操作比 Go 中慢两个数量级。&lt;/p&gt;&lt;p&gt; Go 的切片仅包含三个字段： &lt;code&gt;ptr&lt;/code&gt; 、 &lt;code&gt;cap&lt;/code&gt;和&lt;code&gt;len&lt;/code&gt; 。它的切片操作只涉及对这三个变量的修改。 &lt;/p&gt;&lt;figure class="wp-block-image"&gt;&lt;img alt="图片4" src="https://greptime.com/blogs/2024-04-09-rust-protobuf-performance/image4.png" /&gt;&lt;/figure&gt;&lt;p&gt;在Rust中，为了保证内存安全，反序列化（ &lt;code&gt;WriteRequest&lt;/code&gt; ）的输出必须与输入数据（ &lt;code&gt;Bytes&lt;/code&gt; ）的生命周期无关。为了避免数据复制， &lt;code&gt;Bytes&lt;/code&gt;采用了引用计数机制。&lt;/p&gt;&lt;p&gt;如下所示，两个 Bytes 实例 A 和 B 基本上指向相同的底层内存区域。然而，每个都有一个数据指针，指向保存引用计数信息的结构。仅当引用计数达到零时，原始内存数组才会被删除。虽然这种方法避免了复制，但也会产生一些开销。 &lt;/p&gt;&lt;figure class="wp-block-image"&gt;&lt;img alt="图5" src="https://greptime.com/blogs/2024-04-09-rust-protobuf-performance/image5.png" /&gt;&lt;/figure&gt;&lt;ul&gt;&lt;li&gt;通过&lt;code&gt;From&amp;lt;Vec&amp;lt;u8&amp;gt;&amp;gt;&lt;/code&gt;创建的&lt;code&gt;Bytes&lt;/code&gt;实例的切片操作基于引用计数。每次切片都需要复制原始缓冲区的指针、长度、引用计数以及切片的返回值的指针和长度等，相比Go基于可达性分析的垃圾回收，效率无疑要低很多。&lt;/li&gt;&lt;li&gt;由于 Bytes 支持多种实现， &lt;a href="https://docs.rs/bytes/1.5.0/src/bytes/bytes.rs.html#529-534" rel="noreferrer noopener" target="_blank"&gt;因此某些方法（例如克隆）依赖 vtable 进行动态调度。&lt;/a&gt;&lt;/li&gt;&lt;li&gt;为了保证切片操作的安全， &lt;a href="https://docs.rs/bytes/1.5.0/src/bytes/bytes.rs.html#255-266" rel="noreferrer noopener" target="_blank"&gt;Bytes在很多地方手动插入了边界检查。&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h3 class="wp-block-heading" id="step6-a-little-bit-unsafe"&gt; Step6：有点&lt;a href="https://greptime.com/blogs/2024-04-09-rust-protobuf-performance#step6-a-little-bit-unsafe"&gt;不安全&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;对应分行：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-bash" lang="bash"&gt;git checkout step6/optimize-slice&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;有没有办法进一步优化开销？&lt;/p&gt;&lt;p&gt; GreptimeDB 中写入接口的一个显着特点是，一旦解析&lt;code&gt;WriteRequest&lt;/code&gt; ，它将立即转换为 GreptimeDB 自己的数据结构，而不是直接使用&lt;code&gt;WriteRequest&lt;/code&gt; 。&lt;strong&gt;这意味着反序列化输入字节的寿命总是比解析结构的寿命长。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;因此，我们可以对切片操作进行一些hacky修改，直接使用原始数组的指针和长度组装返回的&lt;code&gt;Bytes&lt;/code&gt; 。这样，只要原来的&lt;code&gt;A&lt;/code&gt;实例还活着，从它切下来的所有&lt;code&gt;Bytes&lt;/code&gt;实例都会指向有效的内存。 &lt;/p&gt;&lt;figure class="wp-block-image"&gt;&lt;img alt="图6" src="https://greptime.com/blogs/2024-04-09-rust-protobuf-performance/image6.png" /&gt;&lt;/figure&gt;&lt;p&gt;我们用以下&lt;code&gt;split_to&lt;/code&gt;方法替换&lt;code&gt;data.slice(..len)&lt;/code&gt;操作：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-rust" lang="rust"&gt;pub fn split_to(buf: &amp;amp;mut Bytes, end: usize) -&amp;gt; Bytes { let len = buf.len(); assert!( end &amp;lt;= len, &amp;quot;range end out of bounds: {:?} &amp;lt;= {:?}&amp;quot;, end, len, ); &lt;em&gt;if&lt;/em&gt; end == 0 { &lt;em&gt;return&lt;/em&gt; Bytes::new(); } let ptr = buf.as_ptr(); let x = unsafe { slice::from_raw_parts(ptr, end) };&lt;em&gt; // `Bytes::drop` does nothing when it&amp;#39;s built via `from_static`.&lt;/em&gt; Bytes::from_static(x) } &lt;em&gt;// benchmark&lt;/em&gt; c.bench_function(&amp;quot;split_to&amp;quot;, |b| { let data = data.clone(); b.iter(|| { let mut bytes = data.clone(); &lt;em&gt;for&lt;/em&gt; _ in 0..10000 { bytes = black_box(unsafe { split_to(&amp;amp;bytes, 1) }); } }); })&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;让我们再次对其进行基准测试以查看结果：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;slice/bytes time: [103.23 µs 103.31 µs 103.40 µs] change: [+7.6697% +7.8029% +7.9374%] (p = 0.00 &amp;lt; 0.05) slice/split_to time: [24.061 µs 24.089 µs 24.114 µs] change: [+0.2058% +0.4198% +0.6371%] (p = 0.00 &amp;lt; 0.05)&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;耗时从 103us 大幅下降至 24us。现在，反序列化的总体开销怎么样？&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;decode/pooled_write_request time: [1.6169 ms 1.6181 ms 1.6193 ms] change: [-37.960% -37.887% -37.815%] (p = 0.00 &amp;lt; 0.05) Performance has improved.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;最后，我们成功地将解析单个 WriteRequest 所需的时间减少到约 1.6ms，仅比 Go 的 1.2ms 慢了 33.3%！&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;当然，还有优化的空间。如果我们完全放弃&lt;code&gt;Bytes&lt;/code&gt;并使用 Rust 的切片 ( &lt;code&gt;&amp;amp;[u8]&lt;/code&gt; )，我们可以获得接近 Go 的性能（仅考虑切片的开销）：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-rust" lang="rust"&gt;c.bench_function(&amp;quot;slice&amp;quot;, |b| { let data = data.clone(); let mut slice = data.as_ref(); b.iter(move || { &lt;em&gt;for&lt;/em&gt; _ in 0..10000 { slice = black_box(&amp;amp;slice[..1]); } }); });&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;对应结果如下：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;slice/slice time: [4.6192 µs 4.7333 µs 4.8739 µs] change: [+6.1294% +9.8655% +13.739%] (p = 0.00 &amp;lt; 0.05) Performance has regressed.&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;不过，由于这部分开销在整个写入路径中所占的比例已经很低，因此进一步优化不会对整体吞吐量产生显着影响。&lt;/p&gt;&lt;p&gt;如果您有兴趣，还可以尝试使用切片重构反序列化代码，如果您与我们分享您的经验，我们将非常高兴。&lt;/p&gt;&lt;p&gt;迄今为止的绩效评估：&lt;/p&gt;&lt;ul&gt;&lt;li&gt; Rust 基线持续时间：7.3ms&lt;/li&gt;&lt;li&gt; Go解析持续时间：1.2ms&lt;/li&gt;&lt;li&gt;锈蚀电流持续时间：1.62ms&lt;/li&gt;&lt;/ul&gt;&lt;h2 class="wp-block-heading" id="summary"&gt;&lt;a href="https://greptime.com/blogs/2024-04-09-rust-protobuf-performance#summary"&gt;总结&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;在本文中，我们尝试了各种方法来优化反序列化 Protobuf 编码的&lt;code&gt;WriteRequest&lt;/code&gt;数据的开销。&lt;/p&gt;&lt;p&gt;首先，我们利用池化技术来避免重复的内存分配和释放，直接将时间消耗减少到基线的 36% 左右。然后，为了利用零复制功能，我们将&lt;code&gt;Label&lt;/code&gt;的&lt;code&gt;String&lt;/code&gt;字段替换为&lt;code&gt;Bytes&lt;/code&gt;类型，但发现性能实际上有所下降。火焰图显示，PROST 引入了一些额外的开销，以允许&lt;code&gt;Bytes&lt;/code&gt;在&lt;code&gt;BytesAdapter&lt;/code&gt;和&lt;code&gt;Buf&lt;/code&gt;特征之间进行转换。通过专门化类型，我们设法消除了这些开销。此外，我们在火焰图中注意到， &lt;code&gt;Bytes::slice&lt;/code&gt;本身引入了一些额外的开销，以确保内存安全。考虑到我们的用例，我们破解了切片实现，最终将时间消耗减少到基线的 20% 左右。&lt;/p&gt;&lt;p&gt;总体而言，Rust 在直接操作字节数组时施加了相当多的限制以确保内存安全。使用&lt;code&gt;Bytes&lt;/code&gt;可以通过引用计数来规避生命周期问题，但代价是效率低下。另一方面，使用&lt;code&gt;&amp;amp;[u8]&lt;/code&gt;迫使人们处理生命周期的传染。&lt;/p&gt;&lt;p&gt;本文采用了一种折衷的方法，通过&lt;code&gt;unsafe&lt;/code&gt;方法绕过&lt;code&gt;Bytes&lt;/code&gt;的引用计数机制，手动确保输入缓冲区在输出的整个生命周期内保持有效。&lt;strong&gt;值得注意的是，这不是一种普遍适用的优化方法，但当成本是热代码路径的一部分时值得尝试。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;此外，“零成本抽象”是 Rust 语言的关键设计理念之一。然而，并非所有抽象都是零成本的。在这篇文章中，我们看到了PROST的&lt;code&gt;BytesAdapter&lt;/code&gt;和&lt;code&gt;Buf&lt;/code&gt;特征之间转换的开销，以及&lt;code&gt;Bytes&lt;/code&gt;为了适应不同的底层数据源而引入的动态调度成本等。这提醒我们要更加关注关键代码路径的底层实现和通过持续分析保证高性能。&lt;/p&gt;&lt;p&gt;除了优化反序列化之外，我们还在GreptimeDB v0.7的写入路径上做了其他努力。最初，在转换为 GreptimeDB 的&lt;code&gt;RowInsertRequest&lt;/code&gt;之前，必须完全解析&lt;code&gt;WriteRequest&lt;/code&gt; 。现在，我们消除了中间结构，在&lt;code&gt;WriteRequest&lt;/code&gt;的反序列化过程中，直接将&lt;code&gt;TimeSeries&lt;/code&gt;结构转换为表维度的写入数据。这样就可以减少所有时间线的遍历（ &lt;a href="https://github.com/GreptimeTeam/greptimedb/pull/3425" rel="noreferrer noopener" target="_blank"&gt;#3425&lt;/a&gt; ， &lt;a href="https://github.com/GreptimeTeam/greptimedb/pull/3478" rel="noreferrer noopener" target="_blank"&gt;#3478&lt;/a&gt; ），同时也降低中间结构的内存开销。此外，Rust 中基于 SipHash 的默认 HashMap 在构建表维度写入数据方面表现并不理想。通过改用基于aHash的HashMap，我们在查表方面实现了近40%的性能提升。&lt;/p&gt;&lt;p&gt;性能优化本质上是系统性的，其特点是对即使是最小细节的改进也进行细致的积累，最终产生可观的收益。 GreptimeDB 团队坚定地致力于这一持续的旅程，努力突破效率和卓越的界限。 &lt;/p&gt;&lt;hr class="wp-block-separator has-alpha-channel-opacity" /&gt;&lt;h4 class="wp-block-heading" id="about-greptime"&gt;关于&lt;a href="https://greptime.com/blogs/2024-04-09-rust-protobuf-performance#about-greptime"&gt;Greptime&lt;/a&gt;&lt;/h4&gt;&lt;p&gt;我们帮助生成大量时序数据的行业，例如车联网 (CV)、物联网和可观测性，实时有效地发现数据的隐藏价值。&lt;/p&gt;&lt;p&gt;从任何设备访问&lt;a href="https://www.greptime.com/resources" rel="noreferrer noopener" target="_blank"&gt;最新的 v0.7&lt;/a&gt;即可开始并充分利用您的数据。&lt;/p&gt;&lt;ul&gt;&lt;li&gt; &lt;a href="https://github.com/GreptimeTeam/greptimedb" rel="noreferrer noopener" target="_blank"&gt;GreptimeDB&lt;/a&gt;用 Rust 编写，是一个分布式开源时间序列数据库，专为可扩展性、效率和强大的分析而设计。&lt;/li&gt;&lt;li&gt; &lt;a href="https://www.greptime.com/product/cloud" rel="noreferrer noopener" target="_blank"&gt;GreptimeCloud&lt;/a&gt;提供完全托管的 DBaaS，与可观测性和物联网领域完美集成。&lt;/li&gt;&lt;li&gt; &lt;a href="https://www.greptime.com/product/ai" rel="noreferrer noopener" target="_blank"&gt;GreptimeAI&lt;/a&gt;是专为 LLM 应用程序量身定制的可观察性解决方案。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;如果以上任何内容引起了您的注意，请随时在&lt;a href="https://github.com/GreptimeTeam/greptimedb" rel="noreferrer noopener" target="_blank"&gt;GitHub&lt;/a&gt;上为我们加注星标或加入&lt;a href="https://www.greptime.com/slack" rel="noreferrer noopener" target="_blank"&gt;Slack&lt;/a&gt;上的 GreptimeDB 社区。此外，您还可以访问我们的&lt;a href="https://github.com/GreptimeTeam/greptimedb/contribute" rel="noreferrer noopener" target="_blank"&gt;贡献页面&lt;/a&gt;来查找一些有趣的问题。 &lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;</description><pubDate>Wed, 08 May 2024 16:00:00 GMT</pubDate><guid isPermaLink="true">https://www.cncf.io/blog/2024/05/09/fivefold-slower-compared-to-go-optimizing-rusts-protobuf-decoding-performance/</guid></item><item><title>【Get the first look at CloudNativeSecurityCon North America 2024’s schedule, add-on events, and more】抢先了解 CloudNativeSecurityCon North America 2024 的日程安排、附加活动等</title><link>https://www.cncf.io/blog/2024/05/09/get-the-first-look-at-cloudnativesecuritycon-north-america-2024s-schedule-add-on-events-and-more/</link><description>&lt;p&gt;&lt;a href="https://events.linuxfoundation.org/cloudnativesecuritycon-north-america/"&gt;CloudNativeSecurityCon North America 2024&lt;/a&gt;的日程&lt;a href="https://cloudnativesecurityconna24.sched.com/"&gt;现已上线&lt;/a&gt;，其中包括 75 场会议，提供实用的解决方案，并对当今安全领域的一些最大挑战进行深思熟虑的讨论。该会议将于 6 月 26 日至 27 日在华盛顿州西雅图举行，附加活动将于 6 月 25 日开始。&lt;/p&gt;&lt;p&gt;这是您需要了解的一切。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;strong&gt;有针对性的曲目和发人深省的主题演讲&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;CloudNativeSecurityCon 北美提供八个学习和交流课程：云原生安全新手、GRC + 隐私、IAM + 多租户 + 网络安全、在云安全中利用 + 为 AI 做好准备、可观察性 + 检测 + 响应、安全倡导 + 协作、供应链+ 容器 + 应用程序安全性和教程。&lt;/p&gt;&lt;p&gt;此外，与会者还可以从这两天的十几个主题演讲、五场闪电演讲中学习，当然还可以浏览解决方案展示。主题演讲主题涵盖&lt;a href="https://cloudnativesecurityconna24.sched.com/event/1dCTh/keynote-demystifying-secure-application-communication-with-zero-trust-identity-integrity-confidentiality-lin-sun-head-of-open-source-soloio"&gt;零信任&lt;/a&gt;、 &lt;a href="https://cloudnativesecurityconna24.sched.com/event/1dCVD/keynote-were-vexing-the-cloud-native-landscape-bring-your-code-adolfo-garcia-veytia-staff-software-engineer-stacklok"&gt;漏洞利用交换 (VEX)&lt;/a&gt; 、 &lt;a href="https://cloudnativesecurityconna24.sched.com/event/1dCVC/keynote-sugar-rayio-on-k8s-shut-the-door-baby-greg-castle-gke-security-tech-lead-google-cynthia-thomas-product-manager-google"&gt;检索增强生成 (RAG)&lt;/a&gt; 、 &lt;a href="https://cloudnativesecurityconna24.sched.com/event/1dCTk/keynote-k8s-security-safari-hunting-threats-in-the-wild-wild-cloud-stav-ochakovski-senior-cloud-security-researcher-mitiga-ariel-szarf-devops-tech-lead-mitiga"&gt;Kubernetes 安全基础知识&lt;/a&gt;、 &lt;a href="https://cloudnativesecurityconna24.sched.com/event/1dCVA/keynote-security-education-through-the-art-of-storytelling-ann-wallace-director-of-product-security-education-okta"&gt;安全教育&lt;/a&gt;等。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;strong&gt;探索当今的关键挑战&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;如果存在让您彻夜难眠的云原生安全问题，CloudNativeSecurityCon North America 将解决该问题。无论是提升安全职业水平、多方面审视威胁建模、安全扩展人工智能、抗量子密码学，还是如何缓解 OSS 漏洞，活动与会者都将听到行业专家提出的有针对性的建议。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;strong&gt;附加活动&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;今年，参与者可以选择参加两项附加活动： &lt;a href="https://events.linuxfoundation.org/cloudnativesecuritycon-north-america/add-on-programming/#otel-community-day"&gt;OTel 社区日&lt;/a&gt;和&lt;a href="https://events.linuxfoundation.org/cloudnativesecuritycon-north-america/add-on-programming/#secure-ai-summit-powered-by-cloud-native"&gt;安全人工智能峰会&lt;/a&gt;。当然，我们还有其他令人兴奋的机会同时举办，包括夺旗 (CTF) 和 EmpowerUs。 &lt;/p&gt;&lt;figure class="wp-block-image size-full"&gt;&lt;img alt="OTel 社区日" class="wp-image-107272" height="332" src="https://www.cncf.io/wp-content/uploads/2024/05/image-25-1.jpg" width="618" /&gt;&lt;/figure&gt;&lt;h3 class="wp-block-heading"&gt; &lt;strong&gt;OTel 社区日&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;请于 6 月 25 日星期二加入我们，我们将联合 OpenTelemetry 的维护者、贡献者和用户来解决可观测性的重大挑战。庆祝我们在该领域的开源成就和成功。必须预先注册。不要忘记将&lt;a href="https://events.linuxfoundation.org/open-telemetry-community-day/"&gt;OTel 社区日&lt;/a&gt;纳入您的 CloudNativeSecurityCon North America &lt;a href="https://events.linuxfoundation.org/cloudnativesecuritycon-north-america/register/#registration-types"&gt;注册&lt;/a&gt;中。 &lt;/p&gt;&lt;figure class="wp-block-image size-full"&gt;&lt;img alt="安全人工智能峰会" class="wp-image-107273" height="210" src="https://www.cncf.io/wp-content/uploads/2024/05/image-25-2.jpg" width="642" /&gt;&lt;/figure&gt;&lt;h3 class="wp-block-heading"&gt;&lt;strong&gt;安全人工智能峰会 | 6月25日&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;参加 6 月 25 日星期二举行的&lt;a href="https://events.linuxfoundation.org/cloudnativesecuritycon-north-america/add-on-programming/#secure-ai-summit-powered-by-cloud-native"&gt;安全 AI 峰会&lt;/a&gt;（由 Cloud Native 提供支持），取得一些突破，并花时间研究 AI 和云原生安全性的交叉点。从威胁检测、事件响应自动化和隐私保护，与同事一起讨论当今技术中一些最令人兴奋（和最具挑战性）的主题。&lt;/p&gt;&lt;p&gt;请务必将 Secure AI Summit 添加到您的 CloudNativeSecurityCon North America 2024 &lt;a href="https://events.linuxfoundation.org/cloudnativesecuritycon-north-america/register/#registration-types"&gt;注册&lt;/a&gt;中。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;&lt;strong&gt;夺旗 (CTF)&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt; CTF“永远”是一个不错的选择，今年也不例外。云原生安全是一个黑暗而神秘的世界，所以加入我们，利用供应链攻击并开始寻找旗帜。在此 CTF 期间，与会者可以玩三种（可能）危险且（当然）要求较高的场景，并且欢迎每个人（从初学者到长期专业人士）参与。&lt;/p&gt;&lt;p&gt;不要忘记将这种激动人心的体验添加到您未来几周的日程安排中！&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;&lt;strong&gt;赋予我们力量&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;邀请女性、非二元个体和盟友的与会者参加这项网络活动，就我们快速发展的生态系统中的挑战、领导力、创新和赋权进行公开讨论。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;&lt;strong&gt;现在注册！&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;a href="https://events.linuxfoundation.org/cloudnativesecuritycon-north-america/register/"&gt;早鸟注册&lt;/a&gt;优惠截止日期为 5 月 19 日。如果您在学术界，注册比例会降低。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;免费儿童看护&lt;/strong&gt;CNCF 为 12 岁以下儿童提供免费现场儿童看护。如需注册，请在太平洋夏令时间 2024 年 5 月 29 日晚上 11:59 之前填写&lt;a href="https://events.linuxfoundation.org/cloudnativesecuritycon-north-america/attend/child-care/"&gt;回复表格&lt;/a&gt;。 &lt;/p&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;</description><pubDate>Wed, 08 May 2024 16:00:00 GMT</pubDate><guid isPermaLink="true">https://www.cncf.io/blog/2024/05/09/get-the-first-look-at-cloudnativesecuritycon-north-america-2024s-schedule-add-on-events-and-more/</guid></item><item><title>【KubeCon + CloudNativeCon North America 2024 and Utah’s Bathroom Bill】KubeCon + CloudNativeCon 北美 2024 和犹他州的卫生间账单</title><link>https://www.cncf.io/blog/2024/05/08/kubecon-cloudnativecon-north-america-2024-and-utahs-bathroom-bill/</link><description>&lt;p&gt;CNCF 和 Linux 基金会对犹他州立法机构通过 HB 257 感到悲伤，该法案是一项反平等权利法，通常被称为“犹他州卫生间法案”。&lt;strong&gt;尽管有新的犹他州法律，CNCF 仍致力于确保 KubeCon + CloudNativeCon North America 2024 (KubeCon NA) 为所有与会者提供一个欢迎和包容的空间。&lt;/strong&gt;请参阅我们之前一月份&lt;a href="https://events.linuxfoundation.org/2024/01/31/statement-on-anti-equal-rights-legislation-event-locations/"&gt;关于反平等权利和活动地点的声明&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;正如我们多年来在之前的会议上所做的那样，我们将继续在 KubeCon NA 上提供所有性别的卫生间。在活动和社区空间内，我们的活动工作人员和安全团队将与 CNCF 行为准则委员会合作，继续执行&lt;a href="https://github.com/cncf/foundation/blob/main/code-of-conduct.md"&gt;CNCF 行为准则&lt;/a&gt;和&lt;a href="https://events.linuxfoundation.org/kubecon-cloudnativecon-north-america/attend/code-of-conduct/"&gt;Linux 基金会活动行为准则&lt;/a&gt;，这两项准则均禁止基于性别认同的骚扰和性别表达。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;请注意，&lt;a href="https://www.equalityutah.org/news-coverage"&gt;大多数犹他州人支持 LGBTQ+ 保护&lt;/a&gt;。&lt;a href="https://www.yahoo.com/news/salt-lake-city-council-voices-152424892.html"&gt;盐湖城市长&lt;/a&gt;和&lt;a href="https://www.slc.gov/council/news/salt-lake-city-issues-statement-on-h-b-257/"&gt;盐湖城议会&lt;/a&gt;都公开反对犹他州的厕所法案，盐湖城本身拥有活跃的 LGBTQ+ 人口，在美国排名第 13 位。尽管如此，我们理解并同情社区成员的担忧。为了支持社区成员的安全，根据我们在所有 KubeCon 会议上的标准安全实践，我们将根据要求为任何与会者提供安全护送。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt; Linux 基金会和 CNCF 正在与当地组织（包括 Equality Utah、Utah Pride Center 和 Project Rainbow Utah）进行讨论，以获得他们的建议和资源，帮助我们更好地确保 KubeCon NA 在盐湖城获得积极、安全的体验来自 LGBTQ+ 社区的与会者（例如，获取 LGBTQ+ 友好餐厅和商店的列表）。 Project Rainbow 告知我们，跨性别意识周将于 11 月 13 日至 20 日在盐湖城举行，与 KubeCon NA 重叠，为与会者提供支持当地意识工作的机会（如果他们愿意的话）。当我们有更多详细信息可供分享时，我们将更新 KubeCon NA 网站的&lt;a href="https://events.linuxfoundation.org/kubecon-cloudnativecon-north-america/attend/diversity-inclusion/#utah-bathroom-bill-statement"&gt;多样性和包容性页面&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;即使做出了这些努力来提供安全和包容的空间，我们也理解为什么有些人可能会对访问犹他州感到不舒服。因此，如果任何与会者因 HB 257 改变主意，我们将全额退还其门票。此外，如果任何 CNCF 委员会、SIG、TAG 或其他团体不再愿意在盐湖城开会，但仍希望今年亲自开会，CNCF 将提供另一个面对面开会的地点，例如另一个 CNCF/LF&lt;a href="https://events.linuxfoundation.org/"&gt;活动&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;所有参加者在参加 KubeCon NA 旅行时都可以合法使用卫生间&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;我们已经研究并确认 KubeCon NA 与会者将能够合法使用会议中心、盐湖城机场、盐湖城所有酒店、餐厅、商店和全市其他私营场所的卫生间。这是因为犹他州法律仅适用于 K-12 公立学校卫生间和政府大楼内的更衣室。犹他州法律不适用于私营机构。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;此外，机场、会议中心以及与会议中心相连的凯悦酒店大堂将提供男女通用的浴室（除了男士和女士浴室之外）。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;人们普遍误解 HB 257 应用范围更广。正如&lt;a href="https://www.acluutah.org/en/know-your-rights/faqs-hb-257"&gt;犹他州 ACLU 在 HB 257 的常见问题解答中&lt;/a&gt;所解释的那样，“……事实上，新法律的范围比该法案的新闻报道所暗示的更为有限。”&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;&lt;strong&gt;目前无法更换场地&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;如果在我们评估 KubeCon NA 的潜在地点时犹他州的卫生间法案已经颁布，我们就不会选择犹他州作为我们的会议地点。然而，我们在 HB 257 推出之前就承诺将盐湖城作为 2022 年会议的举办地，并与会议中心、酒店和供应商签订了&lt;strong&gt;&lt;em&gt;具有​​法律约束力且无法取消的&lt;/em&gt;&lt;/strong&gt;合同。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;足以举办 KubeCon 北美会议（通常有 10,000 多名与会者）的会议场地提前几年就被填满。因此，为了确保场地，CNCF必须提前2-4年预订场地。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;由于这些原因，目前为 KubeCon NA 寻找替代场地是不可行的。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;取消 KubeCon NA 并不是一个可行的选择，因为取消会对我们的项目和社区产生不利影响。举办会议将人们聚集在一起进行联系、分享最佳实践和知识并推进云原生技术，对于支持我们让云原生计算无处不在的使命至关重要。同样重要的是，KubeCon 活动的&lt;a href="https://github.com/cncf/toc/blob/main/FAQ.md#what-does-cncf-do-with-its-events-revenues-especially-for-projects"&gt;收入&lt;/a&gt;用于资助基础设施、工具、安全审计、指导、奖学金以及对 CNCF 项目和社区的支持。取消 KubeCon NA 的财务影响将迫使我们减少对项目和社区的支持数百万美元。如果取消，我们也会让许多社区成员失望，他们已经投入了无数时间来为 KubeCon NA 规划、准备演讲和演示、组织同地活动和项目等。&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt; CNCF 致力于地域多样性，为所有社区成员提供服务，无论他们居住在哪里。因此，今年，除了 KubeCon 北美和 KubeCon 欧洲之外，我们还将举办 KubeCon 中国和 KubeCon 印度。我们希望通过将 KubeCon 带到更广泛的地区，让全球社区的更多人能够参加 KubeCon。如果您不愿意今年加入 KubeCon NA，请考虑参加我们的其他 KubeCon 会议或其他 CNCF 活动，其中包括 CloudNativeSecurityCon 和三个 KubeDays。 &lt;/p&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;</description><pubDate>Tue, 07 May 2024 16:00:00 GMT</pubDate><guid isPermaLink="true">https://www.cncf.io/blog/2024/05/08/kubecon-cloudnativecon-north-america-2024-and-utahs-bathroom-bill/</guid></item><item><title>【Kubernetes is turning 10! Join the party on June 6th】Kubernetes 已经 10 岁了！ 6月6日参加聚会</title><link>https://www.cncf.io/blog/2024/05/07/kubernetes-is-turning-10-join-the-party-on-june-6th/</link><description>&lt;p&gt;在过去的 10 年里， &lt;a href="http://kubernetes.io/"&gt;Kubernetes&lt;/a&gt;已成为现代应用程序部署的支柱，并彻底改变了创新的进程。&lt;/p&gt;&lt;p&gt; Kubernetes 是 2016 年 3 月第一个被 CNCF 孵化器&lt;a href="https://www.cncf.io/announcements/2016/03/10/cloud-native-computing-foundation-accepts-kubernetes-as-first-hosted-project-technical-oversight-committee-elected/"&gt;接纳的&lt;/a&gt;项目，至今仍是顶级开源项目。 Kubernetes 不仅打破了人们对自己的期望，还为整个 CNCF 生态系统树立了北极星。此后，CNCF 已发展到超过 184 个云原生项目，Kubernetes 在 CNCF 中的成功为其他项目奠定了基础。&lt;/p&gt;&lt;p&gt; Kubernetes 现已成为部署和操作容器化应用程序的事实上的标准。 Kubernetes 最初由 Google 开发，并于 2014 年开源发布，它建立在 15 年运行 Google 容器化工作负载的经验以及开源社区的宝贵贡献的基础上。 Kubernetes 让与部署和管理应用程序相关的一切变得更加容易。&lt;/p&gt;&lt;p&gt; &lt;a href="https://events.linuxfoundation.org/kuber10es-birthday-bash/"&gt;6 月 6 日&lt;/a&gt;，全球各地的 Kubernetes 和云原生社区将齐聚一堂，庆祝这伟大的十年，并展望下一个#KuberTENes。社区中的每个人都有机会通过以下方式#celebr8k8s。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt; &lt;strong&gt;KuberTENes 生日狂欢&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;与我们一起于 6 月 6 日在加利福尼亚州山景城的 Google&lt;a href="https://realestate.withgoogle.com/bayview"&gt;湾景园区&lt;/a&gt;参加一场有趣且难忘的现场庆祝活动。&lt;/p&gt;&lt;p&gt;生日庆典将融合重聚表演的元素，同时庆祝许多使这个项目成为可能的隐藏人物，并预览未来 10 年等待着我们的事情。我们将向那些将 Kubernetes 塑造成今天的样子的人们致敬，并讨论为什么它的重要性在未来几年只会变得越来越重要。&lt;/p&gt;&lt;p&gt;有兴趣参加吗？我们很乐意邀请​​您。门票免费，但名额有限，请尽快&lt;a href="https://events.linuxfoundation.org/kuber10es-birthday-bash/"&gt;回复&lt;/a&gt;！&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;&lt;strong&gt;生日狂欢现场直播/重播&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;无法参加山景城的派对？没问题！我们将在活动期间进行直播，并且录制内容也将在 YouTube 上供所有人观看。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt; &lt;strong&gt;KuberTENes 盒装生日派对和本地聚会&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;如果您无法在湾区参加或根本无法参加，请不要担心！您仍然可以参加当地社区的庆祝活动。请&lt;a href="https://share.hsforms.com/1feeTKzUpRqm5lnnifbqOXQ4tvhy?__hstc=160532258.e00e885cf17bfdbb3d74d6b37932e9de.1698502436143.1713989333711.1714401664068.20&amp;amp;__hssc=160532258.1.1714401664068&amp;amp;__hsfp=1717932986"&gt;在此处的框中请求 KuberTENes 聚会&lt;/a&gt;，请注意所有请求都需要在 5 月 10 日之前提出。或者，您可以与本地&lt;a href="http://community.cncf.io/"&gt;云原生聚会小组&lt;/a&gt;联系，他们已经在努力组织您所在地区的活动。列表中的一些位置（但不限于）包括：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;云原生惠灵顿&lt;/li&gt;&lt;li&gt;云原生魁北克&lt;/li&gt;&lt;li&gt;云原生卢森堡&lt;/li&gt;&lt;li&gt;云原生赫尔辛克&lt;/li&gt;&lt;li&gt;云原生达哈卡&lt;/li&gt;&lt;li&gt;云原生图表&lt;/li&gt;&lt;li&gt;云原生巴黎&lt;/li&gt;&lt;li&gt;特拉维夫云原生&lt;/li&gt;&lt;li&gt;新加坡云原生&lt;/li&gt;&lt;li&gt;云原生台湾用户组&lt;/li&gt;&lt;li&gt;云原生哥本哈根&lt;/li&gt;&lt;li&gt;云原生奥胡斯&lt;/li&gt;&lt;li&gt;云原生圣卡塔琳娜州&lt;/li&gt;&lt;li&gt;云原生纽约 Kubernetes 聚会&lt;/li&gt;&lt;li&gt;云原生洛里昂&lt;/li&gt;&lt;li&gt;云原生圣路易斯&lt;/li&gt;&lt;li&gt;云原生危地马拉&lt;/li&gt;&lt;li&gt;云原生维尔纽斯&lt;/li&gt;&lt;li&gt;伊斯坦布尔云原生&lt;/li&gt;&lt;li&gt;云原生喀拉拉邦&lt;/li&gt;&lt;li&gt;云原生 新德里&lt;/li&gt;&lt;li&gt;云原生斯德哥尔摩&lt;/li&gt;&lt;li&gt;云原生奥尔堡&lt;/li&gt;&lt;li&gt;云原生哥德堡&lt;/li&gt;&lt;li&gt;阿姆斯特丹云原生&lt;/li&gt;&lt;li&gt;云原生和 Kubernetes 奥斯陆&lt;/li&gt;&lt;li&gt;云原生达拉斯&lt;/li&gt;&lt;li&gt;云原生圣保罗&lt;/li&gt;&lt;li&gt;云原生慕尼黑&lt;/li&gt;&lt;li&gt;班加罗尔云原生&lt;/li&gt;&lt;li&gt;云原生盐湖城&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;而且，无论您参加其中一项活动，请务必参加盐湖城最大的 Kubernetes 爱好者聚会&lt;a href="https://events.linuxfoundation.org/kubecon-cloudnativecon-north-america/"&gt;KubeCon + CloudNativeCon North America&lt;/a&gt; ，我们计划在那里继续举办 10 周年庆祝活动。 &lt;/p&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;</description><pubDate>Mon, 06 May 2024 16:00:00 GMT</pubDate><guid isPermaLink="true">https://www.cncf.io/blog/2024/05/07/kubernetes-is-turning-10-join-the-party-on-june-6th/</guid></item><item><title>【Adding color-blind themes to Kubecolor to make Kubernetes more inclusive】为 Kubecolor 添加色盲主题，让 Kubernetes 更具包容性</title><link>https://www.cncf.io/blog/2024/05/06/adding-color-blind-themes-to-kubecolor-to-make-kubernetes-more-inclusive/</link><description>&lt;p&gt;&lt;em&gt;大使帖子最初发布于&lt;a href="https://piratemakers.ca/posts/2024/04/adding-color-blind-themes-to-kubecolor-to-make-kubernetes-more-inclusive/"&gt;Sebastian “Prune” Thomas 的博客&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&lt;figure class="wp-block-image size-full"&gt;&lt;img alt="常见的 Kubecolor、红色盲、绿色盲和蓝色盲" class="wp-image-107261" height="1358" src="https://www.cncf.io/wp-content/uploads/2024/05/image-19.jpg" width="1812" /&gt;&lt;/figure&gt;&lt;p&gt; &lt;a href="https://github.com/kubecolor/kubecolor"&gt;Kubcolor&lt;/a&gt;是&lt;code&gt;kubectl&lt;/code&gt;命令的一个薄包装器，可以为输出添加颜色。&lt;/p&gt;&lt;p&gt;我克隆了该项目并在 2022 年开始维护它，当时原作者不再活跃。 &lt;/p&gt;&lt;figure class="wp-block-image size-full"&gt;&lt;img alt="库比颜色标志" class="wp-image-107263" height="2464" src="https://www.cncf.io/wp-content/uploads/2024/05/image-19.png" width="3120" /&gt;&lt;/figure&gt;&lt;p&gt; KubeColor 可以重新格式化大多数&lt;code&gt;kubectl&lt;/code&gt;命令的输出以添加颜色和清晰度。它使阅读输出变得&lt;em&gt;如此容易&lt;/em&gt;，但我仍然不明白它没有得到更广泛的使用。实际上，如果您想要视频推介，我&lt;a href="https://www.youtube.com/live/PWZJzjB7vso?si=CvfnmmdSZP3txENZ&amp;amp;t=32723"&gt;在巴黎举行的 KubeCon 2024 年欧洲云原生拒绝大会上对此进行了一次简短的演讲&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;在上一个项目中详细讨论过的最长需求的功能之一是能够自定义 KubeColor 使用的颜色主题。&lt;/p&gt;&lt;p&gt;实际上，当我第一次克隆原始项目时，我应用了一个全局更改颜色的补丁，以使思考变得更少色彩和更标准，仅限于较小的一组颜色。有些人立刻开始抱怨，但无论如何人们就是这么做的。&lt;/p&gt;&lt;p&gt;从&lt;strong&gt;版本 0.3.0&lt;/strong&gt;开始， &lt;code&gt;kubecolor&lt;/code&gt;现在支持自定义配色方案和主题，这要归功于其他主要贡献者&lt;a href="https://github.com/applejag"&gt;AppleJag&lt;/a&gt;的工作，AppleJag 是一位才华横溢的 (Go) 开发者。 Jag，我非常感谢你为这个项目提供的所有帮助。 &lt;/p&gt;&lt;figure class="wp-block-image size-full"&gt;&lt;img alt="代码示例" class="wp-image-107264" height="280" src="https://www.cncf.io/wp-content/uploads/2024/05/image-20.png" width="1788" /&gt;&lt;/figure&gt;&lt;h2 class="wp-block-heading"&gt;&lt;strong&gt;有什么问题 ？&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;默认情况下， &lt;code&gt;kubecolor&lt;/code&gt;使用终端配置中的颜色集，因此始终可以对其进行配置。只需更改终端的主题，您就可以根据您的需要调整颜色！&lt;/p&gt;&lt;p&gt;但除了默认颜色之外，有些人还想对某些特定字段进行不同的着色，或者使用更多颜色来进一步区分事物。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;strong&gt;但还有更多……&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;根据&lt;a href="https://enchroma.com/blogs/beyond-color/interesting-facts-about-color-blindness"&gt;这篇文章&lt;/a&gt;，每 12 个人中就有一个患有某种&lt;strong&gt;色盲&lt;/strong&gt;（或色障碍）。女性的关注度要低一些，只有 200 人中就有 1 人担心，但仍然很多！ （数字也可能因网站而异......）&lt;/p&gt;&lt;p&gt;查看&lt;a href="https://en.wikipedia.org/wiki/Color_blindness"&gt;维基百科&lt;/a&gt;页面以了解更多信息，还有大量其他网站与此相关。尽管如此，我们通常不会立即想到这一点。&lt;/p&gt;&lt;p&gt;例如，只要看看&lt;a href="https://piratemakers.ca/posts/"&gt;我的博客&lt;/a&gt;，它是低对比度的灰色，你就会明白色盲并不是我当时主要担心的问题。&lt;/p&gt;&lt;p&gt;而且，当我们考虑包容性时，通常会考虑性别和肤色；而当我们考虑无障碍时，会考虑行动障碍、聋哑人和盲人。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;色盲&lt;/strong&gt;通常不会被提及或关注。 &lt;a href="https://contribute.cncf.io/accessibility/"&gt;CNCF网站本身&lt;/a&gt;并没有直接提到它。 &lt;code&gt;Accessibility&lt;/code&gt;部分中唯一的 TAG（技术咨询小组）&lt;a href="https://contribute.cncf.io/accessibility/deaf-and-hard-of-hearing/"&gt;专注于听力问题&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;也许是因为色盲更容易忍受，或者因为人们不会羞耻地谈论它，这仍然是一个真正的问题，而且数字很大，远远超过我一直相信的。&lt;/p&gt;&lt;p&gt;请注意，我并不是试图将其中任何一个与其他人进行比较，或者试图代表受影响的人发言。我没有受到损害，我只是想对包容性有所了解。&lt;/p&gt;&lt;h2 class="wp-block-heading" id="so-what-to-do-with-this-"&gt;那么，该怎么办呢？&lt;/h2&gt;&lt;p&gt;一旦&lt;code&gt;kubecolor&lt;/code&gt;获得了颜色主题功能，我就开始考虑为各种色盲添加一个或多个颜色主题。&lt;/p&gt;&lt;p&gt;我想到的第一个问题是： &lt;/p&gt;&lt;blockquote class="wp-block-quote is-style-smaller-quote is-layout-flow wp-block-quote-is-layout-flow"&gt;&lt;p&gt;通常用&lt;code&gt;green&lt;/code&gt;表示好的事情（成功），用&lt;code&gt;red&lt;/code&gt;表示坏的事情（错误）。但是色盲者有一个共同的模式吗？&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;嗯，到目前为止我还没有答案。但在搜索过程中我学到了一些东西：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;颜色很重要，但&lt;code&gt;contrast&lt;/code&gt;也很重要&lt;/li&gt;&lt;li&gt;还有&lt;strong&gt;粗体&lt;/strong&gt;和&lt;em&gt;斜体&lt;/em&gt;等修饰符可以帮助更好地区分事物&lt;/li&gt;&lt;li&gt;通常最好添加一些解释状态的文本，而不仅仅是依赖颜色。在这里，对我们来说没有问题，因为我们正在为已经富有表现力的文本&lt;em&gt;添加&lt;/em&gt;颜色。&lt;/li&gt;&lt;li&gt;也许我根本不应该添加主题，每个人都会构建自己的主题&lt;/li&gt;&lt;/ul&gt;&lt;h2 class="wp-block-heading" id="understanding-kubecolor-themes"&gt;了解 KubeColor 主题&lt;/h2&gt;&lt;p&gt;感谢 Jag， &lt;code&gt;kubecolor&lt;/code&gt;可以处理&lt;a href="https://github.com/kubecolor/kubecolor/blob/main/README.md#color-theme"&gt;多种定义来配置颜色&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;简而言之：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;使用常规&lt;strong&gt;颜色名称&lt;/strong&gt;（如红色、蓝色）将使用&lt;code&gt;terminal&lt;/code&gt;应用程序主题中定义的任何颜色名称。 &lt;code&gt;white&lt;/code&gt;可能是白色，也可能不是，但&lt;em&gt;如果&lt;/em&gt;您已经有一个针对色盲的主题，您可能不需要更改任何内容。&lt;/li&gt;&lt;li&gt;使用许多其他方法来定义颜色，例如十六进制和 RGB 值，将允许使用不属于终端主题的自定义颜色。&lt;/li&gt;&lt;li&gt;使用&lt;code&gt;bg=&lt;/code&gt;或&lt;code&gt;fg=&lt;/code&gt;将允许更改背景或前面（文本）颜色。&lt;/li&gt;&lt;li&gt;可以使用任何&lt;code&gt;modifiers&lt;/code&gt; （如&lt;strong&gt;粗体&lt;/strong&gt;、&lt;em&gt;斜体&lt;/em&gt;等）来更好地调整每个字段的可见性。&lt;/li&gt;&lt;li&gt;感谢所有&lt;code&gt;KUBECOLOR_THEME_*&lt;/code&gt; ENV 变量，可以完全自定义“每个”字段的输出，具体取决于针对&lt;code&gt;kubectl&lt;/code&gt;使用的原始命令（如&lt;code&gt;get&lt;/code&gt;或&lt;code&gt;describe&lt;/code&gt; ）。&lt;/li&gt;&lt;li&gt;可以通过创建&lt;code&gt;~/.kube/color.yaml&lt;/code&gt;文件（在 OsX 和 Linux 中，在 Windows 上可能是不同的位置）将主题创建为文件，也可以共享它。我们稍后将深入讨论格式，请继续阅读。&lt;/li&gt;&lt;li&gt; &lt;code&gt;kubecolor&lt;/code&gt;在深色和浅色模式下嵌入默认主题：&lt;ul&gt;&lt;li&gt;黑暗的&lt;img alt="图像" src="https://piratemakers.ca/posts/2024/04/adding-color-blind-themes-to-kubecolor-to-make-kubernetes-more-inclusive/images/dark-theme.png" /&gt;&lt;/li&gt;&lt;li&gt;光&lt;/li&gt;&lt;li&gt;pre-0.0.21-dark：原始项目中的先前颜色模式&lt;img alt="图像" src="https://piratemakers.ca/posts/2024/04/adding-color-blind-themes-to-kubecolor-to-make-kubernetes-more-inclusive/images/pre-0.0.21-dark-theme.png" /&gt;&lt;/li&gt;&lt;li&gt; 0.0.21 之前的版本&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;您可以在&lt;a href="https://github.com/kubecolor/kubecolor/blob/main/config/theme.go#L15"&gt;config/theme.go&lt;/a&gt;文件中的代码中查看各个基本主题的内容。&lt;/p&gt;&lt;h2 class="wp-block-heading" id="how-to-build-a-theme"&gt;如何建立主题&lt;/h2&gt;&lt;p&gt;如前所述，您可以使用&lt;code&gt;KUBECOLOR_THEME_*&lt;/code&gt;环境变量或在&lt;code&gt;~/.kube/color.yaml&lt;/code&gt;文件中创建主题。&lt;/p&gt;&lt;h3 class="wp-block-heading" id="using-env-variables"&gt;使用 ENV 变量&lt;/h3&gt;&lt;p&gt;最简单的方法是查看&lt;a href="https://github.com/kubecolor/kubecolor/blob/main/README.md#color-theme"&gt;https://github.com/kubecolor/kubecolor/blob/main/README.md#color-theme&lt;/a&gt;上的文档并进行实验。&lt;/p&gt;&lt;p&gt;无论如何，您必须通过设置&lt;code&gt;KUBECOLOR_PRESET&lt;/code&gt;选择一个&lt;code&gt;base&lt;/code&gt;主题，然后更新一些颜色。例如，您可以使用以下命令将所有&lt;code&gt;running&lt;/code&gt; Pod 更改为蓝色：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-xml" lang="xml"&gt;KUBECOLOR_THEME_BASE_SUCCESS=blue KUBECOLOR_PRESET=dark kubecolor get pods -o wide&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;重击&lt;/p&gt;&lt;figure class="wp-block-image size-full"&gt;&lt;img alt="代码示例" class="wp-image-107265" height="226" src="https://www.cncf.io/wp-content/uploads/2024/05/image-21.png" width="2360" /&gt;&lt;/figure&gt;&lt;h3 class="wp-block-heading" id="using-the-config-file"&gt;使用配置文件&lt;/h3&gt;&lt;p&gt;创建文件&lt;code&gt;~/.kube/color.yaml&lt;/code&gt;并添加一些内容，例如：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-javascript" lang="javascript"&gt;preset: dark theme: table: header: fg=red:bold:bg=blue&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; YAML&lt;/p&gt;&lt;p&gt;所以基本上，你获取 ENV 变量并嵌套它的最后一部分。&lt;/p&gt;&lt;p&gt;使用&lt;code&gt;KUBECOLOR_THEME_STATUS_ERROR&lt;/code&gt; ，您可以删除&lt;code&gt;KUBECOLOR&lt;/code&gt;部分，因此最终路径是&lt;code&gt;theme.status.error&lt;/code&gt; ，因此以粉红色显示错误的 pod：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-javascript" lang="javascript"&gt;preset: dark theme: table: header: fg=red:bold:bg=blue status: error: pink&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; YAML &lt;/p&gt;&lt;figure class="wp-block-image size-full"&gt;&lt;img alt="代码示例" class="wp-image-107266" height="226" src="https://www.cncf.io/wp-content/uploads/2024/05/image-22.png" width="2360" /&gt;&lt;/figure&gt;&lt;h2 class="wp-block-heading" id="color-blind-theme"&gt;色盲主题&lt;/h2&gt;&lt;p&gt;首先，我想明确声明我没有任何色盲，我在这里试图实现的工作是基于我读过的文章以及与色盲人士的一些交谈。我这边没有任何科学工作。&lt;/p&gt;&lt;p&gt;我们的想法是提供一个开箱即用的解决方案来帮助色盲患者。结果可能不完美，甚至没有用，我不承担任何责任。已经是尽力了它是开源的。和我一起裸露。&lt;/p&gt;&lt;p&gt;经过一番研究，我发现了&lt;a href="https://asada.website/webCVS/index.html"&gt;Cromatic Vision Simulator 网站&lt;/a&gt;，该网站允许加载图像，并使用四视图查看色盲者根据残疾类型可能看到的内容。&lt;/p&gt;&lt;p&gt;简而言之，如果我上传捕获&lt;code&gt;k get pods -o wide&lt;/code&gt;命令的先前图像之一，我们可以使用&lt;code&gt;dark&lt;/code&gt;主题检查它的外观：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;常规视图&lt;img alt="图像" src="https://piratemakers.ca/posts/2024/04/adding-color-blind-themes-to-kubecolor-to-make-kubernetes-more-inclusive/images/get-pods-dark.png" /&gt;&lt;/li&gt;&lt;li&gt;红色盲视图&lt;img alt="图像" src="https://piratemakers.ca/posts/2024/04/adding-color-blind-themes-to-kubecolor-to-make-kubernetes-more-inclusive/images/get-pods-dark-protanopia.png" /&gt;&lt;/li&gt;&lt;li&gt;绿盲观&lt;img alt="图像" src="https://piratemakers.ca/posts/2024/04/adding-color-blind-themes-to-kubecolor-to-make-kubernetes-more-inclusive/images/get-pods-dark-deuteranopia.png" /&gt;&lt;/li&gt;&lt;li&gt;蓝色盲视图&lt;img alt="图像" src="https://piratemakers.ca/posts/2024/04/adding-color-blind-themes-to-kubecolor-to-make-kubernetes-more-inclusive/images/get-pods-dark-tritanopia.png" /&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;现在我想我们都明白了当前&lt;code&gt;dark&lt;/code&gt;主题配色方案的问题：任何受损的人都会丢失大部分颜色信息。此时，最好使用普通的&lt;code&gt;kubectl&lt;/code&gt;命令......&lt;/p&gt;&lt;p&gt;因此，我测试了一些半音级数，试图找到一个至少在大多数情况下都可以正常工作的调色板： &lt;/p&gt;&lt;figure class="wp-block-image size-full"&gt;&lt;img alt="调色板" class="wp-image-107267" height="1122" src="https://www.cncf.io/wp-content/uploads/2024/05/image-23.png" width="1980" /&gt;&lt;/figure&gt;&lt;p&gt;色盲不仅仅是看不到绿色或红色，感知的色调也相当有限，因此从绿色到红色的所有颜色（对于普通眼睛来说颜色变化缓慢）几乎都是相同的棕色/对于 Protanopian 来说呈黄色。&lt;/p&gt;&lt;p&gt;我的最终结论是，似乎有可能实现一个有助于更好地区分内容的主题。这里我们需要的是使用不同的色调来显示好坏情况的差异，以及有桌子时的颜色循环。&lt;/p&gt;&lt;p&gt;使用&lt;a href="https://observablehq.com/@d3/color-schemes"&gt;Observable HQ 网站&lt;/a&gt;，我使用&lt;code&gt;discrete 10&lt;/code&gt;模式将彩虹切割成 10 种可用颜色：&lt;/p&gt;&lt;ul&gt;&lt;li&gt; &lt;code&gt;#23171b&lt;/code&gt;&lt;/li&gt;&lt;li&gt; &lt;code&gt;#4860e6&lt;/code&gt;&lt;/li&gt;&lt;li&gt; &lt;code&gt;#2aabee&lt;/code&gt;&lt;/li&gt;&lt;li&gt; &lt;code&gt;#2ee5ae&lt;/code&gt;&lt;/li&gt;&lt;li&gt; &lt;code&gt;#6afd6a&lt;/code&gt;&lt;/li&gt;&lt;li&gt; &lt;code&gt;#c0ee3d&lt;/code&gt;&lt;/li&gt;&lt;li&gt; &lt;code&gt;#feb927&lt;/code&gt;&lt;/li&gt;&lt;li&gt; &lt;code&gt;#fe6e1a&lt;/code&gt;&lt;/li&gt;&lt;li&gt; &lt;code&gt;#c2270a&lt;/code&gt;&lt;/li&gt;&lt;li&gt; &lt;code&gt;#900c00&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;渲染后，我们有： &lt;/p&gt;&lt;figure class="wp-block-image size-full"&gt;&lt;img alt="常见、红色盲、绿色盲、蓝色盲的颜色方案" class="wp-image-107268" height="1461" src="https://www.cncf.io/wp-content/uploads/2024/05/image-24.jpg" width="1596" /&gt;&lt;/figure&gt;&lt;p&gt; &lt;code&gt;dark&lt;/code&gt;主题仅使用 6 种颜色（如果深色主题默认为白色，浅色主题默认为黑色，则 5 种颜色为一种）。所以这是我的选择：&lt;/p&gt;&lt;figure class="wp-block-table"&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;端子颜色&lt;/th&gt;&lt;th&gt;配色&lt;/th&gt;&lt;th&gt;红色盲&lt;/th&gt;&lt;th&gt;绿色盲&lt;/th&gt;&lt;th&gt;蓝色盲&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;code&gt;yellow&lt;/code&gt;&lt;/td&gt;&lt;td&gt; &lt;code&gt;#feb927&lt;/code&gt;&lt;/td&gt;&lt;td&gt; &lt;code&gt;#f9bb27&lt;/code&gt;&lt;/td&gt;&lt;td&gt; &lt;code&gt;#fbbc23&lt;/code&gt;&lt;/td&gt;&lt;td&gt; &lt;code&gt;#ffacb6&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;code&gt;magenta&lt;/code&gt;&lt;/td&gt;&lt;td&gt; &lt;code&gt;#4860e6&lt;/code&gt;&lt;/td&gt;&lt;td&gt; &lt;code&gt;#a77fe5&lt;/code&gt;&lt;/td&gt;&lt;td&gt; &lt;code&gt;#888ee4&lt;/code&gt;&lt;/td&gt;&lt;td&gt; &lt;code&gt;#257e7d&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;code&gt;green&lt;/code&gt;&lt;/td&gt;&lt;td&gt; &lt;code&gt;#6afd6a&lt;/code&gt;&lt;/td&gt;&lt;td&gt; &lt;code&gt;#fee16c&lt;/code&gt;&lt;/td&gt;&lt;td&gt; &lt;code&gt;#fee16c&lt;/code&gt;&lt;/td&gt;&lt;td&gt; &lt;code&gt;#fee16c&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;code&gt;red&lt;/code&gt;&lt;/td&gt;&lt;td&gt; &lt;code&gt;#c2270a&lt;/code&gt;&lt;/td&gt;&lt;td&gt; &lt;code&gt;#bb8b16&lt;/code&gt;&lt;/td&gt;&lt;td&gt; &lt;code&gt;#936a15&lt;/code&gt;&lt;/td&gt;&lt;td&gt; &lt;code&gt;#ff6579&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;code&gt;cyan&lt;/code&gt;&lt;/td&gt;&lt;td&gt; &lt;code&gt;#2aabee&lt;/code&gt;&lt;/td&gt;&lt;td&gt; &lt;code&gt;#34adee&lt;/code&gt;&lt;/td&gt;&lt;td&gt; &lt;code&gt;#22afef&lt;/code&gt;&lt;/td&gt;&lt;td&gt; &lt;code&gt;#34b4b5&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;空颜色（偏白色）&lt;/td&gt;&lt;td&gt; &lt;code&gt;#2ee5ae&lt;/code&gt;&lt;/td&gt;&lt;td&gt; &lt;code&gt;#e8d0b0&lt;/code&gt;&lt;/td&gt;&lt;td&gt; &lt;code&gt;#c6beb3&lt;/code&gt;&lt;/td&gt;&lt;td&gt; &lt;code&gt;#4ddfe0&lt;/code&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;我还在&lt;code&gt;success&lt;/code&gt;时使用了&lt;code&gt;bold&lt;/code&gt; ，实际上我反转了&lt;code&gt;error&lt;/code&gt; ，因此背景是&lt;code&gt;red&lt;/code&gt; ，文本是白色的。当我们可能的颜色有限时，高对比度通常是一个好帮手。&lt;/p&gt;&lt;p&gt;结果似乎在所有情况下都有效： &lt;/p&gt;&lt;figure class="wp-block-image size-full"&gt;&lt;img alt="代码示例" class="wp-image-107269" height="270" src="https://www.cncf.io/wp-content/uploads/2024/05/image-24.png" width="1496" /&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;figure class="wp-block-image size-full"&gt;&lt;img alt="常见、红色盲、绿色盲和蓝色盲的代码示例" class="wp-image-107270" height="1476" src="https://www.cncf.io/wp-content/uploads/2024/05/image-25.jpg" width="1932" /&gt;&lt;/figure&gt;&lt;h3 class="wp-block-heading" id="using-the-themes"&gt;使用主题&lt;/h3&gt;&lt;p&gt;最后，除了之前宣布的其他 4 个主题之外，如果您担心色盲，您现在可以使用任何新主题。他们是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;红色盲-暗&lt;/li&gt;&lt;li&gt;红色盲-光&lt;/li&gt;&lt;li&gt;绿盲-暗&lt;/li&gt;&lt;li&gt;绿盲-光&lt;/li&gt;&lt;li&gt;蓝色盲-暗&lt;/li&gt;&lt;li&gt;蓝色盲-光&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;只需设置您的环境变量，例如：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-xml" lang="xml"&gt;KUBECOLOR_PRESET=protanopia-dark kubecolor get pods&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;重击&lt;/p&gt;&lt;p&gt;或者&lt;/p&gt;&lt;pre class="wp-block-code"&gt;&lt;code class="language-xml" lang="xml"&gt;export KUBECOLOR_PRESET=protanopia-dark kubecolor get pods&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;重击&lt;/p&gt;&lt;p&gt;或者在配置文件&lt;code&gt;~/.kube/color.yaml&lt;/code&gt;中设置它，如下所示：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-javascript" lang="javascript"&gt;preset: protanopia-dark&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; YAML&lt;/p&gt;&lt;h3 class="wp-block-heading" id="updating-the-theme"&gt;更新主题&lt;/h3&gt;&lt;p&gt;由于主题几乎是第一次迭代且正在进行中，如果您认为当前主题可以得到增强，请随时发表评论并&lt;a href="https://github.com/kubecolor/kubecolor/issues"&gt;提出问题&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;此外，您可以通过修改现有主题来开始创建自己的主题，然后在&lt;code&gt;issue&lt;/code&gt;或&lt;code&gt;Pull Request&lt;/code&gt;中共享它。&lt;/p&gt;&lt;p&gt;只需从原始主题文件开始，并向&lt;code&gt;~/.kube/color.yaml&lt;/code&gt;文件添加更多自定义内容：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-javascript" lang="javascript"&gt;preset: protanopia-dark theme: base: key: - fg=#feb927 - fg=white info: primary: fg=#4860e6 secondary: fg=#2aabee success: fg=#6afd6a:bold warning: fg=#feb927 danger: fg=white:bg=#c2270a muted: fg=#feb927 options: flag: fg=#feb927 table: header: fg=white:bold:bg=#2aabee status: error: fg=white:bg=#c2270a&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; YAML&lt;/p&gt;&lt;p&gt;请注意，目前所有红色盲、绿色盲和蓝色盲主题都是相同的。当您留下反馈时，请提及您的情况，以便我们可以以不同的方式更新主题，以更好地适应每种不同的情况。&lt;/p&gt;&lt;p&gt;我鼓励您根据您的残疾类型设置默认主题，以受益于未来的变化。&lt;/p&gt;&lt;h2 class="wp-block-heading" id="wrapping-it-up"&gt;把它包起来&lt;/h2&gt;&lt;p&gt;下次当您看到同事的屏幕使用奇怪的颜色时，请不要微笑或取笑，这个人可能患有某种色盲。相反，只需向他们解释 KubeColor 现在是您的朋友即可。&lt;/p&gt;&lt;p&gt;更糟糕的是，下次你看到有人在单色中使用&lt;code&gt;kubectl&lt;/code&gt;时，&lt;em&gt;坚持&lt;/em&gt;让他们去检查&lt;a href="https://github.com/kubecolor/kubecolor"&gt;Kubecolor&lt;/a&gt; ！&lt;/p&gt;&lt;p&gt;我们在这个功能上投入了大量的精力。我们真诚地希望它能够帮助一些人，并使 Kubernetes 更具包容性。如果没有的话，这也是一次很好的冒险。&lt;/p&gt;&lt;p&gt; &lt;a href="https://github.com/kubecolor/kubecolor/releases/tag/v0.3.0"&gt;Kubecolor v0.3.0&lt;/a&gt;中提供了该功能，现已推出！ &lt;/p&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;</description><pubDate>Sun, 05 May 2024 16:00:00 GMT</pubDate><guid isPermaLink="true">https://www.cncf.io/blog/2024/05/06/adding-color-blind-themes-to-kubecolor-to-make-kubernetes-more-inclusive/</guid></item><item><title>【Top 5 cloud computing trends of 2024】2024 年 5 大云计算趋势</title><link>https://www.cncf.io/blog/2024/05/03/top-5-cloud-computing-trends-of-2024/</link><description>&lt;p&gt;&lt;em&gt;会员帖子，作者： &lt;a href="https://www.msystechnologies.com/"&gt;MSys Technologies&lt;/a&gt;高级营销总监 Sameer Danave&lt;/em&gt;&lt;/p&gt;&lt;p&gt;每当我认为我已经将整个技术游戏归结为一门科学时，眨眼间就会发生一些变化。如果您像我一样对云充满热情，那么随着云趋势的不断转变，您可能也经历过同样的痛苦感觉。&lt;/p&gt;&lt;p&gt;跟上最新的技术趋势并不总是那么容易。然而，为了在竞争中保持领先地位，保持领先地位至关重要。&lt;/p&gt;&lt;p&gt;幸运的是，我直接从行业专家和 MSys 对 400 多名技术专业人士的调查中收集了您所需的有关最新云计算趋势的所有信息，并专门为您制作了&lt;a href="https://www.msystechnologies.com/technology-trends-2024/"&gt;Tech Lens 2024&lt;/a&gt;指南。让我们深入探讨本指南中 2024 年的五个主要趋势。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;strong&gt;值得关注的 5 个主要云计算趋势&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;以下是预计在未来几年将产生重大影响的前五种趋势。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;&lt;strong&gt;人工智能即服务 (AIaaS)&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;未来几年，人工智能服务与云解决方案的集成预计将出现显着增长。云基础设施在人工智能向企业开放经济和社会效益方面发挥着至关重要的作用。训练 AI 模型，例如支持 ChatGPT 的强大大语言模型 (LLM)，需要大量数据和大量计算资源。&lt;/p&gt;&lt;p&gt;企业正在从构建自己的人工智能基础设施转向选择云平台提供的人工智能即服务。这种转变使他们能够利用人工智能的变革力量，而不受管理资源的限制。人工智能即服务提供托管在云平台上的预构建人工智能模型、工具和 API，使企业能够无缝实施人工智能功能，即使没有专门的人工智能专业知识和基础设施。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;&lt;strong&gt;混合和多云策略&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;多云和混合解决方案在全球企业中变得非常受欢迎。混合多云方法整合了来自多个提供商的公共云服务，从而实现了跨不同云基础设施的可移植性。这增强了灵活性并减少了对单一供应商的依赖，从而降低了供应商锁定的风险。&lt;/p&gt;&lt;p&gt;此外，混合云解决方案提供了一种灵活的方法来管理数据存储的复杂性。通过集成公共和私有云环境，组织可以利用现有基础设施，同时获得可扩展性、安全性和冗余性。这种方法优化了存储资源分配，增强了灾难恢复能力，并提高了响应不断变化的业务需求的敏捷性。&lt;/p&gt;&lt;p&gt;此外，与其他云选项相比，混合云解决方案增强了对 IT 基础设施的控制并增强了安全性。云供应商聘请安全专家来确保数据保护，遵守严格的协议和合规措施。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;&lt;strong&gt;边缘人工智能计算&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;边缘计算领域预计在未来几年将受到巨大的关注。在传统的云模型中，数据传输到远程服务器进行处理。相比之下，边缘计算在数据源附近建立一个紧凑的计算环境。&lt;/p&gt;&lt;p&gt;这可以减少延迟并实现实时分析和决策。到 2024 年，5G 等先进网络以及节能处理器和算法的部署预计将进一步增强边缘计算的可行性，以满足不断变化的应用需求。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;&lt;strong&gt;可持续云计算&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;可持续计算预计在未来几年将出现显着增长。全球约&lt;a href="https://www.sciencedirect.com/science/article/pii/S2666389921001884"&gt;1.8% 至 3.9%&lt;/a&gt;的温室气体排放来自信息和通信技术 (ICT) 行业，这一认识推动了这一趋势。&lt;/p&gt;&lt;p&gt;绿色计算涵盖计算机、芯片和其他技术组件整个生命周期（从设计和制造到使用和处置）的环保实践。其目标是通过减少生产、数据中心和最终用户运营等各个阶段的碳排放和能源消耗来减轻对环境的影响。&lt;/p&gt;&lt;p&gt;此外，绿色计算还涉及选择可持续来源的材料、最大限度地减少电子废物以及通过使用可再生资源促进可持续性。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;&lt;strong&gt;无服务器计算&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;预计 2023 年至 2028 年间，无服务器计算将出现显着扩张，复合年增长率 (CAGR) 达到&lt;a href="https://www.mordorintelligence.com/industry-reports/serverless-computing-market"&gt;23.17%，&lt;/a&gt;无服务器计算带来了创建和运营软件应用程序和服务的新颖方法。这种新兴的范例消除了基础设施管理的必要性，使用户能够编写和部署没有底层系统复杂性的代码。&lt;/p&gt;&lt;p&gt;这种转变为开发人员带来了许多好处，包括更快的上市时间、改进的可扩展性以及降低新服务的部署成本。因此，开发人员可以专注于创新，而不是管理基础设施的复杂性。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;strong&gt;结论&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;在技​​术进步的旋风中，跟上云计算趋势既令人兴奋又至关重要。根据行业专家的见解以及 MSys 对 400 多名技术专业人士的调查，我们提炼出了 2024 年的五大趋势。从人工智能集成到可持续实践和无服务器架构，这些趋势有望重塑我们的技术方法。通过拥抱它们，我们可以推动我们的组织前进并在竞争中保持领先地位。本指南提供了可操作的见解，以有效驾驭这些趋势。让我们一起踏上这段旅程，突破云计算可能性的界限。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;关于萨米尔&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Sameer 是一位经验丰富的技术营销专业人士，拥有 16 年的全栈营销经验。他相信 2C——“客户价值”和沟通。他的所有营销活动和项目都包含在其中。&lt;/p&gt;&lt;p&gt;他推动了 phygital（实体 + 数字）活动，吸引客户并将其拉向品牌价值。他的营销策略采用全渠道、对话式营销策略（讲故事、社交和聊天机器人）、人工智能支持的入站营销，并以可靠的分析和见解为后盾，以“内容”作为策略的核心部分。&lt;/p&gt;&lt;p&gt; Sameer 是一项团队运动，需要精心计划、注重细节以及在压力下毫不费力地表现的能力。 &lt;/p&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;</description><pubDate>Thu, 02 May 2024 16:00:00 GMT</pubDate><guid isPermaLink="true">https://www.cncf.io/blog/2024/05/03/top-5-cloud-computing-trends-of-2024/</guid></item></channel></rss>