<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>CNCF - 博客</title><link>https://www.cncf.io/blog/</link><description>CNCF - 博客 - RSSHub 用爱制作(https://github.com/DIYgod/RSSHub)</description><lastBuildDate>Tue, 09 Apr 2024 16:03:52 GMT</lastBuildDate><generator>rfeed v1.1.1</generator><docs>https://github.com/svpino/rfeed/blob/master/README.md</docs><item><title>开放策略代理(OPA)在电信领域的适用性</title><link>https://www.cncf.io/blog/2024/04/08/applicability-of-open-policy-agent-opa-in-telecom-domain/</link><description>&lt;p&gt;&lt;em&gt;成员帖子，作者：Infosys Limited 高级技术架构师&lt;a href="https://www.linkedin.com/in/rakesh-girija-ramesan-nair-0462a1aa/"&gt;Rakesh Girija Ramesan Nair&lt;/a&gt;和技术架构师&lt;a href="https://www.linkedin.com/in/sherni-liz-samuel-74ba8a78/"&gt;Sherni Liz Samuel&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;抽象的：&lt;/h2&gt;&lt;p&gt;&lt;em&gt;本博客介绍了电信领域与政策相关的关键焦点领域和挑战，以及如何通过开放策略代理 (OPA) 解决这些问题，开放策略代理 (OPA) 是云原生计算基金会 (CNCF) 领域的一个毕业项目。此外，它还展示了如何通过 OPA 解决类似问题的实际示例以及在执行相同操作时的关键观察结果。&lt;/em&gt;&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;strong&gt;介绍&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;数字化转型一直是电信公司的重点关注领域，这推动了每个通信服务提供商 (CSP) 实现基础设施、运营和服务现代化，以满足多供应商和异构网络技术生态系统不断变化的需求。这一数字化转型之旅的基本方面之一是转向云原生。开始这一旅程的原始设备制造商 (OEM)、电信公司和服务提供商强调了需要通过协作活动来解决的许多挑战和实际问题。&lt;/p&gt;&lt;p&gt; CNCF 及其相关项目在汇集电信行业的主要参与者并支持构建云原生生态系统方面发挥着关键作用。 CSP 正在转向云原生架构，而 OEM 的期望是提供符合云原生原则的解决方案。从基础设施的角度来看，Kubernetes 的核心是运行所有网络工作负载和应用程序的事实上的运行时环境。&lt;/p&gt;&lt;p&gt;在这一全面转型之旅中，存在多个需要执行政策和法规的接触点。该策略是调出电信领域的关键接触点，并利用 CNCF 项目开放策略代理来加速实施过程，从而缩短上市时间。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;&lt;strong&gt;电信领域的政策驱动领域&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;本节着眼于政策和规则在电信领域发挥重要作用的关键领域&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;安全&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;正如上一节中提到的，随着网络走向数字化和云原生化，安全性变得至关重要。安全性分布在基础设施、集群、开发和工作负载的所有层面。互联网安全中心、国家标准与技术研究院等不同行业论坛已经发布了清单、指南和对策，用于在电信堆栈中安全配置和实施云原生原则。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;编排&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;部署工作负载（网络功能、应用程序等）涉及多个系统，例如域管理器、元素管理系统和域编排系统。同样，实现端到端客户服务或任何 B2B 服务都涉及跨网络域和多供应商设备/功能驱动配置。策略驱动的编排是跨各个层实现完全按需/动态编排的关键。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;数据&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;全球各地的电信公司正在采用新技术来帮助其转型。人工智能 (AI) 尤其被用来改善服务、提升客户体验并创造更多收入。为了在这个数据驱动的世界中脱颖而出，电信提供商正在尝试利用数据分析并创建跨域和设备收集各种数据（结构化、半结构化、非结构化等）的数据存储。实现更好的分析见解和提高生产力（自我修复）等预期结果的主要挑战是数据质量。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;一体化&lt;/strong&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在任何重大转型计划中，跨各种系统的集成的简化是基础。电信管理论坛 (TMForum)、欧洲电信标准协会 (ETSI) 等标准行业机构正在尽最大努力标准化网络环境中的各种接口。目的是避免任何供应商锁定并以标准化方式公开/使用数据。网络即服务 (NaaS) 正在蓬勃发展，为网络提供所需的敏捷性，以释放更多收入流和用例。验证任何集成中涉及的合同协议是一个非常重要的问题。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;strong&gt;引入开放策略代理（OPA）&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;开放策略代理 (OPA) 是一种开源通用策略引擎，有助于跨整个技术堆栈的各个部分编写、管理和执行策略。 OPA 提供了一种称为 Rego 的高级声明性语言，它定义了管理系统/应用程序的规则。&lt;/p&gt;&lt;p&gt; OPA 的主要特点如下： –&lt;/p&gt;&lt;p&gt;&lt;strong&gt;多功能性&lt;/strong&gt;： – OPA 可以被视为一种策略即代码工具，它提供了跨多个应用程序/云网络等强制执行策略的灵活性。它可以用于从简单的数据验证/API 授权，甚至基于升级的云原生部署政策。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;可重用性&lt;/strong&gt;： – 在 OPA 中定义一次的通用策略可以在多个平台上重复使用和执行，从而减少重复。除此之外，当平台或基础设施扩展时，这还可以节省开发时间、减少错误并简化策略维护。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;高性能策略决策&lt;/strong&gt;： – OPA 能够在某些用例中并行化策略评估，从而在处理庞大且复杂的数据集和策略时优化性能。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;简化的策略管理&lt;/strong&gt;： – OPA 将策略逻辑与应用程序代码解耦，从而使管理策略变得更容易、更高效。通过使用 OPA 作为核心来定义和维护整个基础设施和技术堆栈的策略，可以实现统一的策略管理。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;&lt;strong&gt;在电信领域利用 OPA 的实例&lt;/strong&gt;&lt;/h3&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;网络的提取、验证和转换框架：&lt;/strong&gt; –&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;连续数据的质量可以释放数据存储的价值，进而有助于最大限度地利用网络数据。它使电信公司能够运行高级分析，提供实时见解和机器学习驱动的预测。&lt;/p&gt;&lt;p&gt;下图是我们为 OPA 推动的网络数据存储设置的提取验证和转换框架 (EVTF)。 &lt;/p&gt;&lt;figure class="wp-block-image"&gt;&lt;img alt="电脑屏幕截图描述已自动生成" src="https://lh7-us.googleusercontent.com/A8zicKb6iuU7MjYTlp4c0RutnEmIGvcSD4eXqdiOsf1xzS5bRIAcfuUM8QIqLBuZDcBGnifW0k7hvwn5Y4efByGQROYYc1ghUgX_KfQ2ybI1lkROurMSbPX20B4kRTDrR3bKRLj0ze2hm5WqJW9FIw" /&gt;&lt;/figure&gt;&lt;p&gt;该框架的整体流程为：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;数据收集层使用各种协议（例如简单网络管理协议-SNMP、gRPC网络管理接口-GNMI等）跨域（例如网络管理系统、网元管理系统、实际设备等）连接到各种网络数据源，并收集不同的网络数据。数据（例如库存、拓扑、警报、遥测）然后被推送到消息总线以供使用。&lt;/li&gt;&lt;/ol&gt;&lt;ol start="2"&gt;&lt;li&gt;然后，数据被使用并通过根据设备类型、域和供应商配置的各个验证阶段。提取验证和转换框架 (EVTF) 利用 OPA 来执行 Rego 中定义的策略。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;可以使用 OPA 定义的一些验证规则包括：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;数据类型检查：&lt;/strong&gt;确保数据符合预期类型（例如，端口号的整数、IP 地址的字符串）。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;完整性检查：&lt;/strong&gt;确保数据没有缺失值或缺失数据记录。 &lt;strong&gt;&amp;nbsp;&lt;/strong&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;范围检查：&lt;/strong&gt;验证特定范围内的数据（例如，有效的 IP 地址范围）。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;自定义验证规则：&lt;/strong&gt;使用 Rego 函数实现更复杂的验证逻辑。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;处理所有特定电信用例/场景的抽象层被开发为自定义微服务。它充当任何协调器系统与 OPA 交互的外观。作为该服务的一部分，创建了带有驱动网络设备模型验证和转换的 Swagger 文档的定制 API。下面提供了一个示例验证 REST API 端点，它采用 4 个参数作为输入。&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;域&lt;/strong&gt;：标识数据源自的特定网络区域&lt;/li&gt;&lt;li&gt;&lt;strong&gt;设备类型&lt;/strong&gt;：指定生成数据的设备类型（例如路由器、交换机、防火墙）。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;供应商&lt;/strong&gt;：提供有关原始设备制造商的信息&lt;/li&gt;&lt;li&gt;&lt;strong&gt;输入消息&lt;/strong&gt;：这是要验证的实际数据有效负载。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;每个验证规则都是在 OPA 中利用提供的开箱即用 API 进行配置的。用于执行数据类型验证的 Rego 策略示例如下所示： – &lt;/p&gt;&lt;figure class="wp-block-image"&gt;&lt;img alt="代码" src="https://lh7-us.googleusercontent.com/Saup1Ll0U7RnnxJtNNaen1KNxdHDFO7ajEMcup13j2kXRKH-WaR2RPqw-IAdr2JMAR86Zo23CXcmu5d6NZSzJRpscju-N37L4Zj16sfVALYd51r_tcCUtrMwFoUwqkNJ2Rp_xdu1tarszEQfol-YvA" /&gt;&lt;/figure&gt;&lt;p&gt;在此示例中，datatype_string_check Rego 规则检查输入值是否符合约定的数据类型。 Rego 策略用于生成结果并为错误场景配置自定义消息。 Rego 提供导入外部数据文件的灵活性。外部文件中的可配置数据在上述 Rego 策略中引用并使用，例如 data.deviceheaders。&lt;/p&gt;&lt;p&gt;该框架的关键思想是采用与 OPA 相一致的低代码方法，使领域中小企业更容易以最小的技术依赖性配置所需的规则。&lt;/p&gt;&lt;ol start="3"&gt;&lt;li&gt;验证成功后，数据将保存到原始存储中。无效数据会通知各自的源系统，并隔离在错误存储中以供参考。&lt;/li&gt;&lt;li&gt;转换脚本从原始存储中提取经过验证/数据质量检查的数据。&lt;/li&gt;&lt;li&gt;在转换组件中，再次使用具有底层 OPA 的 EVTF 来定义将原始数据转换为通用建模格式所需的各种转换规则。以下是定义的一些转换规则： –&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;数据映射&lt;/strong&gt;：将特定于网络的数据格式转换为符合任何行业标准的通用数据模型。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;字段重命名：&lt;/strong&gt;重命名字段以与通用模型保持一致。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;数据丰富：&lt;/strong&gt;根据预定义的规则或外部来源添加附加信息。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;这里也遵循步骤 2 中详述的类似方法，展示了基于 OPA 的 EVTF 的灵活性。单一解决方案可解决两个不同领域的问题。 &lt;/p&gt;&lt;figure class="wp-block-image"&gt;&lt;img alt="代码" src="https://lh7-us.googleusercontent.com/FkGCd9xyaieq62UkoXopoHy2Ild2lS3ve-eRVcz1JISBZhILHNdgur4aObB76PLacGfgoa3KNTs3adHAucGiryDAZcrsQaE4nZN99o1wTSlqgOs8zYEHItEEU7-Sp3lKrLPqC6u1IlQie3XmBYonsw" /&gt;&lt;/figure&gt;&lt;p&gt;例如，上面的 Rego 策略显示了基于源和目标的简单转换映射逻辑。在上面的示例中，设备类型是源，要映射的数据模型类型是目标。实际映射在外部 data.json 文件下配置并导入到 Rego 策略中。&lt;/p&gt;&lt;ol start="6"&gt;&lt;li&gt;转换后的数据与通用数据模型保持一致，并被推送到转换后的存储中。&lt;/li&gt;&lt;li&gt;数据服务层从转换后的存储中提取转换后的数据，并将其作为符合各种用例的产品模型提供给不同的消费者。&lt;/li&gt;&lt;/ol&gt;&lt;ol start="2"&gt;&lt;li&gt;&lt;strong&gt;网络关联和编排策略引擎&lt;/strong&gt;： –&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;网络保障对于电信公司确保最终客户的网络可用性至关重要。编排可帮助电信公司缩短上市时间，轻松推出新产品。保证和编排齐头并进以实现自治网络。&lt;/p&gt;&lt;p&gt;下图显示了运营人工智能 (AIOPS) 平台如何与利用 OPA 驱动的关联和编排策略引擎 (COPE) 的各种网络域编排器和系统集成。 &lt;/p&gt;&lt;figure class="wp-block-image"&gt;&lt;img alt="自动生成的流程图描述" src="https://lh7-us.googleusercontent.com/Zrda_41VxXnobzw8TM96jzgscdNd58_ZnqcnfZhvgVXlluP1gEeOQbMa3LIOYalCNrcpHcK8LQeuzTY8qTz3g3Vl572SNmpEoWqp1nVNlZ9tA0v3tSIaUZ8CLvLNiauB8ftaj8yCTU9LCo0Azz6NsA" /&gt;&lt;/figure&gt;&lt;p&gt; AIOPS 平台利用其 AI/ML 功能发现网络异常和模式。这些由操作员管理员审核，以添加、修改和批准将它们存储为关联策略。然后，这些策略会更新为 COPE，在运行时用于主动解决网络问题。&lt;/p&gt;&lt;p&gt;由 OPA 驱动的关联与编排策略引擎 (COPE) 具有自定义服务，可充当任何接口应用程序的中介。所有网络级别的复杂性都在此微服务中处理，而引擎仍然是 OPA。&lt;/p&gt;&lt;p&gt;用于配置基于利用率和相关性策略的示例 Rego 策略如下所示： –&lt;/p&gt;&lt;p&gt;配置网络利用率带宽超出定义阈值时的操作。可以定义Rego策略，指定判断网络输入输出流量是否大于阈值的条件。 &lt;/p&gt;&lt;figure class="wp-block-image"&gt;&lt;img alt="代码" src="https://lh7-us.googleusercontent.com/hoSV0FVLKuwGLiWb3O9YGYrdGoScbdUX-rBqXqGPOXewPZOrK3EI0vS-DiMocjO-vv3qL3XviG7vr-K06fcuCoTlAAop-HTvjZYEsbykiIXmBjlo6kXepGPKppAj1gzjKEScqzWwUenbNHFIPOJx9Q" /&gt;&lt;/figure&gt;&lt;p&gt;在上面的例子中，我们有两个函数input_utilization和output_utilization。阈值可以通过 Spark Streaming 动态计算并配置。自定义微服务层利用此信息来丰富数据并根据定义的 Rego 策略验证数据。&lt;/p&gt;&lt;p&gt;关联警报模式的 OPA 策略示例如下所示： – &lt;/p&gt;&lt;figure class="wp-block-image"&gt;&lt;img alt="代码" src="https://lh7-us.googleusercontent.com/q-3xoF1N1QPnLOlxbE3K822_rveH9AbaENtmxb0jojt5QEmv0-DEPmkUZ0yUf250ybWWPmzROBeiTpMLH1T533w9V60HyFuWq1r6SOaooc-XhvNhamaUQIuMdKU9jow_G4FdRIT2Ei43XCd1tV1Szg" /&gt;&lt;/figure&gt;&lt;p&gt;在上面的示例中，Rego 策略检查输入警报数组并使用预配置的警报模式数组验证警报集。警报模式通过 AI/ML 识别或根据经验进行配置，以实现主动保证。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;strong&gt;推理&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;OPA 为执行基于规则和策略的检查提供了急需的灵活性。正如上面示例中所解释的，OPA 具有许多开箱即用 (OTB) 功能，并且通过一些细微的自定义，可以应用于涵盖电信堆栈的长度和广度的多个用例。 OPA 充当任何规则或策略驱动解决方案的支柱。&lt;/p&gt;&lt;p&gt; OTB&lt;/p&gt;&lt;ul&gt;&lt;li&gt; OPA 通过 CRUD 操作公开 REST API 端点。&lt;/li&gt;&lt;li&gt; OPA Rego 策略是用自然语言编写的，因此与 Drools 等其他规则引擎相比，可以非常快速地掌握。任何未来的增强或实施都不需要特定的技能。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;定制&lt;/p&gt;&lt;ul&gt;&lt;li&gt;配置驱动的解决方案方法可以通过 OPA 来实现，并进行一些小的增强。它有助于避免任何 IT/人员依赖性，从而实现自助服务并缩短响应时间。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt; Rego Playground 等工具可帮助我们随时随地开发和测试 Rego 策略。除此之外，我们还有一个广泛活跃的 OPA 社区，使其易于使用。&lt;/p&gt;&lt;p&gt; OPA在电信领域有着广泛的适用性。使用 OPA 探索、应用和转变您的网络格局。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;strong&gt;参考&lt;/strong&gt;&lt;/h2&gt;&lt;figure class="wp-block-table"&gt;&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;官方 OPA 文档&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&lt;a href="https://www.openpolicyagent.org/docs/latest/policy-language/"&gt;https://www.openpolicyagent.org/docs/latest/policy-language/&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt;&lt;strong&gt;雷戈游乐场&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&lt;a href="https://play.openpolicyagent.org/"&gt;https://play.openpolicyagent.org/&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;strong&gt;Github 社区讨论&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&lt;a href="https://github.com/open-policy-agent/community/discussions"&gt;https://github.com/open-policy-agent/community/discussions&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;td&gt; &lt;strong&gt;Github OPA 问题/功能请求&lt;/strong&gt;&lt;/td&gt;&lt;td&gt;&lt;a href="https://github.com/open-policy-agent/opa/issues"&gt;https://github.com/open-policy-agent/opa/issues&lt;/a&gt; &lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/figure&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;</description><pubDate>Sun, 07 Apr 2024 16:00:00 GMT</pubDate><guid isPermaLink="true">https://www.cncf.io/blog/2024/04/08/applicability-of-open-policy-agent-opa-in-telecom-domain/</guid></item><item><title>会员变更源码解读</title><link>https://www.cncf.io/blog/2024/04/04/membership-change-source-code-interpretation/</link><description>&lt;p&gt;&lt;em&gt;会员帖子最初由 DatenLord 发布在&lt;a href="https://medium.com/@datenlord/membership-change-source-code-interpretation-5a5e405b120a"&gt;Medium&lt;/a&gt;上&lt;/em&gt;&lt;/p&gt;&lt;figure class="wp-block-image"&gt;&lt;img alt="图像" src="https://miro.medium.com/v2/resize:fit:700/1*a6ZEBsDkU6MnIN_ZnrMe7Q.jpeg" /&gt;&lt;/figure&gt;&lt;h2 class="wp-block-heading" id="2447"&gt;背景&lt;/h2&gt;&lt;p id="ddf6"&gt;在分布式系统应用场景中，难免会增删节点或者更换节点，最简单的解决方案就是暂时关闭集群，然后直接修改配置文件添加新的节点，完成后重启集群过程。这确实可以达到我们的目的，但是它的问题也非常明显。变更期间集群不可用，这对于需要高可用性的系统来说是无法接受的。手动过程可能会导致其他错误，例如可能会降低系统的稳定性。因此，如何高效、安全地改变集群成员成为分布式系统开发的关键问题。对于Xline来说，不仅需要处理常规的变更过程，还需要将其与Curp协议集成，以确保引入集群成员资格变更不会导致前端协议出现错误。&lt;/p&gt;&lt;h2 class="wp-block-heading" id="be0f"&gt;会员动态变更的问题及解决方案&lt;/h2&gt;&lt;p id="75e7"&gt;由于Xline使用Raft作为后端协议，因此为Xline添加动态更改成员的能力需要解决Raft协议本身遇到的问题。 Raft 协议成功运行的一个关键前提是在任何给定时间只能有一个领导者。在不施加任何限制的情况下，直接向集群添加节点可能会破坏这个前提，如下图所示： &lt;/p&gt;&lt;figure class="wp-block-image"&gt;&lt;img alt="图像" src="https://miro.medium.com/v2/resize:fit:700/0*2D-SFfb8Ncsc2QwH" /&gt;&lt;/figure&gt;&lt;p id="66b8"&gt;由于网络延迟等原因，无法保证每个节点同时从C_old切换到C_new，可能的结果如下图所示。&lt;/p&gt;&lt;p id="3403"&gt;假设此时Server 1和Server 5同时开始选举，Server 1获得了Server 2的选票，满足C_old中的法定人数，成为Leader。 Server 5收到Server 3和Server 4的投票，满足C_new中的法定人数要求，成为Leader，然后同时有两个Leader，这就产生了一致性问题。&lt;/p&gt;&lt;p id="7c22"&gt;为了解决这个问题，Raft的作者提供了两种解决方案。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;共同共识&lt;/li&gt;&lt;li&gt;单步会员变更&lt;/li&gt;&lt;/ol&gt;&lt;h2 class="wp-block-heading" id="6e4e"&gt;共同共识&lt;/h2&gt;&lt;p id="cea5"&gt;联合共识本质上是在成员变更过程中添加一个中间状态。 &lt;/p&gt;&lt;figure class="wp-block-image"&gt;&lt;img alt="图像" src="https://miro.medium.com/v2/resize:fit:700/0*JtNt1XOW2oUbocXD" /&gt;&lt;/figure&gt;&lt;p id="f8ff"&gt;当 Leader 收到成员资格变更请求时，它会创建一个 C_(old, new) 配置并通过 AppendEntries 与 Follower 同步。接收到C_(old,new)的节点会同时使用这两种配置来做出决策，即选举等操作需要C_old和C_new都一致才能成功。 C_(old, new)提交后，Leader创建C_new配置并与Follower同步。&lt;/p&gt;&lt;p id="4484"&gt;在这种场景下，集群成员中间状态变化有以下几种可能：&lt;/p&gt;&lt;ol&gt;&lt;li&gt; C_(old, new)被创建然后提交，此阶段集群中可能存在C_old、C_(old, new)两种配置，此阶段任何节点想要成为Leader都需要C_old配置达成一致到它，所以不会有两个领导者。&lt;/li&gt;&lt;li&gt; C_old,new提交之后，C_new创建之前，这个阶段可能同时存在C_old,C_(old,new)两种配置，但只有使用C_(old,new)的节点才能成为Leader，因为大多数节点此阶段集群中的节点已经配置了 C_old，剩余尚未切换的节点不足以选举新的 Leader。&lt;/li&gt;&lt;li&gt; C_new 创建并提交。该阶段可能同时存在C_old、C_(old, new)、C_new 三种配置，其中C_old配置无法选举出Leader，原因如前所述.C_(old, new)而 C_new 需要 C_new 同意才能选举 Leader，这种情况下不会有两个 Leader。&lt;/li&gt;&lt;li&gt; C_new提交后，C_new独立做出决定，不会出现两个领导者。&lt;/li&gt;&lt;/ol&gt;&lt;h2 class="wp-block-heading" id="34fc"&gt;单步节点变更&lt;/h2&gt;&lt;p id="59e1"&gt;除了联合共识之外，还有另一种安全地进行集群成员身份更改的方法，那就是单步节点更改。这种方法每次只增减一个节点，这种情况下，大部分新旧配置一定会有重叠的节点，而重叠的节点只能投票给一个节点，这就保证了不会有两个Leader同时，复杂的变更行为需要转化为多个单步节点变更才能完成。 &lt;/p&gt;&lt;figure class="wp-block-image"&gt;&lt;img alt="图像" src="https://miro.medium.com/v2/resize:fit:700/0*yU6wgFTGbG_k6qJ8" /&gt;&lt;/figure&gt;&lt;p id="6139"&gt;该方案没有中间状态，只需一步操作即可完成更改。逻辑比联合共识更加简洁，没有那么多复杂的中间状态，实现会简单一点，当然它的功能没有联合共识那么强大。&lt;/p&gt;&lt;p id="391e"&gt; Xline目前的做法是单步成员变更，未来我们将增加对联合共识的支持。&lt;/p&gt;&lt;h2 class="wp-block-heading" id="17ab"&gt; Curp协议集成&lt;/h2&gt;&lt;p id="8fe0"&gt;Membership变更的主要过程可以通过后端Raft来完成，但是这个过程可能会打乱前端Curp协议的流程。正常处理时，Curp客户端会向集群中的所有节点广播Propose请求，并根据成功的Propose数量是否大于当前集群成员的superquorum数量以及是否成功来判断本次Propose是否在curp中提交。成员在创建客户端时确定，但随着成员资格的变化而变化。在成员资格变更之前，所有成员都是在创建客户端时确定的，但是引入成员资格变更之后，需要有一种机制来确保当客户端在使用旧配置时，也能检测到服务器使用的新配置并使用新的配置重试当前请求，否则可能会导致Curp协议无法正常工作。 &lt;/p&gt;&lt;figure class="wp-block-image"&gt;&lt;img alt="图像" src="https://miro.medium.com/v2/resize:fit:700/0*7fFD3-m1z5uCFN1W" /&gt;&lt;/figure&gt;&lt;p id="698c"&gt;如图所示，假设Client向三节点集群广播一个Propose，那么Client收到三个（3节点的superquorum）成功响应，则认为该Propose已在Curp中提交。在此提议过程中，集群成员资格发生变化，Server4 加入集群。但节点 4 的 superquorum 为 4，这意味着 3 节点集群中 curp 刚刚提交的请求在成员资格变更后不再满足 Curp 的提交条件，可能会导致该请求丢失已退还给客户。&lt;/p&gt;&lt;p id="a0bc"&gt;为了解决这个问题，我们为外部客户端发送的请求引入了一个新字段&lt;code&gt;cluster_version&lt;/code&gt; ，它表示集群当前使用的配置版本，并且每次执行成员资格更改时都会进行修改。这样Server就可以通过该字段来判断发送请求的客户端是否使用了正确的配置，而使用错误的配置则直接拒绝该请求。 Client 检测到&lt;code&gt;cluster_version&lt;/code&gt;不一致后，会主动从 Server 上拉取当前配置，并以新配置发起新一轮请求。在上面的例子中，当Propose和membership变更同时发生时，Server1、2、3中的节点之一必须使用新的配置，这样该节点就会拒绝使用另一个&lt;code&gt;cluster_version&lt;/code&gt;的Propose。当Client检测到新的配置后&lt;code&gt;cluster_version&lt;/code&gt; ，它将从集群中重新拉取当前成员配置，并使用新配置重试整个请求。&lt;/p&gt;&lt;h2 class="wp-block-heading" id="1c69"&gt;源码解读&lt;/h2&gt;&lt;h2 class="wp-block-heading" id="0acd"&gt;领导者发起成员变更&lt;/h2&gt;&lt;p id="00d0"&gt;发起成员资格变更的第一步是向 Leader 发送&lt;code&gt;ProposeConfChangeRequest&lt;/code&gt; ，其中包含本次提案中要变更的节点信息以及其他一些辅助字段。&lt;/p&gt;&lt;p id="0aa4"&gt;当Server收到请求时，首先检查请求的&lt;code&gt;cluster_version&lt;/code&gt;是否与集群当前的&lt;code&gt;cluster_version&lt;/code&gt;匹配，不匹配的请求会被拒绝，然后再进入Server的处理逻辑：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;/// Handle `propose_conf_change` request pub(super) fn handle_propose_conf_change( &amp;amp;self, propose_id: ProposeId, conf_changes: Vec&amp;lt;ConfChange&amp;gt;, ) -&amp;gt; Result&amp;lt;(), CurpError&amp;gt; { // ... self.check_new_config(&amp;amp;conf_changes)?; let entry = log_w.push(st_r.term, propose_id, conf_changes.clone())?; debug!(&amp;quot;{} gets new log[{}]&amp;quot;, self.id(), entry.index); let (addrs, name, is_learner) = self.apply_conf_change(conf_changes); self.ctx .last_conf_change_idx .store(entry.index, Ordering::Release); let _ig = log_w.fallback_contexts.insert( entry.index, FallbackContext::new(Arc::clone(&amp;amp;entry), addrs, name, is_learner), ); // ... }&lt;/code&gt;&lt;/pre&gt;&lt;p id="2d03"&gt; Leader节点在处理时会通过&lt;code&gt;check_new_config&lt;/code&gt;方法检查本次conf变更的有效性，提前拒绝无法处理的变更，比如插入已经存在的节点或者删除不存在的节点。一旦检查通过，它就会经历与常规请求相同的过程，通过共识同步到所有 Follower。除了同一过程的这一部分之外，conf 更改还需要一些特殊处理，在将新配置插入日志后立即应用新配置，并记录用于回滚配置的上下文。这和Raft论文中提到的一样，节点拥有日志后，不需要等待它提交，它会立即生效。在Raft中，未提交的日志是可以被覆盖的，因此需要记录上下文，如果日志被覆盖，则可以利用这个上下文来回滚更改。&lt;/p&gt;&lt;h2 class="wp-block-heading" id="f17d"&gt;关注者处理成员变更&lt;/h2&gt;&lt;p id="9721"&gt;对于Follower节点来说，成员变更的主要逻辑发生在&lt;code&gt;handle_append_entries&lt;/code&gt;中，用于处理Leader发送的日志，包括conf的变更。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;pub(super) fn handle_append_entries( &amp;amp;self, term: u64, leader_id: ServerId, prev_log_index: LogIndex, prev_log_term: u64, entries: Vec&amp;lt;LogEntry&amp;lt;C&amp;gt;&amp;gt;, leader_commit: LogIndex, ) -&amp;gt; Result&amp;lt;u64, (u64, LogIndex)&amp;gt; { // ... // append log entries let mut log_w = self.log.write(); let (cc_entries, fallback_indexes) = log_w .try_append_entries(entries, prev_log_index, prev_log_term) .map_err(|_ig| (term, log_w.commit_index + 1))?; // fallback overwritten conf change entries for idx in fallback_indexes.iter().sorted().rev() { let info = log_w.fallback_contexts.remove(idx).unwrap_or_else(|| { unreachable!(&amp;quot;fall_back_infos should contain the entry need to fallback&amp;quot;) }); let EntryData::ConfChange(ref conf_change) = info.origin_entry.entry_data else { unreachable!(&amp;quot;the entry in the fallback_info should be conf change entry&amp;quot;); }; let changes = conf_change.clone(); self.fallback_conf_change(changes, info.addrs, info.name, info.is_learner); } // apply conf change entries for e in cc_entries { let EntryData::ConfChange(ref cc) = e.entry_data else { unreachable!(&amp;quot;cc_entry should be conf change entry&amp;quot;); }; let (addrs, name, is_learner) = self.apply_conf_change(cc.clone()); let _ig = log_w.fallback_contexts.insert( e.index, FallbackContext::new(Arc::clone(&amp;amp;e), addrs, name, is_learner), ); } // ... }&lt;/code&gt;&lt;/pre&gt;&lt;p id="b946"&gt;常规日志的处理这里不再赘述。当Follower尝试追加来自Leader的日志时，它会确定当前节点上有哪些新的conf更改日志可用，以及哪些尚未提交的conf更改将被覆盖。然后，使用预先记录的上下文，以相反的顺序回滚被覆盖的更改并应用新的更改。应用新更改时，还应在此处记录新更改的上下文。&lt;/p&gt;&lt;h2 class="wp-block-heading" id="2b2e"&gt;成员变更日志的提交&lt;/h2&gt;&lt;pre class="wp-block-code"&gt;&lt;code class=""&gt;async fn worker_as&amp;lt;C: Command, CE: CommandExecutor&amp;lt;C&amp;gt;, RC: RoleChange&amp;gt;( entry: Arc&amp;lt;LogEntry&amp;lt;C&amp;gt;&amp;gt;, prepare: Option&amp;lt;C::PR&amp;gt;, ce: &amp;amp;CE, curp: &amp;amp;RawCurp&amp;lt;C, RC&amp;gt;, ) -&amp;gt; bool { // ... let success = match entry.entry_data { EntryData::ConfChange(ref conf_change) =&amp;gt; { // ... let shutdown_self = change.change_type() == ConfChangeType::Remove &amp;amp;&amp;amp; change.node_id == id; // ... if shutdown_self { curp.shutdown_trigger().self_shutdown(); } true } _ =&amp;gt; // ... }; ce.trigger(entry.inflight_id(), entry.index); success }&lt;/code&gt;&lt;/pre&gt;&lt;p id="44ff"&gt;在提交conf更改后的aftersync阶段，除了一些常规操作外，我们还需要确定提交的conf更改是否删除了当前节点，如果是，我们需要在这里关闭当前节点。一般情况下，只有Leader节点会在这里执行并提交被移除节点的日志，并且在其自行关闭后，其余节点将选举出具有最新日志的Leader。&lt;/p&gt;&lt;h2 class="wp-block-heading" id="5b6a"&gt;新节点加入集群&lt;/h2&gt;&lt;p id="886a"&gt;为了区分创建新集群运行的节点和需要加入现有集群的新启动节点，启动时需要传入一个新参数&lt;code&gt;InitialClusterState&lt;/code&gt; 。这是一个只有两个成员的枚举类型。 &lt;code&gt;InitialClusterState::New&lt;/code&gt;表示本次启动的节点是新启动的集群的成员之一； &lt;code&gt;InitialClusterState::Existing&lt;/code&gt;表示本次启动的节点是一个要添加到现有集群中的新节点。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;let cluster_info = match *cluster_config.initial_cluster_state() { InitialClusterState::New =&amp;gt; init_cluster_info, InitialClusterState::Existing =&amp;gt; get_cluster_info_from_remote( &amp;amp;init_cluster_info, server_addr_str, &amp;amp;name, Duration::from_secs(3), ) .await .ok_or_else(|| anyhow!(&amp;quot;Failed to get cluster info from remote&amp;quot;))?, _ =&amp;gt; unreachable!(&amp;quot;xline only supports two initial cluster states: new, existing&amp;quot;), };&lt;/code&gt;&lt;/pre&gt;&lt;p id="574e"&gt;这两种方式的本质区别在于，当创建一个新的集群时，每个节点的初始集群成员都是相同的，并且可以直接根据这个初始信息计算出全局统一的节点ID，以保证每个节点都有唯一的ID ，而在加入已有集群时，新节点无法自行计算节点ID，需要通过get_cluster_info_from_remote方法获取已有集群的信息，直接继承已有集群正在使用的ID等信息，以保证ID与集群内节点的对应关系。这样可以保证集群中ID与节点的对应关系，避免ID重复或者一个节点有多个ID。&lt;/p&gt;&lt;p id="cd9e"&gt;为了确保与etcd接口的兼容性，新节点在开始运行之前没有名称。 etcdctl根据name是否为空来判断对应节点是否已经启动。当新节点启动并运行并加入集群后，它会向 Leader 发送 Publish Rpc，以在集群中发布其名称。&lt;/p&gt;&lt;h2 class="wp-block-heading" id="f198"&gt;节点删除&lt;/h2&gt;&lt;p id="4747"&gt;假设我们删除一个节点后没有关闭它，那么它会选择一个超时并向其余节点发送投票请求，浪费其他节点的网络和CPU资源。为了解决这个问题，我们可以想到两种方法。&lt;/p&gt;&lt;p id="6803"&gt; 1. 在应用将自行删除的新配置后，立即关闭节点。显然，这个方案一定是不可行的。因为在应用新的配置时，这条日志还没有提交，仍然有被备份的可能，如果你在这里关闭了自己，​​那么如果后面发生了配置变更，那么被移除的节点就会已经被关闭了，不能直接回复，这不是我们希望看到的结果。&lt;/p&gt;&lt;p id="32e7"&gt; 2. 节点提交删除自身日志后立即关闭节点。因为已经提交了，所以这个方法不存在上面的问题，但是如果你相应的实现的话，你会发现被移除的节点有时还是无法自动关闭。因为被删除的节点可能根本不会提交新的配置。假设我们要删除一个Follower节点，而Leader将这条删除记录添加到自己的日志中，然后立即开始使用新的日志，此时Leader不会向Follower发送任何请求，Follower也会自然无法commit记录。当然，follower 无法提交此日志并自行关闭。对于Leader来说不存在这个问题，Leader会暂时管理集群，没有自己，直到日志提交为止。&lt;/p&gt;&lt;p id="51b3"&gt;如果最直接的方法都不起作用，那么被删除的节点该如何自行关闭呢？假设我们这里不添加关闭逻辑，发生的情况是Leader将conf变更日志同步到集群，新集群的所有成员都会正常处理并提交这个日志。被删除的节点将在不知情的情况下离开集群，并且不会收到来自 Leader 的心跳。然后该节点超时并开始选举，这就是我们最终决定进行更改的地方。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;pub(super) fn handle_pre_vote( &amp;amp;self, term: u64, candidate_id: ServerId, last_log_index: LogIndex, last_log_term: u64, ) -&amp;gt; Result&amp;lt;(u64, Vec&amp;lt;PoolEntry&amp;lt;C&amp;gt;&amp;gt;), Option&amp;lt;u64&amp;gt;&amp;gt; { // ... let contains_candidate = self.cluster().contains(candidate_id); let remove_candidate_is_not_committed = log_r .fallback_contexts .iter() .any(|(_, ctx)| match ctx.origin_entry.entry_data { EntryData::ConfChange(ref cc) =&amp;gt; cc.iter().any(|c| { matches!(c.change_type(), ConfChangeType::Remove) &amp;amp;&amp;amp; c.node_id == candidate_id }), _ =&amp;gt; false, }); // extra check to shutdown removed node if !contains_candidate &amp;amp;&amp;amp; !remove_candidate_is_not_committed { return Err(None); } // ... }&lt;/code&gt;&lt;/pre&gt;&lt;p id="9fcb"&gt;我们在 ProVote 阶段添加了额外的检查逻辑，收到预投票的节点将检查候选人是否已被删除。假设候选者不在当前节点的配置中，并且可能的回退操作将不允许该节点重新加入集群，则意味着这是已被删除的候选者。处理请求的节点将向 Follower 发送一个带有&lt;code&gt;shutdown_candidate&lt;/code&gt;字段的特殊&lt;code&gt;VoteResponse&lt;/code&gt; 。 Candidate 收到响应并确定&lt;code&gt;shutdown_candidate&lt;/code&gt;是否为&lt;code&gt;true&lt;/code&gt; ，如果是，则开始自我关闭，如果不是，则继续选举过程。&lt;/p&gt;&lt;h2 class="wp-block-heading" id="4d61"&gt;概括&lt;/h2&gt;&lt;p id="c8ea"&gt;在这篇文章中，我们深入探讨了分布式系统中集群成员资格变更是如何执行的，简要介绍了两种主要解决方案：联合共识和单步成员资格变更。联合共识引入了中间状态，以确保变革期间不会有两个领导者。单步集群变更牺牲了部分功能，通过逐一变更节点来简化实现逻辑。另外，我们还分析了Xline目前单步成员变更方案的源码，展示了Leader和Follower都是如何处理变更的，以及引入集群变更后需要处理哪些新的逻辑。&lt;/p&gt;&lt;p id="67ff"&gt;目前，Xline仅使用单步集群变更来处理集群成员变更，提供了基本的变更能力。未来我们将尝试支持联合共识来增强Xline的功能。&lt;/p&gt;&lt;p id="f253"&gt; Xline 的会员变更就到此为止。如果您对更多实现细节感兴趣，请参阅我们的开源存储库&lt;a href="https://github.com/xline-kv/Xline"&gt;https://github.com/xline-kv/Xline&lt;/a&gt;或在 Xline 网站上了解更多信息： &lt;a href="https://xline./"&gt;https://xline。&lt;/a&gt;云。 &lt;/p&gt;&lt;p&gt;&lt;a href="https://medium.com/@datenlord?source=post_page-----5a5e405b120a--------------------------------"&gt;&lt;/a&gt;&lt;/p&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;</description><pubDate>Wed, 03 Apr 2024 16:00:00 GMT</pubDate><guid isPermaLink="true">https://www.cncf.io/blog/2024/04/04/membership-change-source-code-interpretation/</guid></item><item><title>2024 年 K8s 基准报告：工作负载可靠性的最新趋势</title><link>https://www.cncf.io/blog/2024/04/03/a-2024-k8s-benchmark-report-the-latest-trends-in-workload-reliability/</link><description>&lt;p&gt;&lt;em&gt;会员帖子最初由 Joe Pelletier 在&lt;a href="https://www.fairwinds.com/blog/2024-k8s-benchmark-report-workload-reliability"&gt;Fairwinds 博客&lt;/a&gt;上发布&lt;/em&gt;&lt;/p&gt;&lt;p&gt;据Gartner预测， &lt;a href="https://www.gartner.com/en/newsroom/press-releases/2023-11-29-gartner-says-cloud-will-become-a-business-necessity-by-2028"&gt;到2028年，云计算将成为保持企业竞争力&lt;/a&gt;的重要组成部分。事实上，到 2024 年，公共云服务支出预计将达到 6790 亿美元。虽然云支出很复杂，成本来自多个来源，但不可否认的是，许多组织正在将应用程序和服务转移到云中，并使用 Kubernetes 来有效管理容器并确保工作负载可靠性。&lt;/p&gt;&lt;p&gt; Fairwinds 使用来自超过 330,000 个工作负载和数百个组织的数据，创建了&lt;a href="https://www.fairwinds.com/kubernetes-config-benchmark-report"&gt;2024 年 Kubernetes 基准报告&lt;/a&gt;，该报告分析了 2024 年的趋势，并将结果与​​ 2022 年和 2023 年的基准进行比较。尽管组织已经在生产中部署 Kubernetes 工作负载，但许多组织仍然面临着与 Kubernetes 最佳实践保持一致的挑战。不幸的是，缺乏一致性可能会导致严重后果：安全风险增加、云成本失控以及应用程序和服务的&lt;a href="https://www.fairwinds.com/blog/kubernetes-best-practices-reliability"&gt;可靠性&lt;/a&gt;降低。基准分析回顾了所有这些主题，而本文重点关注与工作负载可靠性相关的六个领域，以帮助您确定做得好的领域或需要进行一些改进的领域。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;缺少活性和就绪探针&lt;/h2&gt;&lt;p&gt;&lt;a href="https://www.fairwinds.com/blog/a-guide-to-understanding-kubernetes-liveness-probes-best-practices"&gt;活性探针&lt;/a&gt;指示容器是否正在运行，这是 Kubernetes 工作负载是否按设计运行的基本指标。如果活性探测器进入失败状态，Kubernetes 会发送一个信号以自动重新启动容器。重启容器的目的是将服务恢复到可运行状态。但是，如果您无法确保 Pod 中的每个容器都有活性探测器，则无法正常运行的容器可能会无限期地运行，占用资源，并且在某些情况下会导致应用程序错误。&lt;/p&gt;&lt;p&gt;同样， &lt;a href="https://www.fairwinds.com/blog/increase-kubernetes-reliability-a-best-practices-guide-for-readiness-probes"&gt;就绪探测&lt;/a&gt;指示容器是否准备好接收流量，这也会影响应用程序的整体可靠性。容器不可避免地会发生故障并需要重新启动，而 Kubernetes 活跃度和就绪性探测在确保发生这种情况时容器可用并准备好为流量提供服务方面发挥着重要作用。根据基准，最新数据显示，69% 的组织有 11-50% 的工作负载缺少活跃度探测器。同样，我们发现 66% 的组织（其工作负载为 11-50%）缺少就绪性探测。您是否确保您的工作负载具有适当的活动性和就绪性探测器？ &lt;/p&gt;&lt;figure class="wp-block-image"&gt;&lt;img alt="缺少活性探针图" src="https://lh7-us.googleusercontent.com/alo8sxqnt0MQIReGkszdQzenndAPGWSxX_4QfnWl4tgDoGhSQyNTvBP3H7aoNfQf300YVSUE5IfMQnstsTIZJnWxZjkHLiYFFq_hIBFAKFTe7CI4uDPBhIDZKkfSgEXd2jaLQirBoE3XyZPS7Qob7Fo" /&gt;&lt;/figure&gt;&lt;h2 class="wp-block-heading"&gt;拉动政策并不总是&lt;/h2&gt;&lt;p&gt;在 Kubernetes 中，拉取策略是一种设置，用于确定 Kubernetes 如何以及何时为 Pod 拉取容器映像。它告诉 Kubernetes 工作节点 (kubelet) 在运行 pod 时如何处理图像下载。不幸的是，依赖缓存的 Docker 镜像可能会导致可靠性和安全性问题。默认情况下，如果镜像尚未缓存在尝试运行该镜像的节点上，Kubernetes &lt;a href="https://www.fairwinds.com/blog/kubernetes-basics-tutorial-how-to-set-image-pull-policy-to-always"&gt;会拉取该镜像&lt;/a&gt;。但是，如果您使用缓存版本，则可能会导致每个节点运行图像的多个版本。它还可能引入潜在的安全漏洞，主要是因为 Kubernetes 将使用图像的缓存版本而不验证其来源。 2024 年基准显示受影响的工作负载数量有所增加：24% 的组织超过 90% 的工作负载依赖缓存图像，这可能会严重影响应用程序的可靠性。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;部署缺少副本&lt;/h2&gt;&lt;p&gt;基准报告从 2023 年开始在分析中包含缺失的副本，因为我们发现许多工作负载未配置副本。到 2024 年，55% 的组织有超过 21% 的工作负载缺少副本。副本有助于维护容器的稳定性和可用性，因为 ReplicaSet 将替换失败的 Pod。您的工作负载中有多少百分比缺少副本？&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;缺少 CPU 限制&lt;/h2&gt;&lt;p&gt;最新的基准数据显示，越来越多的组织正在设置&lt;a href="https://training.fairwinds.com/action-item-setting-kubernetes-cpu-limits"&gt;CPU 限制&lt;/a&gt;。分析显示，22% 的组织有不到 10% 的工作负载未达到 CPU 限制。当您不指定 CPU 限制时，容器没有任何上限，这是一个问题，因为 CPU 密集型容器可能会使用节点上的所有可用 CPU，从而导致其他容器缺乏所需的资源。设置 CPU 限制有助于提高应用程序的&lt;a href="https://www.fairwinds.com/blog/kubernetes-benchmark-report-managing-k8s-workload-costs-2024"&gt;成本效率&lt;/a&gt;和可靠性，因此值得检查它们是否到位并适当设置。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt; CPU 请求丢失&lt;/h2&gt;&lt;p&gt;从新数据来看，组织似乎正在意识到确保设置&lt;a href="https://training.fairwinds.com/action-items-setting-kubernetes-cpu-requests"&gt;CPU 请求&lt;/a&gt;的价值。 2022 年，只有 50% 的组织缺少至少 10% 工作负载的请求，而到 2023 年，78% 的组织缺少至少 10% 工作负载的请求。今年，拥有 10% 工作负载的组织中，这一比例下降至 67%。 % 或更多工作负载受到缺少 CPU 请求的影响。&lt;/p&gt;&lt;p&gt;与 CPU 限制类似，如果您没有设置 CPU 请求，则单个 Pod 可能会消耗所有节点 CPU 和内存，从而导致其他 Pod 资源匮乏。当您设置资源请求时，它可以保证 pod 能够访问所需的资源。这有助于确保您的应用程序和服务具有更高的可靠性。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;工作负载可靠性仍然具有挑战性&lt;/h2&gt;&lt;p&gt;Kubernetes 在 2024 年及以后为组织带来非凡的价值，这意味着如果您想满足您的环境和业务需求，了解 Kubernetes 中可用的许多配置以及如何适当调整它们至关重要。 Kubernetes 基准报告可以帮助您了解同行在配置工作负载方面的成功和失败之处，以及他们是否始终遵循最佳实践。使用此信息可帮助您配置部署，使其尽可能安全、可靠且经济高效。&lt;/p&gt;&lt;p&gt;立即阅读&lt;a href="https://www.fairwinds.com/kubernetes-config-benchmark-report"&gt;Kubernetes 基准报告&lt;/a&gt;。 &lt;/p&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;</description><pubDate>Tue, 02 Apr 2024 16:00:00 GMT</pubDate><guid isPermaLink="true">https://www.cncf.io/blog/2024/04/03/a-2024-k8s-benchmark-report-the-latest-trends-in-workload-reliability/</guid></item><item><title>Gödel Scheduler 开源：在线和离线工作负载的统一调度程序</title><link>https://www.cncf.io/blog/2024/04/02/godel-scheduler-open-sourced-a-unified-scheduler-for-online-and-offline-workloads/</link><description>&lt;p&gt;&lt;em&gt;字节跳动的会员帖子&lt;/em&gt;&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;自 2014 年开源以来，Kubernetes 已迅速成为容器编排事实上的标准。字节跳动的基础设施团队很早就采用了 Kubernetes 来构建我们的私有云平台。多年来，字节跳动在微服务、推荐/广告/搜索服务、机器学习与大数据、存储等各业务线的快速增长，导致对计算资源的需求大幅增长。 &lt;/p&gt;&lt;figure class="wp-block-image"&gt;&lt;img alt="图像" src="https://lh7-us.googleusercontent.com/aiyjHAn71MVHGmgoDMYMdkguB-XqRGdLk_hmyAjuBXsqBzZcbTkKYY4oWUbNe-INqe_bV08otBKPJPTKXAg30qYxS6PFP9Wywucy15bC8xmowgex102r9rZXYYjMteIKhYlMwS3vktDCcY72pFjOow" /&gt;&lt;/figure&gt;&lt;p&gt;最初，字节跳动使用单独的资源池来管理其在线和离线工作负载，每个资源池专用于不同的业务部门。为了适应重大节假日和重大活动期间在线业务需求的激增，基础设施团队通常需要提前规划，将线下资源重新分配到线上池，以增强处理在线活动增加的能力。虽然这一临时解决方案满足了即时需求，但池间资源借用过程被证明非常耗时、操作繁重且效率低下。此外，为在线和离线工作负载维护单独的资源池会导致大量的主机托管成本，几乎没有提高资源利用率的空间。因此，基础设施团队寻求实现一个统一的系统来调度和管理在线和离线工作负载。该举措旨在促进资源池化，提高资源利用率和弹性，优化成本和用户体验，减轻运营负担。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;strong&gt;统一调度实践&lt;/strong&gt;&lt;/h2&gt;&lt;h3 class="wp-block-heading"&gt;&lt;strong&gt;Kubernetes 默认调度程序之外的增强功能：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;自2018年广泛使用Kubernetes以来，字节跳动不断优化Kubernetes的各个组件的功能和性能。但随着2019年推荐/广告/搜索服务的容器化，原生的Kubernetes调度器无论是功能还是性能都距离满足字节跳动的业务需求越来越远。在功能上，需要更细粒度的资源调度能力和灵活的抢占策略。在性能方面，原生 Kubernetes 默认调度器在 5000 个节点的集群中只能实现每秒 10 个 Pod 左右的调度吞吐量，往往会导致业务升级遇到瓶颈，远远不能满足要求。因此，团队对 Kubernetes 默认调度器引入了多项关键优化，包括：&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;&lt;strong&gt;功能&lt;/strong&gt;：&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;扩展了调度功能以支持非本地资源，例如内存带宽和网络带宽。&lt;/li&gt;&lt;li&gt;支持微拓扑调度。&lt;/li&gt;&lt;li&gt;通过提供可插拔的抢占框架来支持扩展抢占功能，重构了抢占实现。&lt;/li&gt;&lt;/ul&gt;&lt;h3 class="wp-block-heading"&gt;&lt;strong&gt;表现&lt;/strong&gt;：&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;通过重构数据结构，进一步强化快照间增量更新的理念，优化Scheduler缓存与Snapshot之间的数据同步机制。&lt;/li&gt;&lt;li&gt;对同构调度单元的调度结果进行缓存，减少冗余计算，提高效率。&lt;/li&gt;&lt;li&gt;通过重新组织抢占相关的数据结构，及时进行剪枝，减少不必要的计算，优化抢占实现。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;通过上述优化，我们成功增强了容器化能力，满足了字节跳动快速扩张的需求。这使得调度吞吐量显着增加了 30 倍。也就是说，在包含 10,000 个节点的集群中，我们始终实现每秒 300 个 Pod 的调度速率。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;strong&gt;哥德尔调度器&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;2020年，字节跳动启动了线上线下业务运营的统一调度和资源管理项目。目标是提高整体资源利用率、提高运营效率并减少维护费用。最初，该计划涉及通过单一调度系统管理在线和离线任务。然而，这种方法提出了挑战，主要是由于离线调度的复杂性，它与在线流程明显不同，尤其是对高吞吐量的需求。&lt;/p&gt;&lt;p&gt;原生的 Kubernetes 调度器主要是为 Pod 级别的调度而设计的，它对更复杂的“Job”调度语义的支持有些有限，并且在处理这些更高级别的需求时遇到了性能限制。为了有效满足这些独特的需求，并更好地满足字节跳动多样化的运营需求，决定开发一个定制的内部分布式调度器。这导致了 Gödel Scheduler 的创建，专门用于与 Kubernetes 系统集成，并处理字节跳动广阔且不断发展的业务环境中苛刻且多样化的调度需求。&lt;/p&gt;&lt;p&gt; Gödel Scheduler 是一个分布式系统，旨在整合在线和离线工作负载的调度。该调度程序是 Kubernetes (K8s) 调度程序的增强版，旨在增强可扩展性并提高调度质量。善于满足字节跳动线上线下运营多样化的功能和性能需求。哥德尔调度程序的主要功能包括：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;乐观并发&lt;/strong&gt;：它结合了乐观并发概念，将最耗时的单元到节点匹配（过滤和评分）移至调度程序组件。这允许并发执行并提高大规模集群中的调度吞吐量。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;两层调度抽象&lt;/strong&gt;（Unit和Pod）&lt;strong&gt;和框架&lt;/strong&gt;：提供更灵活的批量调度能力，更好地支持离线操作，同时提高调度吞吐量和系统可扩展性。扩展框架更有效地处理特殊场景。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;功能丰富、性能卓越&lt;/strong&gt;：满足线上、线下（批量、流式）、训练任务等多种作业需求，实现真正的统一调度。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;与 Kubernetes 生态系统的兼容性&lt;/strong&gt;：可以作为 K8s Scheduler 的替代方案，但由于性能和架构优化，其框架接口与 K8s Scheduler 并不完全相同。但它的扩展性不受影响，可以实现类似 Kubernetes 的调度插件。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;下图是Gödel Scheduler的架构图。 &lt;/p&gt;&lt;figure class="wp-block-image"&gt;&lt;img alt="图像" src="https://lh7-us.googleusercontent.com/UWj3cxod92AL8B8NbCxJHEyxANnpd4jtUcovpzjaHK-HME0PuNw7NWiXxj4_yBOuPb5RsrpjSwBF6t61Xiy05W4wza2wt4bZEK6d3qAz9PtVvfSbWs0gwC4m-aglyyQDyTsfC7dFiOLPVcXmpYAX_A" /&gt;&lt;/figure&gt;&lt;p&gt;如上所述，Gödel Scheduler 由三个主要组件组成：Dispatcher、Scheduler 和 Binder。其架构的关键是 Scheduler 组件，该组件通常部署在多个分片中以促进乐观并发调度。这种多分片部署提高了其效率和可扩展性。另一方面，Dispatcher 和 Binder 均部署为单个实例，这种配置适合它们在 Gödel Scheduler 系统中的特定角色和职责。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;&lt;strong&gt;调度员&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;调度程序在管理应用程序排队、分发和节点分区方面发挥着关键作用。它由几个关键组件组成：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;排序策略管理器&lt;/strong&gt;：该模块处理应用程序的排队。目前，它实现了 FIFO 和 DRF/FairShare 排队策略，后者仍有待生产使用。未来的增强功能将引入更复杂的排队策略，包括基于优先级值的策略。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;调度策略管理器&lt;/strong&gt;：其主要功能是跨各种调度程序实例分配应用程序。目前默认采用LoadBalance策略。未来的更新旨在使此功能更加通用且基于插件。&lt;/li&gt;&lt;li&gt; &lt;strong&gt;Node Shuffler&lt;/strong&gt; ：该组件的任务是根据 Scheduler 实例的数量组织集群节点。它将每个节点分配给特定的节点分区，每个调度程序实例监督一个分区。在调度过程中，调度程序首先考虑其分区内的节点，然后再探索其他分区中的节点。这种安排是动态调整的，以响应节点可用性或调度程序计数的变化。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;分区规则&lt;/strong&gt;：目前，系统力求节点在 Scheduler 实例之间均匀分布。目前正在计划扩展这些分区策略，增强其可配置性。&lt;/li&gt;&lt;li&gt; &lt;strong&gt;Scheduler Maintenanceer&lt;/strong&gt; ：该元素负责监控 Scheduler 实例的状态。它跟踪健康状态、工作负载和每个分区内的节点计数等方面。&lt;/li&gt;&lt;li&gt; &lt;strong&gt;Reconciler&lt;/strong&gt; ：定期运行，Reconciler 监督 Pod、节点、调度程序和 SchedulingUnit 等各种元素的状态。它可以解决任何错误、差异或缺陷，确保系统完整性和性能。&lt;/li&gt;&lt;/ol&gt;&lt;h3 class="wp-block-heading"&gt;&lt;strong&gt;调度程序&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;Scheduler 在调度和抢占应用程序的决策过程中发挥着关键作用，尽管它本身并不执行这些决策（该任务由 Binder 处理）。它在两层框架上运行：Unit Scheduling Framework 和 Pod Scheduling Framework。整个调度过程分为三个主要阶段：节点组织、单元调度和单元抢占。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;节点组织&lt;/strong&gt;：此阶段涉及对节点进行过滤和排序，以简化调度过程并提高其质量。它由两种类型的插件组成：&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;定位插件：这些过滤器节点基于特定的应用程序信息。&lt;/li&gt;&lt;li&gt;分组插件：这些插件根据可用资源或作业级别关联性对节点进行分组。&lt;/li&gt;&lt;/ul&gt;&lt;ol start="2"&gt;&lt;li&gt;&lt;strong&gt;单元调度&lt;/strong&gt;：在此阶段，节点将根据已通过节点组织插件过滤的应用程序请求进行匹配和评分。此过程类似于 Kubernetes (K8s) 调度程序框架，包括：&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;过滤插件：这些过滤器节点基于应用程序请求的要求。&lt;/li&gt;&lt;li&gt;评分插件：这些插件将分数分配给上一步中已过滤的节点。&lt;/li&gt;&lt;/ul&gt;&lt;ol start="3"&gt;&lt;li&gt; &lt;strong&gt;Unit Preempting&lt;/strong&gt; ：如果在Unit Scheduling阶段没有找到合适的节点，Scheduler就会进入抢占阶段。在这里，它尝试通过抢占正在运行的应用程序实例来释放资源，为新的应用程序实例腾出空间。这一阶段包括：&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;受害者搜索：识别可被抢占的潜在受害者应用程序。&lt;/li&gt;&lt;li&gt;候选者排序：对节点和潜在受害者进行排序，以确定最合适的抢占选择。&lt;/li&gt;&lt;/ul&gt;&lt;h3 class="wp-block-heading"&gt;&lt;strong&gt;活页夹&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;Binder 在调度过程的最后阶段起着至关重要的作用，重点是冲突检测、抢占操作以及执行应用程序与资源的绑定。它由三个主要组件组成：ConflictResolver、PreemptionOperator 和 UnitBinder。&lt;/p&gt;&lt;ol&gt;&lt;li&gt; &lt;strong&gt;ConflictResolver&lt;/strong&gt; ：该组件的任务是检测调度过程中的并发冲突。它以两种模式运行：&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;跨节点冲突解决程序：检查不同节点之间可能发生的冲突。&lt;/li&gt;&lt;li&gt;单节点冲突解决程序：识别单个节点内的冲突。&lt;br /&gt;如果检测到任何冲突，申请将立即被拒绝并重新安排。&lt;/li&gt;&lt;/ul&gt;&lt;ol start="2"&gt;&lt;li&gt; &lt;strong&gt;PreemptionOperator&lt;/strong&gt; ：在不存在冲突但需要抢占的场景下，由该算子负责。它通过删除受害者（需要终止以释放资源的应用程序或进程）来执行抢占，然后等待最终的调度。&lt;/li&gt;&lt;li&gt; &lt;strong&gt;UnitBinder&lt;/strong&gt; ：这部分Binder负责绑定之前所需的准备工作，比如动态创建存储卷，然后进行实际的绑定操作，将应用程序链接到指定的资源。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;值得注意的是，当前版本的 Binder 集成了 PodGroup 控制器。该控制器负责管理 PodGroup 的状态和生命周期。然而，值得注意的是，在未来的版本中，我们计划从 Binder 中删除此功能，将其转变为独立的控制器。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;strong&gt;经验&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;在过去的两年里，Gödel Scheduler 一直是字节跳动的基石，提供了丰富的调度功能和语义。高效可靠地支撑了字节跳动多样化、复杂业务负载的运行。&lt;/p&gt;&lt;p&gt;在架构增强的基础上，字节跳动借鉴 Kubernetes 原生调度器的经验，实现了深刻的性能优化。与字节跳动内部完善的 Kubernetes 系统集成后，Gödel Scheduler 现在拥有令人印象深刻的吞吐量：单个分片中 2000+ pod/s，跨多个分片 5000+ pod/s。字节跳动不断努力扩大单集群容量，其最大的产品集群已达到超过 20,000 个节点和超过 1,000,000 个 Pod。&lt;/p&gt;&lt;p&gt;经过字节跳动内部多年的深入实践和增强，Gödel Scheduler已经达到了相对稳定的状态。 2023年，顶级云计算会议SoCC接受了我们关于Gödel Scheduler的论文，凸显了字节跳动大规模资源管理和调度的统一方法。研发团队也受邀在会议上展示工作。对于感兴趣的人，可以在 https://dl.acm.org/doi/10.1145/3620678.3624663 上获取 Gödel Scheduler 论文。&lt;/p&gt;&lt;p&gt;出于对开源社区的贡献，字节跳动团队决定开源Gödel Scheduler，提供全新的调度解决方案，通过卓越的性能和全面的调度能力，增强线上线下服务的云原生体验。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;strong&gt;未来的工作&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;展望未来，字节跳动致力于Gödel Scheduler的持续开发，重点丰富其功能并增强其可扩展性。一个重要的关注领域是优化特定挑战性场景中的调度吞吐量，例如涉及高部署率和频繁抢占的场景。通过创新的重新调度策略，字节跳动旨在解决维持调度性能和提高调度质量之间的复杂平衡。首要目标不仅是保持当前的调度吞吐量，而且还大幅提高调度质量。&lt;/p&gt;&lt;p&gt;此外，字节跳动高度重视生态系统的发展。我们将努力确保 Gödel Scheduler 与各种业务应用程序中使用的领先系统和框架的兼容性。该计划将包括与著名的大数据和机器学习框架的集成，并附有实际使用示例和全面的文档。&lt;/p&gt;&lt;p&gt;为了保持社区的参与和知情，将有条不紊地制定 Gödel Scheduler 的详细路线图，并在 Gödel Scheduler Repository 上提供。这将为感兴趣的各方提供跟踪进度、做出贡献并成为项目积极参与者的机会。&lt;/p&gt;&lt;p&gt;虽然哥德尔调度器在字节跳动内部经历了多次迭代，在各种场景下经过了严格的测试，并证明了其有效性，但字节跳动承认，在通用性和标准化方面仍然有很大的进步潜力。字节跳动热忱邀请并鼓励社区成员参与哥德尔调度器的开发，相信共同努力将带来更大的改进和创新。&lt;/p&gt;&lt;p&gt;哥德尔调度程序项目存储库： &lt;a href="https://github.com/kubewharf/godel-scheduler"&gt;https://github.com/kubewharf/godel-scheduler&lt;/a&gt; &lt;/p&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;</description><pubDate>Mon, 01 Apr 2024 16:00:00 GMT</pubDate><guid isPermaLink="true">https://www.cncf.io/blog/2024/04/02/godel-scheduler-open-sourced-a-unified-scheduler-for-online-and-offline-workloads/</guid></item><item><title>提升系统弹性：利用 LitmusChaos 和 Backstage 集成</title><link>https://www.cncf.io/blog/2024/04/01/elevating-system-resilience-leveraging-litmuschaos-and-backstage-integration/</link><description>&lt;p&gt;&lt;em&gt;项目发布者：Namkyu Park&lt;/em&gt; ， &lt;em&gt;LitmusChaos 维护者 ( &lt;a href="https://www.linkedin.com/in/namkyupark1999/?locale=en_US"&gt;LinkedIn&lt;/a&gt; | &lt;a href="https://github.com/namkyu1999"&gt;GitHub&lt;/a&gt; )&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;这篇博文提供了使用 LitmusChaos 注入混沌并使用 Backstage 进行管理的分步说明。&lt;/em&gt; &lt;/p&gt;&lt;hr class="wp-block-separator has-alpha-channel-opacity" /&gt;&lt;h2 class="wp-block-heading"&gt;&lt;a href="https://dev.to/namkyu1999/a-beginners-guide-to-litmus-and-backstage-4p18-temp-slug-9264283?preview=1ab316fd623b5144a4102e4057db0744e32cd289a39a2ffc04e5bdaca4caf5f173faa3b2c345da6204b570a6cf4896c8000346f60706789e13f405d5#table-of-contents"&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;混沌工程、LitmusChaos 和 Backstage&lt;/li&gt;&lt;li&gt;先决条件&lt;/li&gt;&lt;li&gt;我们的演示由什么组成？&lt;/li&gt;&lt;li&gt;演示环境&lt;/li&gt;&lt;li&gt;使用 LitmusChaos 注入混沌&lt;/li&gt;&lt;li&gt;在后台管理 LitmusChaos 内容&lt;/li&gt;&lt;li&gt;概括&lt;/li&gt;&lt;/ul&gt;&lt;hr class="wp-block-separator has-alpha-channel-opacity" /&gt;&lt;h2 class="wp-block-heading"&gt;&lt;a href="https://dev.to/namkyu1999/a-beginners-guide-to-litmus-and-backstage-4p18-temp-slug-9264283?preview=1ab316fd623b5144a4102e4057db0744e32cd289a39a2ffc04e5bdaca4caf5f173faa3b2c345da6204b570a6cf4896c8000346f60706789e13f405d5#chaos-engineering-litmuschaos-and-backstage"&gt;&lt;/a&gt;混沌工程、LitmusChaos 和 Backstage&lt;/h2&gt;&lt;p&gt;随着包括 Kubernetes 在内的云原生技术变得越来越复杂，应用程序由更多组件组成。您的系统有弹性吗？例如，如果您的一个容器由于 OOM 而宕机，它是否会自动重新创建并做好准备？&lt;a href="https://principlesofchaos.org/"&gt;混沌工程&lt;/a&gt;是一门对系统进行实验的学科，目的是建立对系统承受生产中湍流条件的能力的信心。 &lt;a href="https://docs.litmuschaos.io/docs/introduction/what-is-litmus"&gt;LitmusChaos&lt;/a&gt; （CNCF孵化项目）是一个具有跨云支持的云原生混沌工程框架。您可以使用 LitmusChaos 将混乱注入不同的基础设施层。&lt;/p&gt;&lt;figure class="wp-block-image"&gt; &lt;a href="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F52ajvswmhak5nuu0oced.png"&gt;&lt;img alt="下层" src="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F52ajvswmhak5nuu0oced.png" /&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt; &lt;a href="https://backstage.io/"&gt;Backstage&lt;/a&gt;是一个用于构建开发者门户的开放平台，是最受欢迎的 CNCF 项目之一。它允许开发人员从一个点管理云原生应用程序的众多服务和代码。&lt;/p&gt;&lt;p&gt; LitmusChaos 可以通过&lt;a href="https://github.com/litmuschaos/backstage-plugin"&gt;backstage-plugin&lt;/a&gt;与 Backstage 集成。在本教程中，我们将通过 minikube 构建本地 Kubernetes 集群并安装演示应用程序和 LitmusChaos。之后，我们将使用 LitmusChaos 进行混沌实验，并使用 Backstage 轻松查看 LitmusChaos 中的内容。 &lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;a href="https://dev.to/namkyu1999/a-beginners-guide-to-litmus-and-backstage-4p18-temp-slug-9264283?preview=1ab316fd623b5144a4102e4057db0744e32cd289a39a2ffc04e5bdaca4caf5f173faa3b2c345da6204b570a6cf4896c8000346f60706789e13f405d5#prerequisites"&gt;&lt;/a&gt;先决条件&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://docs.docker.com/engine/install/"&gt;Docker&lt;/a&gt; 、 &lt;a href="https://minikube.sigs.k8s.io/docs/start/"&gt;minikube&lt;/a&gt; （如果你使用 k8s 集群，请跳过此部分）&lt;/li&gt;&lt;li&gt; &lt;a href="https://docs.litmuschaos.io/docs/getting-started/installation/#prerequisites"&gt;LitmusChaos 先决条件&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://backstage.io/docs/getting-started/#prerequisites"&gt;后台先决条件&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 class="wp-block-heading"&gt;&lt;a href="https://dev.to/namkyu1999/a-beginners-guide-to-litmus-and-backstage-4p18-temp-slug-9264283?preview=1ab316fd623b5144a4102e4057db0744e32cd289a39a2ffc04e5bdaca4caf5f173faa3b2c345da6204b570a6cf4896c8000346f60706789e13f405d5#what-does-our-deployment-consist-of"&gt;&lt;/a&gt;我们的部署包括什么？&lt;/h2&gt;&lt;p&gt;幸运的是，我们不必制作基于 k8s 的服务。 &lt;a href="https://github.com/GoogleCloudPlatform/microservices-demo"&gt;microservice-demo&lt;/a&gt;是我们可以使用的一个很棒的微服务。下图显示了我们将要构建的演示的架构。&lt;/p&gt;&lt;figure class="wp-block-image"&gt; &lt;a href="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F3bjyi3qw7btsfwrnf0wz.png"&gt;&lt;img alt="演示环境" src="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F3bjyi3qw7btsfwrnf0wz.png" /&gt;&lt;/a&gt; &lt;/figure&gt;&lt;h2 class="wp-block-heading"&gt;&lt;a href="https://dev.to/namkyu1999/a-beginners-guide-to-litmus-and-backstage-4p18-temp-slug-9264283?preview=1ab316fd623b5144a4102e4057db0744e32cd289a39a2ffc04e5bdaca4caf5f173faa3b2c345da6204b570a6cf4896c8000346f60706789e13f405d5#demo-environment"&gt;&lt;/a&gt;演示环境&lt;/h2&gt;&lt;p&gt;让我们安装本地 k8s 集群和演示应用程序，然后安装 LitmusChaos。 &lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;&lt;a href="https://dev.to/namkyu1999/a-beginners-guide-to-litmus-and-backstage-4p18-temp-slug-9264283?preview=1ab316fd623b5144a4102e4057db0744e32cd289a39a2ffc04e5bdaca4caf5f173faa3b2c345da6204b570a6cf4896c8000346f60706789e13f405d5#minikube-local-k8s-cluster"&gt;&lt;/a&gt; minikube（本地 k8s 集群）&lt;/h3&gt;&lt;p&gt;在本教程中，我们使用本地 k8s 集群 minikube。如果您尚未安装 minikube，请按照&lt;a href="https://minikube.sigs.k8s.io/docs/start/"&gt;本指南&lt;/a&gt;进行操作。一旦&lt;code&gt;minikube start&lt;/code&gt;执行，您就可以使用&lt;code&gt;kubectl&lt;/code&gt;命令访问本地 k8s 集群。&lt;/p&gt;&lt;figure class="wp-block-image"&gt; &lt;a href="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fxbfz9a2p9svsl0ggifjp.png"&gt;&lt;img alt="kubectl_get_node" src="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fxbfz9a2p9svsl0ggifjp.png" /&gt;&lt;/a&gt; &lt;/figure&gt;&lt;h3 class="wp-block-heading"&gt;&lt;a href="https://dev.to/namkyu1999/a-beginners-guide-to-litmus-and-backstage-4p18-temp-slug-9264283?preview=1ab316fd623b5144a4102e4057db0744e32cd289a39a2ffc04e5bdaca4caf5f173faa3b2c345da6204b570a6cf4896c8000346f60706789e13f405d5#online-boutique-microservicesdemo"&gt;&lt;/a&gt;在线精品店（微服务演示）&lt;/h3&gt;&lt;p&gt;安装 microservices-demo 更加简单。您所要做的就是执行以下代码。这是更&lt;a href="https://github.com/GoogleCloudPlatform/microservices-demo"&gt;详细的指南&lt;/a&gt;。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;// clone the repo git clone https://github.com/GoogleCloudPlatform/microservices-demo cd microservices-demo/ // move dir cd microservices-demo/ // install using a manifest file kubectl apply -f ./release/kubernetes-manifests.yaml&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们需要使用&lt;a href="https://minikube.sigs.k8s.io/docs/commands/service/"&gt;以下命令&lt;/a&gt;生成的 URL 来访问演示。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;minikube service frontend-external --url&lt;/code&gt;&lt;/pre&gt;&lt;figure class="wp-block-image"&gt; &lt;a href="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F79baavrjibu24mrevztq.png"&gt;&lt;img alt="minikube_service_ generated_1" src="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F79baavrjibu24mrevztq.png" /&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;现在我们可以通过&lt;code&gt;http://&amp;lt;&amp;lt;generated_url&amp;gt;&amp;gt;&lt;/code&gt; .GIF 访问该服务&lt;/p&gt;&lt;figure class="wp-block-image size-full"&gt;&lt;img alt="" src="https://i.giphy.com/media/v1.Y2lkPTc5MGI3NjExdzZ1cTh2YTEybGIzc3VtdmRzM2o3c3JyZTMzbW1ubWk2eTd6Y2k0YiZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/L8LfnvJPsdDToA5msX/giphy.gif" /&gt;&lt;/figure&gt;&lt;h3 class="wp-block-heading"&gt;&lt;a href="https://dev.to/namkyu1999/a-beginners-guide-to-litmus-and-backstage-4p18-temp-slug-9264283?preview=1ab316fd623b5144a4102e4057db0744e32cd289a39a2ffc04e5bdaca4caf5f173faa3b2c345da6204b570a6cf4896c8000346f60706789e13f405d5#litmuschaos"&gt;&lt;/a&gt;石蕊混沌&lt;/h3&gt;&lt;p&gt;让我们打开一个新 shell 并安装 LitmusChaos。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;// Add LitmusChaos Helm repo helm repo add litmuschaos https://litmuschaos.github.io/litmus-helm/ // Create the namespace kubectl create ns litmus // Install the chart helm install chaos litmuschaos/litmus --namespace=litmus --set portal.frontend.service.type=NodePort&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;和之前一样，我们需要创建一个 URL 来访问 litmuschaos（混沌中心）的前端。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;minikube service chaos-litmus-frontend-service -n litmus --url&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fc34o9u39m7578cs25qmw.png"&gt;&lt;/a&gt;&lt;br /&gt;以&lt;code&gt;admin / litmus&lt;/code&gt;身份登录&lt;/p&gt;&lt;figure class="wp-block-image"&gt;&lt;a href="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fghkkwhwz31qhqzxetpg1.png"&gt;&lt;img alt="litmus_login_page" src="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fghkkwhwz31qhqzxetpg1.png" /&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;第一次登录 LitmusChaos 时，您会看到一个弹出窗口，要求您启用这样的混沌基础设施&lt;/p&gt;&lt;figure class="wp-block-image"&gt;&lt;a href="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fapjyjjf9w24q4336izxy.png"&gt;&lt;img alt="石蕊弹出窗口" src="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fapjyjjf9w24q4336izxy.png" /&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;完成创建环境的所有步骤后，您将看到混沌基础设施已连接，如下所示。&lt;/p&gt;&lt;figure class="wp-block-image"&gt; &lt;a href="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fd2l0mup1w0h0sm48w3tu.png"&gt;&lt;img alt="混沌基础设施" src="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fd2l0mup1w0h0sm48w3tu.png" /&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;如果您对 LitmusChaos 的架构感到好奇，请查看&lt;a href="https://docs.litmuschaos.io/docs/architecture/architecture-summary"&gt;此文档&lt;/a&gt;。 &lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;a href="https://dev.to/namkyu1999/a-beginners-guide-to-litmus-and-backstage-4p18-temp-slug-9264283?preview=1ab316fd623b5144a4102e4057db0744e32cd289a39a2ffc04e5bdaca4caf5f173faa3b2c345da6204b570a6cf4896c8000346f60706789e13f405d5#injecting-chaos-using-litmuschaos"&gt;&lt;/a&gt;使用 LitmusChaos 注入混沌&lt;/h2&gt;&lt;p&gt;我们已经完成了执行混沌工程的所有准备工作。我们来讨论一个场景。假设您是一家在线精品服务的经理，您想要运行一个实验，看看当您删除其 pod 时， &lt;code&gt;cartservice&lt;/code&gt;组件是否会恢复。要检查 pod 是否存在，请使用以下命令。 &lt;code&gt;kubectl get pods -n default | grep cartservice | grep Running | wc -l&lt;/code&gt; 。&lt;/p&gt;&lt;figure class="wp-block-image"&gt; &lt;a href="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F467s6egncebaudn78bf2.png"&gt;&lt;img alt="命令执行" src="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F467s6egncebaudn78bf2.png" /&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt; LitmusChaos 支持各种类型的探针。&lt;a href="https://docs.litmuschaos.io/docs/concepts/probes"&gt;在这里&lt;/a&gt;了解有关探针的更多信息，这里有一个很棒的&lt;a href="https://youtu.be/_nvpNdvqfvk?feature=shared"&gt;教程视频&lt;/a&gt;。 &lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;&lt;a href="https://dev.to/namkyu1999/a-beginners-guide-to-litmus-and-backstage-4p18-temp-slug-9264283?preview=1ab316fd623b5144a4102e4057db0744e32cd289a39a2ffc04e5bdaca4caf5f173faa3b2c345da6204b570a6cf4896c8000346f60706789e13f405d5#setup-probe"&gt;&lt;/a&gt;设置探针&lt;/h3&gt;&lt;p&gt;您可以在&lt;code&gt;Resilience Probes&lt;/code&gt;选项卡中创建新探针。在本教程中，我们将创建一个&lt;code&gt;Command Probe&lt;/code&gt; 。输入如下所示的值。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;// Command kubectl get pods -n default | grep cartservice | grep Running | wc -l // Type Int // Comparison Criteria &amp;gt; // Value 0&lt;/code&gt; &lt;/pre&gt;&lt;figure class="wp-block-image size-full"&gt;&lt;img alt="" class="wp-image-104897" height="250" src="https://www.cncf.io/wp-content/uploads/2024/04/giphy.gif" width="480" /&gt;&lt;/figure&gt;&lt;p&gt;另一件事，因为&lt;code&gt;cartservice&lt;/code&gt;部署没有标签，我们添加了如下标签&lt;/p&gt;&lt;pre class="wp-block-code"&gt;&lt;code class=""&gt;kubectl label deployment cartservice app=cartservice&lt;/code&gt; &lt;/pre&gt;&lt;h3 class="wp-block-heading"&gt;&lt;a href="https://dev.to/namkyu1999/a-beginners-guide-to-litmus-and-backstage-4p18-temp-slug-9264283?preview=1ab316fd623b5144a4102e4057db0744e32cd289a39a2ffc04e5bdaca4caf5f173faa3b2c345da6204b570a6cf4896c8000346f60706789e13f405d5#lets-inject-chaos"&gt;&lt;/a&gt;让我们注入混乱&lt;/h3&gt;&lt;p&gt;我们所要做的就是创建一个混沌实验。正如我们之前讨论的，我们删除&lt;code&gt;cartservice&lt;/code&gt; pod 并检查该 pod 是否重新生成。下面是&lt;a href="https://docs.litmuschaos.io/docs/user-guides/schedule-experiment"&gt;详细教程&lt;/a&gt;和 gif。我只想指出一些重要的特征。 &lt;/p&gt;&lt;figure class="wp-block-image size-full"&gt;&lt;img alt="" src="https://i.giphy.com/media/v1.Y2lkPTc5MGI3NjExbTl0NXZraDhmMTR5YzMwaHB5bGtsM25tdWU2dWFyczlzdDFkM3hiMCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/34mlMp0MFwtowZAPoA/giphy.gif" /&gt;&lt;/figure&gt;&lt;p&gt;首先，我们在本次实验中选择了&lt;code&gt;pod-delete&lt;/code&gt;混沌故障。 &lt;/p&gt;&lt;figure class="wp-block-image size-full"&gt;&lt;img alt="图像" src="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F29y2k3dvffis209pewul.png" /&gt;&lt;/figure&gt;&lt;p&gt;其次，我们提供有关目标应用程序的信息，如下所示。 &lt;/p&gt;&lt;figure class="wp-block-image size-full"&gt;&lt;img alt="图像" class="wp-image-104899" height="364" src="https://www.cncf.io/wp-content/uploads/2024/04/image-1.png" width="1360" /&gt;&lt;/figure&gt;&lt;p&gt;最后，我们使用之前制作的探针。 &lt;/p&gt;&lt;figure class="wp-block-image size-full"&gt;&lt;img alt="图像" class="wp-image-104900" height="302" src="https://www.cncf.io/wp-content/uploads/2024/04/image-2.png" width="1364" /&gt;&lt;/figure&gt;&lt;p&gt;当您设置并运行混沌实验时，混沌会被注入到目标应用程序中，并且探测器会检查应用程序是否具有弹性。如果是，那么您现在已经掌握了混沌工程。恭喜你🎉&lt;/p&gt;&lt;figure class="wp-block-image"&gt; &lt;a href="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fsk3ne4rdxjeejtt68mni.png"&gt;&lt;img alt="成功" src="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fsk3ne4rdxjeejtt68mni.png" /&gt;&lt;/a&gt; &lt;/figure&gt;&lt;h2 class="wp-block-heading"&gt;&lt;a href="https://dev.to/namkyu1999/a-beginners-guide-to-litmus-and-backstage-4p18-temp-slug-9264283?preview=1ab316fd623b5144a4102e4057db0744e32cd289a39a2ffc04e5bdaca4caf5f173faa3b2c345da6204b570a6cf4896c8000346f60706789e13f405d5#manage-litmuschaos-stuff-in-backstage"&gt;&lt;/a&gt;在后台管理 LitmusChaos 内容&lt;/h2&gt;&lt;p&gt;您可以按照本&lt;a href="https://backstage.io/docs/getting-started/#create-your-backstage-app"&gt;入门指南&lt;/a&gt;开始构建 Backstage 应用程序并使用yarn dev 运行它。&lt;/p&gt;&lt;figure class="wp-block-image"&gt; &lt;a href="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fo481g3qmrhlxjycy8pr5.png"&gt;&lt;img alt="后台主程序" src="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fo481g3qmrhlxjycy8pr5.png" /&gt;&lt;/a&gt; &lt;/figure&gt;&lt;h3 class="wp-block-heading"&gt;&lt;a href="https://dev.to/namkyu1999/a-beginners-guide-to-litmus-and-backstage-4p18-temp-slug-9264283?preview=1ab316fd623b5144a4102e4057db0744e32cd289a39a2ffc04e5bdaca4caf5f173faa3b2c345da6204b570a6cf4896c8000346f60706789e13f405d5#litmuschaos-plugin-for-backstage"&gt;&lt;/a&gt;用于 Backstage 的 LitmusChaos 插件&lt;/h3&gt;&lt;p&gt;让我们向 Backstage 添加一个 LitmusChaos 插件&lt;/p&gt;&lt;figure class="wp-block-image size-full"&gt;&lt;img alt="" class="wp-image-104901" height="229" src="https://www.cncf.io/wp-content/uploads/2024/04/giphy-2.gif" width="480" /&gt;&lt;/figure&gt;&lt;ul&gt;&lt;li&gt;在&lt;code&gt;./packages/app&lt;/code&gt;项目中添加插件。&lt;/li&gt;&lt;/ul&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;yarn add backstage-plugin-litmus&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;通过 LitmusChaos UI 获取 LitmusChaos API 令牌&lt;ol&gt;&lt;li&gt;单击侧栏中的“设置”。&lt;/li&gt;&lt;li&gt;单击“API 令牌”部分中的“+ 新令牌”按钮。 &lt;img alt="创建令牌" height="408" src="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fl04ndjz91tjklz4lqieg.png" width="800" /&gt;&lt;/li&gt;&lt;li&gt;输入您的信息并点击“确认”。&lt;/li&gt;&lt;li&gt;获取“VALUE”列中的令牌。&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li&gt;在&lt;code&gt;app-config.yaml&lt;/code&gt;文件根目录中，添加 litmus 代理和信息，如下所示&lt;/li&gt;&lt;/ul&gt;&lt;pre class="wp-block-code"&gt;&lt;code class=""&gt; proxy: &amp;#39;/litmus&amp;#39;: target: &amp;#39;your-own-litmus-ui-url&amp;#39; changeOrigin: true headers: Authorization: &amp;#39;Bearer ${LITMUS_AUTH_TOKEN}&amp;#39; litmus: baseUrl: &amp;#39;your-own-litmus-ui-url&amp;#39; apiToken: ${LITMUS_AUTH_TOKEN}&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;将您的身份验证密钥添加到环境变量中&lt;/li&gt;&lt;/ul&gt;&lt;pre class="wp-block-code"&gt;&lt;code class=""&gt; export LITMUS_AUTH_TOKEN=&amp;quot;your-own-token&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;要获取项目 ID，请直接从门户 URL 中的“/project/”之后复制它&lt;img alt="项目ID" height="334" src="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fzdv8f1hkyyl4gt7fgrh4.png" width="800" /&gt;&lt;/li&gt;&lt;li&gt;将新组件附加到&lt;code&gt;./examples/entities.yaml&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;# ... --- apiVersion: backstage.io/v1alpha1 kind: Component metadata: name: backstage-litmus-demo description: An example of a Backstage application. ## append here annotations: litmuschaos.io/project-id: your-own-project-id ## spec: type: service owner: john@example.com lifecycle: experimental&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;要启用前端，我们需要编辑&lt;code&gt;./packages/app/src/components/catalog/EntityPage.tsx&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre class="wp-block-code"&gt;&lt;code class=""&gt; // packages/app/src/components/catalog/EntityPage.tsx import { isLitmusAvailable, EntityLitmusCard, EntityLitmusContent } from &amp;#39;backstage-plugin-litmus&amp;#39; // ... const overviewContent = ( &amp;lt;Grid container spacing={6} alignItems=&amp;quot;stretch&amp;quot;&amp;gt; // ... &amp;lt;EntitySwitch&amp;gt; &amp;lt;EntitySwitch.Case if={isLitmusAvailable}&amp;gt; &amp;lt;Grid item md={4} xs={12}&amp;gt; &amp;lt;EntityLitmusCard /&amp;gt; &amp;lt;/Grid&amp;gt; &amp;lt;/EntitySwitch.Case&amp;gt; &amp;lt;/EntitySwitch&amp;gt; // ... &amp;lt;/Grid&amp;gt; ) // ... const serviceEntityPage = ( &amp;lt;EntityLayout&amp;gt; // ... &amp;lt;EntityLayout.Route path=&amp;quot;/litmus&amp;quot; title=&amp;quot;Litmus&amp;quot;&amp;gt; &amp;lt;EntityLitmusContent /&amp;gt; &amp;lt;/EntityLayout.Route&amp;gt; // ... &amp;lt;/EntityLayout&amp;gt; )&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;再次&lt;code&gt;yarn dev&lt;/code&gt; ，现在您可以在一个地方（后台）管理有关LitmusChaos 的所有内容。&lt;a href="https://docs.litmuschaos.io/docs/integrations/backstage#entitylitmuscard"&gt;概述选项卡&lt;/a&gt;提供了 LitmusChaos 中一些重要指标的概览视图。&lt;/p&gt;&lt;figure class="wp-block-image"&gt; &lt;a href="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F6uywsu7of0wo5xjmlro7.png"&gt;&lt;img alt="概述" src="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F6uywsu7of0wo5xjmlro7.png" /&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;在&lt;a href="https://docs.litmuschaos.io/docs/integrations/backstage#entitylitmuscontent"&gt;LitmusChaos 选项卡&lt;/a&gt;中，您可以在一个页面上查看有关 LitmusChaos 的所有信息，包括混沌实验、混沌基础设施等。&lt;/p&gt;&lt;figure class="wp-block-image"&gt; &lt;a href="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fb43x6wx3cwhf1mbvpc3d.png"&gt;&lt;img alt="石蕊试片" src="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fb43x6wx3cwhf1mbvpc3d.png" /&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;我想强调的是，我们可以重新运行现有的混沌实验。我们所要做的就是点击“运行实验”按钮🚀&lt;/p&gt;&lt;figure class="wp-block-image"&gt; &lt;a href="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fqjwwemtiu98uyhsevg37.png"&gt;&lt;img alt="运行实验按钮" src="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fqjwwemtiu98uyhsevg37.png" /&gt;&lt;/a&gt; &lt;/figure&gt;&lt;h2 class="wp-block-heading"&gt;&lt;a href="https://dev.to/namkyu1999/a-beginners-guide-to-litmus-and-backstage-4p18-temp-slug-9264283?preview=1ab316fd623b5144a4102e4057db0744e32cd289a39a2ffc04e5bdaca4caf5f173faa3b2c345da6204b570a6cf4896c8000346f60706789e13f405d5#summary"&gt;&lt;/a&gt;概括&lt;/h2&gt;&lt;p&gt;在本教程中，我们探索了如何利用 LitmusChaos 和 Backstage 集成将混乱注入 Kubernetes 环境并对其进行有效管理。&lt;/p&gt;&lt;p&gt; LitmusChaos 和 Backstage 的集成提供了一个统一的平台来管理混沌工程的各个方面，从注入混沌到监控影响和分析结果。&lt;/p&gt;&lt;p&gt;如果您对 LitmusChaos 感兴趣，请加入社区！您可以加入&lt;a href="https://github.com/litmuschaos/litmus"&gt;GitHub&lt;/a&gt;和&lt;a href="https://kubernetes.slack.com/?redir=%2Farchives%2FCNXNB0ZTN"&gt;Slack&lt;/a&gt;上的 LitmusChaos 社区。&lt;/p&gt;&lt;p&gt;感谢您的阅读🙏&lt;/p&gt;&lt;p&gt;南久公园&lt;br /&gt;LitmusChaos 的维护者&lt;br /&gt;&lt;a href="https://www.linkedin.com/in/namkyupark1999/?locale=en_US"&gt;领英&lt;/a&gt;| &lt;a href="https://github.com/namkyu1999"&gt;GitHub&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;a href="https://dev.to/t/chaosengineering"&gt;&lt;/a&gt;&lt;/p&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;</description><pubDate>Sun, 31 Mar 2024 16:00:00 GMT</pubDate><guid isPermaLink="true">https://www.cncf.io/blog/2024/04/01/elevating-system-resilience-leveraging-litmuschaos-and-backstage-integration/</guid></item><item><title>从 Kyverno 策略生成 Kubernetes ValidatingAdmissionPolicies</title><link>https://www.cncf.io/blog/2024/03/29/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/</link><description>&lt;p&gt;&lt;em&gt;项目帖子最初由 Mariam Fahmy 发布在&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;Kyverno 的博客&lt;/a&gt;上&lt;/em&gt;&lt;/p&gt;&lt;p&gt;在&lt;a href="https://kyverno.io/blog/2023/11/13/using-cel-expressions-in-kyverno-policies/"&gt;上一篇博文&lt;/a&gt;中，我们讨论了在 Kyverno 策略中编写&lt;a href="https://github.com/google/cel-spec"&gt;通用表达式语言 (CEL)&lt;/a&gt;表达式以进行资源验证。 CEL 最初被引入 Kubernetes，用于 CustomResourceDefinitions 的验证规则，然后在 1.26 中被 Kubernetes ValidatingAdmissionPolicies 使用。&lt;/p&gt;&lt;p&gt; ValidatingAdmissionPolicies 提供了一种声明式的进程内替代方案来验证准入 Webhooks。&lt;/p&gt;&lt;p&gt; ValidatingAdmissionPolicies 使用通用表达式语言 (CEL) 来声明策略的验证规则。验证准入策略是高度可配置的，使策略作者能够定义可以根据集群管理员的需要进行参数化和限定资源范围的策略。&lt;/p&gt;&lt;p&gt;这篇文章将向您展示如何从 Kyverno 策略生成 Kubernetes ValidatingAdmissionPolicies 及其绑定。&lt;/p&gt;&lt;h2 class="wp-block-heading" id="prerequisite"&gt;先决条件&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/#prerequisite"&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;生成 Kubernetes ValidatingAdmissionPolicies 需要以下内容：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;具有 Kubernetes 1.26 或更高版本的集群。&lt;/li&gt;&lt;li&gt;启用&lt;code&gt;ValidatingAdmissionPolicy&lt;/code&gt;&lt;a href="https://kubernetes.io/docs/reference/command-line-tools-reference/feature-gates/"&gt;功能门&lt;/a&gt;。&lt;/li&gt;&lt;li&gt;为v1.28和v1.29启用&lt;code&gt;admissionregistration.k8s.io/v1beta1&lt;/code&gt; API。或者 为 v1.26 和 v1.27 启用&lt;code&gt;admissionregistration.k8s.io/v1alpha1&lt;/code&gt; API。&lt;/li&gt;&lt;li&gt;在 Kyverno 准入控制器中设置&lt;code&gt;--generateValidatingAdmissionPolicy&lt;/code&gt;标志。&lt;/li&gt;&lt;li&gt;授予准入控制器服务帐户生成 ValidatingAdmissionPolicies 及其绑定所需的权限。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;在这篇文章中，我们将使用 Kubernetes 1.29 的测试版。&lt;/p&gt;&lt;h2 class="wp-block-heading" id="installation--setup"&gt;安装与设置&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/#installation--setup"&gt;&lt;/a&gt;&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;创建本地集群&lt;/li&gt;&lt;/ol&gt;&lt;pre class="wp-block-code"&gt;&lt;code class=""&gt;kind create cluster --image &amp;quot;kindest/node:v1.28.0&amp;quot; --config - &amp;lt;&amp;lt;EOF kind: Cluster apiVersion: kind.x-k8s.io/v1alpha4 featureGates: ValidatingAdmissionPolicy: true runtimeConfig: admissionregistration.k8s.io/v1beta1: true admissionregistration.k8s.io/v1alpha1: true nodes: - role: control-plane - role: worker EOF&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;巴什&lt;/p&gt;&lt;ol start="2"&gt;&lt;li&gt;添加 Kyverno Helm 存储库。&lt;/li&gt;&lt;/ol&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;helm repo add kyverno https://kyverno.github.io/kyverno/ helm repo update&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;巴什&lt;/p&gt;&lt;ol start="3"&gt;&lt;li&gt;创建一个新文件来覆盖图表中的值。&lt;/li&gt;&lt;/ol&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;cat &amp;lt;&amp;lt; EOF &amp;gt; new-values.yaml features: generateValidatingAdmissionPolicy: enabled: true admissionController: rbac: clusterRole: extraResources: - apiGroups: - admissionregistration.k8s.io resources: - validatingadmissionpolicies - validatingadmissionpolicybindings verbs: - create - update - delete - list EOF&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;巴什&lt;/p&gt;&lt;ol start="4"&gt;&lt;li&gt;部署 Kyverno&lt;/li&gt;&lt;/ol&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;helm install kyverno kyverno/kyverno -n kyverno --create-namespace --version v3.1.4 --values new-values.yaml&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;巴什&lt;/p&gt;&lt;p&gt;我们现在准备从 Kyverno 策略生成 Kubernetes ValidatingAdmissionPolicies。&lt;/p&gt;&lt;h2 class="wp-block-heading" id="generating-kubernetes-validatingadmissionpolicies"&gt;生成 Kubernetes ValidatingAdmissionPolicies &lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/#generating-kubernetes-validatingadmissionpolicies"&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;在本节中，我们将创建一个 Kyverno 策略，确保没有主机路径卷用于部署，然后我们将查看生成的 ValidatingAdmissionPolicy 及其绑定。最后，我们将创建一个违反策略的 Deployment。&lt;/p&gt;&lt;p&gt;让我们从创建 Kyverno 策略开始。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;kubectl apply -f - &amp;lt;&amp;lt;EOF apiVersion: kyverno.io/v1 kind: ClusterPolicy metadata: name: disallow-host-path spec: validationFailureAction: Enforce background: false rules: - name: host-path match: any: - resources: kinds: - Deployment validate: cel: expressions: - expression: &amp;quot;!has(object.spec.template.spec.volumes) || object.spec.template.spec.volumes.all(volume, !has(volume.hostPath))&amp;quot; message: &amp;quot;HostPath volumes are forbidden. The field spec.template.spec.volumes[*].hostPath must be unset.&amp;quot; EOF&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;巴什&lt;/p&gt;&lt;p&gt;您可以从 Kyverno 策略状态检查是否生成了 ValidatingAdmissionPolicy。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;$ kubectl get cpol disallow-host-path -o jsonpath=&amp;#39;{.status}&amp;#39; { &amp;quot;autogen&amp;quot;:{ }, &amp;quot;conditions&amp;quot;:[ { &amp;quot;lastTransitionTime&amp;quot;:&amp;quot;2023-09-12T11:42:13Z&amp;quot;, &amp;quot;message&amp;quot;:&amp;quot;Ready&amp;quot;, &amp;quot;reason&amp;quot;:&amp;quot;Succeeded&amp;quot;, &amp;quot;status&amp;quot;:&amp;quot;True&amp;quot;, &amp;quot;type&amp;quot;:&amp;quot;Ready&amp;quot; } ], &amp;quot;ready&amp;quot;:true, &amp;quot;rulecount&amp;quot;:{ &amp;quot;generate&amp;quot;:0, &amp;quot;mutate&amp;quot;:0, &amp;quot;validate&amp;quot;:1, &amp;quot;verifyimages&amp;quot;:0 }, &amp;quot;validatingadmissionpolicy&amp;quot;:{ &amp;quot;generated&amp;quot;:true, &amp;quot;message&amp;quot;:&amp;quot;&amp;quot; } }&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;巴什&lt;/p&gt;&lt;p&gt;让我们尝试获取 ValidatingAdmissionPolicy 及其绑定。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;$ kubectl get validatingadmissionpolicy NAME VALIDATIONS PARAMKIND AGE disallow-host-path 1 &amp;lt;unset&amp;gt; 8m12s $ kubectl get validatingadmissionpolicybindings NAME POLICYNAME PARAMREF AGE disallow-host-path-binding disallow-host-path &amp;lt;unset&amp;gt; 8m30s&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;巴什&lt;/p&gt;&lt;p&gt;您可能会注意到，ValidatingAdmissionPolicy 和 ValidatingAdmissionPolicyBinding 与它们源自的 Kyverno 策略共享相同的名称，并且绑定具有“-binding”后缀。&lt;/p&gt;&lt;p&gt;让我们详细了解一下 ValidatingAdmissionPolicy 及其绑定。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;$ kubectl get validatingadmissionpolicy disallow-host-path -o yaml apiVersion: admissionregistration.k8s.io/v1beta1 kind: ValidatingAdmissionPolicy metadata: creationTimestamp: &amp;quot;2023-09-12T11:42:13Z&amp;quot; generation: 1 labels: app.kubernetes.io/managed-by: kyverno name: disallow-host-path ownerReferences: - apiVersion: kyverno.io/v1 kind: ClusterPolicy name: disallow-host-path uid: e540d96b-c683-4380-a84f-13411384241a resourceVersion: &amp;quot;11294&amp;quot; uid: 9f3e0161-d010-4a6f-bd28-bf9c87151795 spec: failurePolicy: Fail matchConstraints: matchPolicy: Equivalent namespaceSelector: {} objectSelector: {} resourceRules: - apiGroups: - apps apiVersions: - v1 operations: - CREATE - UPDATE resources: - deployments scope: &amp;#39;*&amp;#39; validations: - expression: &amp;#39;!has(object.spec.template.spec.volumes) || object.spec.template.spec.volumes.all(volume, !has(volume.hostPath))&amp;#39; message: HostPath volumes are forbidden. The field spec.template.spec.volumes[*].hostPath must be unset. variables: null status: observedGeneration: 1 typeChecking: {}&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;巴什&lt;/p&gt;&lt;pre class="wp-block-code"&gt;&lt;code class=""&gt;$ kubectl get validatingadmissionpolicybindings disallow-host-path-binding -o yaml apiVersion: admissionregistration.k8s.io/v1beta1 kind: ValidatingAdmissionPolicyBinding metadata: creationTimestamp: &amp;quot;2023-09-12T11:42:13Z&amp;quot; generation: 1 labels: app.kubernetes.io/managed-by: kyverno name: disallow-host-path-binding ownerReferences: - apiVersion: kyverno.io/v1 kind: ClusterPolicy name: disallow-host-path uid: e540d96b-c683-4380-a84f-13411384241a resourceVersion: &amp;quot;11292&amp;quot; uid: 2fec35c3-8a8c-42a7-8a02-a75e8882a01e spec: policyName: disallow-host-path validationActions: - Deny&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;巴什&lt;/p&gt;&lt;p&gt;现在，让我们尝试部署一个使用 hostPath 的应用程序：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;kubectl apply -f - &amp;lt;&amp;lt;EOF apiVersion: apps/v1 kind: Deployment metadata: name: nginx spec: replicas: 2 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx-server image: nginx volumeMounts: - name: udev mountPath: /data volumes: - name: udev hostPath: path: /etc/udev EOF&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;巴什&lt;/p&gt;&lt;p&gt;正如预期的那样，部署创建被 API 服务器拒绝，而不是被 Kyverno 准入控制器拒绝。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;The deployments &amp;quot;nginx&amp;quot; is invalid: ValidatingAdmissionPolicy &amp;#39;disallow-host-path&amp;#39; with binding &amp;#39;disallow-host-path-binding&amp;#39; denied request: HostPath volumes are forbidden. The field spec.template.spec.volumes[*].hostPath must be unset.&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;巴什&lt;/p&gt;&lt;p&gt;如果 ValidatingAdmissionPolicy 或绑定由于某种原因被删除/更新，则控制器负责恢复它。&lt;/p&gt;&lt;p&gt;让我们尝试删除 ValidatingAdmissionPolicy。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;$ kubectl delete validatingadmissionpolicy disallow-host-path validatingadmissionpolicy.admissionregistration.k8s.io &amp;quot;disallow-host-path&amp;quot; deleted $ kubectl get validatingadmissionpolicy NAME VALIDATIONS PARAMKIND AGE disallow-host-path 1 &amp;lt;unset&amp;gt; 11s&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;巴什&lt;/p&gt;&lt;p&gt;此外，您可以更新Kyverno策略，控制器将相应地重新生成ValidatingAdmissionPolicy。例如，您也可以更改 Kyverno 策略以匹配有状态集。&lt;/p&gt;&lt;p&gt;补丁.yaml：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;spec: rules: - name: host-path match: any: - resources: kinds: - Deployment - StatefulSet validate: cel: expressions: - expression: &amp;quot;!has(object.spec.template.spec.volumes) || object.spec.template.spec.volumes.all(volume, !has(volume.hostPath))&amp;quot; message: &amp;quot;HostPath volumes are forbidden. The field spec.template.spec.volumes[*].hostPath must be unset.&amp;quot;&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt; YAML&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;kubectl patch cpol disallow-host-path --type merge --patch-file patch.yaml&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;巴什&lt;/p&gt;&lt;p&gt;ValidatingAdmissionPolicy 也将更新以匹配 StatefulSet。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;apiVersion: admissionregistration.k8s.io/v1beta1 kind: ValidatingAdmissionPolicy metadata: creationTimestamp: &amp;quot;2023-09-12T12:54:48Z&amp;quot; generation: 2 labels: app.kubernetes.io/managed-by: kyverno name: disallow-host-path ownerReferences: - apiVersion: kyverno.io/v1 kind: ClusterPolicy name: disallow-host-path uid: e540d96b-c683-4380-a84f-13411384241a resourceVersion: &amp;quot;29208&amp;quot; uid: 9325e2b7-9131-4ff4-9e56-244129cb625e spec: failurePolicy: Fail matchConstraints: matchPolicy: Equivalent namespaceSelector: {} objectSelector: {} resourceRules: - apiGroups: - apps apiVersions: - v1 operations: - CREATE - UPDATE resources: - deployments - statefulsets scope: &amp;#39;*&amp;#39; validations: - expression: &amp;#39;!has(object.spec.template.spec.volumes) || object.spec.template.spec.volumes.all(volume, !has(volume.hostPath))&amp;#39; message: HostPath volumes are forbidden. The field spec.template.spec.volumes[*].hostPath must be unset. variables: null status: observedGeneration: 2 typeChecking: {}&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt; YAML&lt;/p&gt;&lt;h2 class="wp-block-heading" id="conclusion"&gt;结论&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/#conclusion"&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;在本博客中，我们讨论了如何从 Kyverno 策略生成 Kubernetes ValidatingAdmissionPolicies。您可以在 Kyverno 策略中使用 CEL 表达式通过 Kyverno 引擎或 API 服务器验证资源。在下一篇博客中，我们将讨论如何为 ValidatingAdmissionPolicies 生成后台扫描报告。 &lt;/p&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;</description><pubDate>Thu, 28 Mar 2024 16:00:00 GMT</pubDate><guid isPermaLink="true">https://www.cncf.io/blog/2024/03/29/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/</guid></item><item><title>Kelsey Hightower 和 Alex Saroyan 的 2024 年云计算趋势</title><link>https://www.cncf.io/blog/2024/03/28/the-2024-trends-on-cloud-computing-by-kelsey-hightower-and-alex-saroyan/</link><description>&lt;p&gt;&lt;em&gt;会员帖子最初发布在&lt;a href="https://www.netris.io/the-2024-trends-on-cloud-computing-by-kelsey-hightower-and-alex-saroyan/"&gt;Netris 的博客&lt;/a&gt;上&lt;/em&gt;&lt;/p&gt;&lt;p&gt;公共云基本上变得相同。大多数公司为&lt;strong&gt;云基础设施&lt;/strong&gt;支付的费用远远高于应有的费用。简而言之，这些陈述总结了&lt;strong&gt;&lt;a href="https://www.netris.io/recap-of-tech-trends-in-2023-and-predictions-for-2024-virtual-roundtable/"&gt;Kelsey Hightower 最近主持的 Netris 圆桌讨论&lt;/a&gt;&lt;/strong&gt;中有关云计算现状的关键要点。&lt;/p&gt;&lt;p&gt;但简洁的总结很难准确反映 Hightower 和其他与会者在活动期间分享的见解 - 因此，为了那些无法现场参加的人，我们想解开我们探索的云计算趋势以及他们对云的未来发展提出了重要观点。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;趋势一：公有云平台差异缩小&lt;/h3&gt;&lt;p&gt;在讨论初期，Hightower 发表了一个听起来可能很直白，但却很难反驳的声明：“截至 2024 年，大多数云提供商的核心产品看起来都是一样的。”&lt;/p&gt;&lt;p&gt;他指的是这样一个事实：所有主要的公共云平台——&lt;strong&gt;亚马逊网络服务、微软Azure和谷歌云平台&lt;/strong&gt;——现在都提供或多或少相同的核心服务集。诚然，他们实施这些服务的方式存在差异。例如， &lt;strong&gt;Amazon EC2&lt;/strong&gt;提供的特定云服务器实例配置与&lt;strong&gt;Azure 虚拟机&lt;/strong&gt;上的配置不同。但抛开细微的差异不谈，大型公共云竞争对手如今都提供几乎相同的服务。&lt;/p&gt;&lt;p&gt;活动参与者一致认为，公共云之间界限的模糊并不是一件坏事。相反，这意味着企业可以不再专注于选择适合自己需求的公有云，同时使用多个云将成为未来的常态&lt;/p&gt;&lt;p&gt;然而，Hightower 和其他人指出的一个症结是，每个公共云供应商提供的本机工具之间仍然存在重要差异。例如，成为 AWS IAM 专家并不一定意味着您有资格在 Azure 上管理 IAM，因为每个云的 IAM 框架涉及不同的概念和工具。&lt;/p&gt;&lt;p&gt;因此，对于想要跨云工作的无缝体验的团队来说，寻找简化工具集和管理流程的方法非常重要，尽管云本身现在都做几乎相同的事情。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;趋势 2：本地云和公有云的界限已经模糊&lt;/h3&gt;&lt;p&gt;Hightower 又做出了一项大胆的声明，他宣称，到 2024 年，本地环境和公共云环境之间的差异基本上不再重要。&lt;/p&gt;&lt;p&gt;他表示，如今企业应该“&lt;strong&gt;减少对云计算和本地部署的关注，而更多地关注这两个世界如何融合&lt;/strong&gt;。”&lt;/p&gt;&lt;p&gt;这是一个大胆的声明，因为在很多方面，本地云和公共云之间确实仍然存在重要差异。例如，与在云中运行的服务器相比，裸机本地服务器为您提供了更多的控制权。从基础设施管理和安全性等角度来看，每种类型的环境也有很大不同。&lt;/p&gt;&lt;p&gt;但 Hightower 并不意味着本地云和公共云实际上已经变得相同。相反，他指的是这样一个事实：现代工具（例如&lt;strong&gt;Netris&lt;/strong&gt; ，它将&lt;strong&gt;公共云网络管理的简单性带入任何环境&lt;/strong&gt;，包括本地）已经使您的工作负载实现非常相似的管理体验，无论它们运行本地或云端。&lt;/p&gt;&lt;p&gt;为了让大家明白这一点，Hightower 还指出，“我讨厌混合云这个词，因为它只会造成混乱。没有任何混合体。只有数据中心。”&lt;/p&gt;&lt;p&gt;这听起来可能有点奇怪，因为混合云（将公共云服务与私有基础设施结合在一起）和其他类型的云平台之间存在架构差异。但 Hightower 并不是说​​混合云实际上不存在。他的意思是，使用现代工具，管理混合云环境与管理本地或公共云环境实际上没有任何不同。&lt;/p&gt;&lt;p&gt;底线：组织应该少担心谁拥有托管给定工作负载的数据中心，而更多地关注确保他们能够有效管理该工作负载。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;趋势三：云成本管理的大胆想法&lt;/h3&gt;&lt;p&gt;随着越来越多的企业寻找控制云支出的方法，FinOps 意味着云成本优化的实践，多年来一直是一个热门话题。优化AWS成本、GCP成本和其他云支出长期以来一直是一个优先事项。&lt;/p&gt;&lt;p&gt;通常，FinOps 建议归结为一些策略，例如选择能够在成本和性能之间实现最佳权衡的云服务器实例。但 Netris 圆桌会议上的人们就如何减少云中的负担提出了一些其他更大胆的想法。&lt;/p&gt;&lt;p&gt; Hightower 走得更远，他建议数据出口（企业为将数据移出云环境而支付的费用）应该免费。 “出口正在杀死公司，”他说，并补充说，想要吸引更多客户的云提供商应该取消出口费用。&lt;/p&gt;&lt;p&gt;我们并不是说您应该要求云提供商为您提供免费出口。他们可能会说不，因为到目前为止，出口收费仍然是标准且普遍存在的。但我们喜欢 Hightower 雄心勃勃的想法，即通过消除云客户早已接受的一些费用，使云从根本上更具成本效益。&lt;/p&gt;&lt;p&gt; Hightower 还指出，在许多情况下，具有可预测工作负载的企业最好通过将其保留在本地来获得最佳服务，这一指导意见违背了“立即将所有内容迁移到云端！”的原则。过去十年或更长时间里主导 IT 行业的建议。他指出，虽然云在您不知道需要多少容量的情况下很有用，但“大多数企业确实知道他们必须支持多少客户以及他们需要什么”——因此，他们不会从云的内置可扩展性中获得太多好处。&lt;/p&gt;&lt;p&gt;我们还将提到，这也是当今使用一致工具管理任何环境的能力如此重要的另一个原因。当您的工具集和管理流程在所有环境中都相同时，您可以将工作负载放置在最有意义的地方，而无需为您支持的每个环境投资不同的管理策略。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;趋势4：VPC正在成为常态&lt;/h3&gt;&lt;p&gt;尽管所有讨论都涉及云平台和架构之间的模糊界限，但圆桌会议与会者确实同意，在云环境中仍然存在一种非常重要的独特环境类型：虚拟私有云或 VPC。&lt;/p&gt;&lt;p&gt; &lt;strong&gt;VPC 是云中的网络结构&lt;/strong&gt;，可创建隔离环境，换句话说，就是虚拟私有云。每个云用户可以创建至少一个VPC。&lt;/p&gt;&lt;p&gt;除了隔离之外，VPC 还包括设计和管理网络所需的基本结构（例如 DHCP、IP 子网、路由、NAT、负载均衡器、访问组和网络访问控制）。因此，当工程师谈论 VPC 时，他们通常不仅指隔离技术，还指 VPC 提供的一套基本网络构造。&lt;/p&gt;&lt;p&gt; VPC 已在主要公共云平台上存在多年，但 Hightower 认为现在是本地、边缘和裸机环境也利用 VPC 的时候了。 “&lt;strong&gt;让世界规范 VPC 的概念非常重要，&lt;/strong&gt;这样我们就可以对网络进行抽象 - 类似于容器对计算的作用，”他说。换句话说，Hightower 认为更多的企业应该利用 VPC 来简化和标准化其公共云和私有云工作负载的网络。&lt;/p&gt;&lt;p&gt; Netris 首席执行官兼联合创始人 Alex Saroyan 补充说，借助 Netris 等工具，管理 VPC 网络变得比以往更加容易。 “我们为他们提供了与云非常相似的 API 和用户体验，而在后端我们会自动处理详细的网络配置，”他解释道。&lt;/p&gt;&lt;p&gt; Hightower 表示同意，并指出 Netris 等工具可用于将公共云中的 VPC 网络与私有云和其他环境中的 VPC 网络统一起来。 &lt;strong&gt;Netris 自动处理大部分复杂的网络工程&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;简而言之，我们期望看到越来越多的组织采用 VPC 作为其私有和公共云战略的一部分。我们还希望他们能够利用 Netris 等工具在其环境的各个方面提供一致的网络管理体验。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;结论：重新思考云战略&lt;/h3&gt;&lt;p&gt;底线是：多年来一直处于云计算中心的许多争论感觉越来越无关紧要。如今，企业需要回答的最重要问题不再是选择哪个公共云平台或将哪些工作负载保留在本地。现代云工具和网络抽象使各种环境更加相似，这意味着将工作负载从一个环境转移到另一个环境已更多地成为业务驱动的决策，而不再是工程麻烦。&lt;/p&gt;&lt;p&gt;因此， &lt;strong&gt;2024 年云战略的首要任务是确保企业能够有效管理其工作负载，无论其托管在何处&lt;/strong&gt;。团队不应再担心他们在云架构或环境上贴上哪些标签，而应该更多地担心他们是否尽可能高效、可靠地管理云的所有组件。 &lt;/p&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;</description><pubDate>Wed, 27 Mar 2024 16:00:00 GMT</pubDate><guid isPermaLink="true">https://www.cncf.io/blog/2024/03/28/the-2024-trends-on-cloud-computing-by-kelsey-hightower-and-alex-saroyan/</guid></item><item><title>错过了 KubeCon + CloudNativeCon Europe 2024？这是您需要了解的一切</title><link>https://www.cncf.io/blog/2024/03/28/missed-kubecon-cloudnativecon-europe-2024-heres-everything-you-need-to-know/</link><description>&lt;p&gt;超过 12,000 人参加了我们在巴黎举行的&lt;a href="https://events.linuxfoundation.org/kubecon-cloudnativecon-europe/"&gt;KubeCon + CloudNativeCon Europe 2024&lt;/a&gt; ，虽然我们讨论了从人工智能到可持续计算的所有内容，但最大的收获是社区令人难以置信的力量。该社区推动了 Kubernetes 和云原生运动的发生，而该社区现在正在推动人工智能、平台工程甚至“绿色”计算计划的采用。&lt;/p&gt;&lt;p&gt;请继续阅读每日精彩内容（如果您想观看演示，可以在我们的&lt;a href="https://www.youtube.com/@cncf/videos"&gt;YouTube 频道&lt;/a&gt;上观看视频。）&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;同期举办活动&lt;/h2&gt;&lt;p&gt;KubeCon + CloudNativeCon Europe 2024 的同期活动始终是非常受欢迎的演示，可以深入探讨特定项目、技术或流程。今年，同一地点举行的活动继续吸引了众多参加者，对于那些新参加会议的人来说，这是与同行会面和建立联系的快速而简单的方式。&lt;a href="https://www.youtube.com/@cncf/playlists"&gt;所有同地举办的活动&lt;/a&gt;均可在 YouTube 上观看（此链接将带您前往每个同地举办的活动的播放列表……点击“查看完整播放列表”即可享受！）。或者， &lt;a href="https://www.cncf.io/blog/2024/03/19/kubecon-cloudnativecon-europe-2024-day-one-co-located-events-and-announcements-recap/"&gt;快速浏览一下&lt;/a&gt;欧洲云原生人工智能日、欧洲平台工程日、欧洲 AppDeveloperCon、云原生创业节等等。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;第一天：云原生如何推动人工智能运动&lt;/h2&gt;&lt;p&gt;毫不奇怪，在 KubeCon + CloudNativeCon Europe 2024 的第一天，人工智能“无处不在”。从人工智能中心的主题演讲到无数的操作演示，以及如何利用云原生充分利用人工智能的讨论– 反之亦然 – 速度又快又激烈，更不用说非常令人兴奋了。深入了解&lt;a href="https://www.youtube.com/@cncf/search?query=AI"&gt;YouTube 上的所有 AI 内容&lt;/a&gt;或&lt;a href="https://www.cncf.io/blog/2024/03/20/kubecon-cloudnativecon-europe-2024-day-two-how-cloud-native-is-powering-the-ai-movement-and-other-news/"&gt;探索精选的精彩内容&lt;/a&gt;。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;第二天：可持续计算的力量&lt;/h2&gt;&lt;p&gt;云原生能够并且将会帮助改善我们的环境足迹，这就是 KubeCon + CloudNativeCon Europe 2024 当天的主题。从负责任的创新到绿色 IT 和云原生架构的革命，全天的主题演讲和其他演讲都讨论了这一重要主题。&lt;a href="https://www.youtube.com/@cncf/search?query=sustainability%202024"&gt;通过视频探索我们所有的可持续发展演示&lt;/a&gt;，或深入&lt;a href="https://www.cncf.io/blog/2024/03/21/kubecon-cloudnativecon-europe-2024-day-three-the-power-of-sustainable-computing/"&gt;阅读当天的内容&lt;/a&gt;。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;第三天：Kubernetes 和云原生的过去与未来&lt;/h2&gt;&lt;p&gt;要结束一场令人难以置信的会议，还有什么比回顾云原生和 Kubernetes 已经取得的进展并展望即将发生的事情更好的方式呢？我们取得了如此多的进展，我们将努力实现更多目标——从日益增长的多样性和包容性到应用程序开发的未来——所有演讲者都发人深省，也令人放心。查看&lt;a href="https://www.youtube.com/@cncf/search?query=cloud%20native%20future%202024"&gt;面向未来的视频演示&lt;/a&gt;，或阅读&lt;a href="https://www.cncf.io/blog/2024/03/22/kubecon-cloudnativecon-europe-2024-day-four-how-cloud-native-is-powering-the-ai-movement-and-other-news/"&gt;当天的亮点&lt;/a&gt;。 &lt;/p&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;</description><pubDate>Wed, 27 Mar 2024 16:00:00 GMT</pubDate><guid isPermaLink="true">https://www.cncf.io/blog/2024/03/28/missed-kubecon-cloudnativecon-europe-2024-heres-everything-you-need-to-know/</guid></item><item><title>Kubernetes 上的 WebAssembly：实践指南（第 02 部分）</title><link>https://www.cncf.io/blog/2024/03/28/webassembly-on-kubernetes-the-practice-guide-part-02/</link><description>&lt;p&gt;&lt;em&gt;&lt;a href="https://github.com/cr7258"&gt;七成&lt;/a&gt;的社区帖子&lt;/em&gt;| &lt;a href="https://www.cncf.io/blog/2024/03/12/webassembly-on-kubernetes-from-containers-to-wasm-part-01/"&gt;在这里查看第一部分&lt;/a&gt;&lt;/p&gt;&lt;p&gt;在上一篇文章中，我概述了 Wasm 的特性和优势。我还解释了如何在容器环境中运行 Wasm 模块。在本文中，我将指导您在云原生生态系统中构建和部署 Wasm 应用程序。你需要：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;登录 Docker Hub（您还可以调整演练以使用不同的容器映像注册表。&lt;/li&gt;&lt;li&gt; Rust 开发环境（本文告诉您如何查找安装说明）。&lt;/li&gt;&lt;li&gt;运行 Debian、Ubuntu 或基于 Debian 的类似 Linux 发行版的 PC。&lt;br /&gt; PC 应具有 AMD64 或兼容的 CPU。&lt;br /&gt;同样，如果您使用不同风格的 Linux 或不同类型的 CPU，您可以调整建议。如果您使用不同的操作系统（不是 Linux），请在虚拟机内设置本地 Linux 环境。&lt;/li&gt;&lt;/ul&gt;&lt;h2 class="wp-block-heading"&gt;使用 Rust 和 WebAssembly 编写示例应用程序&lt;/h2&gt;&lt;p&gt;应用程序是否可以编译为 Wasm 在很大程度上取决于所使用的编程语言。 Rust、C、C++等语言对 Wasm 提供了很好的支持，Go 从 1.21 版本开始对 WASI 提供了初步支持。在此之前，需要使用tinygo等第三方工具进行编译。由于 Rust 对 Wasm 的一流支持，我在本文中使用 Rust 来开发 Wasm 应用程序。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;安装 Rust&lt;/h3&gt;&lt;p&gt;请参考&lt;a href="https://www.rust-lang.org/tools/install"&gt;Rust 安装说明&lt;/a&gt;来安装 Rust。&lt;br /&gt;确保安装 Cargo（Rust 的包管理器）以及 Rust 本身。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;为 Rust 添加 wasm32-wasi 目标&lt;/h3&gt;&lt;p&gt;前面提到，WASI 是 WebAssembly 的系统级接口，旨在促进各种环境下 WebAssembly 与主机系统之间的交互。它提供了一种标准化方法，使 WebAssembly 能够访问文件 I/O、网络和系统调用等系统级功能。&lt;/p&gt;&lt;p&gt; Rustc 是一个跨平台编译器，具有许多编译目标，包括&lt;em&gt;wasm32-wasi&lt;/em&gt; 。该目标将 Rust 代码编译成遵循 WASI 标准的 Wasm 模块。将 Rust 代码编译到 wasm32-wasi 目标可以将 Rust 的功能和安全性集成到 WebAssembly 环境中，同时利用 wasm32-wasi 提供的标准化系统接口与主机系统进行交互。&lt;/p&gt;&lt;p&gt;将 wasm32-wasi 目标添加到 Rust 编译器。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-cpp" lang="cpp"&gt;rustup target add wasm32-wasi&lt;/code&gt;&lt;/pre&gt;&lt;h3 class="wp-block-heading"&gt;编写 Rust 程序&lt;/h3&gt;&lt;p&gt;使用 Cargo new 命令创建一个名为 http-server 的新 Rust 项目：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-cpp" lang="cpp"&gt;cargo new http-server&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;编辑 Cargo.toml 文件以添加下面列出的依赖项。 &lt;a href="https://crates.io/crates/warp_wasi"&gt;&lt;em&gt;warp_wasi&lt;/em&gt;&lt;/a&gt;是专门为 WASI 设计的，构建在&lt;a href="https://docs.rs/warp/latest/warp/"&gt;&lt;em&gt;Warp&lt;/em&gt;&lt;/a&gt;框架之上，Warp 框架是一个轻量级 Web 服务器框架，用于开发高性能异步 Web 应用程序。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-csharp" lang="csharp"&gt;[dependencies]&lt;br /&gt; tokio_wasi = { version = &amp;quot;1&amp;quot;, features = [&amp;quot;rt&amp;quot;, &amp;quot;macros&amp;quot;, &amp;quot;net&amp;quot;, &amp;quot;time&amp;quot;, &amp;quot;io-util&amp;quot;]}&lt;br /&gt; warp_wasi = &amp;quot;0.3&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建一个简单的 HTTP 服务器，在端口 8080 上公开服务并返回“Hello, World!”当收到请求时。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-csharp" lang="csharp"&gt;use warp::Filter;&lt;br /&gt;&lt;br /&gt; #[tokio::main(flavor = &amp;quot;current_thread&amp;quot;)]&lt;br /&gt; async fn main() {&lt;br /&gt;    let hello = warp::get()&lt;br /&gt;        .and(warp::path::end())&lt;br /&gt;        .map(|| &amp;quot;Hello, World!&amp;quot;);&lt;br /&gt;&lt;br /&gt;    println!(&amp;quot;Listening on http://0.0.0.0:8080&amp;quot;);&lt;br /&gt;    warp::serve(hello).run(([0, 0, 0, 0], 8080)).await;&lt;br /&gt; }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将该文件作为 main.rs 保存到您的 PC 上。&lt;br /&gt;将程序编译成Wasm模块，会写入项目的target/wasm32-wasi/release目录下。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;cargo build --target wasm32-wasi --release&lt;/code&gt;&lt;/pre&gt;&lt;h3 class="wp-block-heading"&gt;安装 WasmEdge&lt;/h3&gt;&lt;p&gt;编译后的 Wasm 模块需要适当的 Wasm 运行时才能执行。流行的选择包括 WasmEdge、Wasmtime 和 Wasmer 等。&lt;/p&gt;&lt;p&gt;在本文中，我使用&lt;a href="https://wasmedge.org/docs/"&gt;&lt;em&gt;WasmEdge&lt;/em&gt;&lt;/a&gt; ，这是一个轻量级、高性能且可扩展的 WebAssembly 运行时。&lt;/p&gt;&lt;p&gt;通过运行以下命令安装 WasmEdge：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;# Running scripts directly via curl | bash has security implications.&lt;br /&gt; # Carefully examine the script content and only execute if you completely understand and trust the source.&lt;br /&gt; curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使已安装的二进制文件在当前会话中可用：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;source $HOME/.wasmedge/env&lt;/code&gt;&lt;/pre&gt;&lt;h3 class="wp-block-heading"&gt;运行 Wasm 模块&lt;/h3&gt;&lt;p&gt;您可以使用 wasmedge 命令来运行 Wasm 模块：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;wasmedge target/wasm32-wasi/release/http-server.wasm&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;向本地运行的服务发送请求：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;curl http://localhost:8080&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出是：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;Hello, World!&lt;/code&gt;&lt;/pre&gt;&lt;h2 class="wp-block-heading"&gt;在 Linux 容器中运行 Wasm 模块&lt;/h2&gt;&lt;p&gt;在当前容器生态系统中无缝运行 Wasm 模块的最简单方法是将 Wasm 模块嵌入到 Linux 容器镜像中。接下来，我将演示如何实现这一点。&lt;/p&gt;&lt;p&gt;使用编译的 Wasm 模块构建 Linux 容器映像。我将解释如何使用 Docker 来实现这一点，这是制作容器映像的一种非常常见的方法。在 http-server 项目的根目录中创建一个名为 Dockerfile-wasmedge-slim 的&lt;em&gt;Dockerfile&lt;/em&gt; 。在 Dockerfile 中，将 Wasm 模块包含在安装了 wasmedge 的 slim Linux 映像中，并使用 wasmedge 命令执行 Wasm 模块。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;FROM wasmedge/slim-runtime:0.10.1&lt;br /&gt; COPY target/wasm32-wasi/release/http-server.wasm /&lt;br /&gt; CMD [&amp;quot;wasmedge&amp;quot;, &amp;quot;--dir&amp;quot;, &amp;quot;.:/&amp;quot;, &amp;quot;/http-server.wasm&amp;quot;]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;构建容器镜像：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;# replace cr7258 with your own Docker Hub repository name&lt;br /&gt; docker build -f Dockerfile-wasmedge-slim -t cr7258/wasm-demo-app:slim .&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了在本地测试代码，我将使用 Docker 运行容器：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;docker run -itd -p 8080:8080 \&lt;br /&gt; --name wasm-demo-app \&lt;br /&gt; docker.io/cr7258/wasm-demo-app:slim&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;向本地测试容器中运行的服务发送请求：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;curl http://localhost:8080&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出是：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;Hello, World!&lt;/code&gt;&lt;/pre&gt;&lt;h2 class="wp-block-heading"&gt;在支持 Wasm 的容器运行时中运行 Wasm 模块&lt;/h2&gt;&lt;p&gt;在上一节中，我展示了如何将 Wasm 模块嵌入到 Linux 容器中来运行 Wasm 模块。接下来，我将从低级和高级容器运行时的角度演示如何使用支持 Wasm 的容器运行时直接运行 Wasm 模块。这种方法提供了更好的安全性和性能。&lt;/p&gt;&lt;p&gt;在运行 Wasm 模块之前，请将其构建到没有 Linux 操作系统的映像中。 &lt;em&gt;scrap&lt;/em&gt;是 Docker 中保留的最小基础镜像。 Dockerfile 如下所示：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;FROM scratch&lt;br /&gt; COPY target/wasm32-wasi/release/http-server.wasm /&lt;br /&gt; CMD [&amp;quot;/http-server.wasm&amp;quot;]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;构建容器镜像。这次创建的镜像大约只有之前构建的 wasm-demo-app:slim 镜像大小的 1/4。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;# replace cr7258 with your own Docker Hub repository name&lt;br /&gt; docker build -t docker.io/cr7258/wasm-demo-app:v1 .&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了方便后面的demo使用，请将镜像推送到Docker Hub。将存储库替换为您自己的存储库。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;# replace cr7258 with your own Docker Hub repository name&lt;br /&gt; docker push docker.io/cr7258/wasm-demo-app:v1&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下来，我将单独演示如何通过低级和高级容器运行时运行 Wasm 模块。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;通过低级容器运行时运行 Wasm 模块&lt;/h3&gt;&lt;p&gt;&lt;a href="https://github.com/containers/crun"&gt;&lt;em&gt;Crun&lt;/em&gt;&lt;/a&gt;是一个用 C 语言编写的快速且轻量级的 OCI 容器运行时，它内置了对 WasmEdge 的支持。在本节中，我将演示如何利用 crun 使用提供的 config.json 和 rootfs 文件直接启动 Wasm 模块，而不依赖于高级容器运行时。&lt;/p&gt;&lt;p&gt; 💡 确保您已按照“ &lt;a href="https://docs.google.com/document/d/1eM-iK_0s-Z7daLe1w_8TKujj5cxHl4S6/edit#bookmark=id.gjdgxs"&gt;安装 WasmEdge”部分中的说明安装了 WasmEdge&lt;/a&gt; 。&lt;/p&gt;&lt;p&gt;安装编译所需的依赖项。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;apt update&lt;br /&gt; apt install -y make git gcc build-essential pkgconf libtool \&lt;br /&gt;    libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev \&lt;br /&gt;    go-md2man libtool autoconf python3 automake&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;配置、构建和安装包含 WasmEdge 支持的 crun 二进制文件：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;git clone https://github.com/containers/crun&lt;br /&gt; cd crun&lt;br /&gt; ./autogen.sh&lt;br /&gt; ./configure --with-wasmedge&lt;br /&gt; make&lt;br /&gt; make install&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行crun -v 检查安装是否成功。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;crun -v&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看到+WASM:wasmedge表示crun中已经安装了WasmEdge。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;crun version 1.8.5.0.0.0.23-3856&lt;br /&gt; commit: 385654125154075544e83a6227557bfa5b1f8cc5&lt;br /&gt; rundir: /run/crun&lt;br /&gt; spec: 1.0.0&lt;br /&gt; +SYSTEMD +SELINUX +APPARMOR +CAP +SECCOMP +EBPF +WASM:wasmedge +YAJL&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建一个目录，用于存储运行容器所需的文件和目录（config.json和rootfs），&lt;br /&gt;然后复制到根文件系统：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;mkdir test-crun&lt;br /&gt; cd test-crun&lt;br /&gt; mkdir rootfs&lt;br /&gt; # Copy the compiled Wasm module to the rootfs directory, replace it with the appropriate directory path for your system.&lt;br /&gt; cp ~/hands-on-lab/wasm/runtime/http-server/target/wasm32-wasi/release/http-server.wasm rootfs&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行 crun spec 命令生成默认的 config.json 配置文件，然后进行以下修改：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;将 args 字段中的 sh 替换为 /http-server.wasm。&lt;/li&gt;&lt;li&gt;在注释字段中添加“module.wasm.image/variant”:“compat”以表明这是一个没有客户操作系统的 Wasm 应用程序。&lt;/li&gt;&lt;li&gt;在网络命名空间中添加“path”：“/proc/1/ns/net”，以允许程序与宿主机共享网络命名空间。这将使我们能够在本地访问容器。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;修改后的配置文件应如下所示：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;{ &amp;quot;ociVersion&amp;quot;: &amp;quot;1.0.0&amp;quot;, &amp;quot;process&amp;quot;: { &amp;quot;terminal&amp;quot;: true, &amp;quot;user&amp;quot;: { &amp;quot;uid&amp;quot;: 0, &amp;quot;gid&amp;quot;: 0 }, &amp;quot;args&amp;quot;: [ &amp;quot;/http-server.wasm&amp;quot; ], &amp;quot;env&amp;quot;: [ &amp;quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&amp;quot;, &amp;quot;TERM=xterm&amp;quot; ], &amp;quot;cwd&amp;quot;: &amp;quot;/&amp;quot;, &amp;quot;capabilities&amp;quot;: { &amp;quot;bounding&amp;quot;: [ &amp;quot;CAP_AUDIT_WRITE&amp;quot;, &amp;quot;CAP_KILL&amp;quot;, &amp;quot;CAP_NET_BIND_SERVICE&amp;quot; ], &amp;quot;effective&amp;quot;: [ &amp;quot;CAP_AUDIT_WRITE&amp;quot;, &amp;quot;CAP_KILL&amp;quot;, &amp;quot;CAP_NET_BIND_SERVICE&amp;quot; ], &amp;quot;inheritable&amp;quot;: [ ], &amp;quot;permitted&amp;quot;: [ &amp;quot;CAP_AUDIT_WRITE&amp;quot;, &amp;quot;CAP_KILL&amp;quot;, &amp;quot;CAP_NET_BIND_SERVICE&amp;quot; ], &amp;quot;ambient&amp;quot;: [ &amp;quot;CAP_AUDIT_WRITE&amp;quot;, &amp;quot;CAP_KILL&amp;quot;, &amp;quot;CAP_NET_BIND_SERVICE&amp;quot; ] }, &amp;quot;rlimits&amp;quot;: [ { &amp;quot;type&amp;quot;: &amp;quot;RLIMIT_NOFILE&amp;quot;, &amp;quot;hard&amp;quot;: 1024, &amp;quot;soft&amp;quot;: 1024 } ], &amp;quot;noNewPrivileges&amp;quot;: true }, &amp;quot;root&amp;quot;: { &amp;quot;path&amp;quot;: &amp;quot;rootfs&amp;quot;, &amp;quot;readonly&amp;quot;: true }, &amp;quot;hostname&amp;quot;: &amp;quot;crun&amp;quot;, &amp;quot;mounts&amp;quot;: [ { &amp;quot;destination&amp;quot;: &amp;quot;/proc&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;proc&amp;quot;, &amp;quot;source&amp;quot;: &amp;quot;proc&amp;quot; }, { &amp;quot;destination&amp;quot;: &amp;quot;/dev&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;tmpfs&amp;quot;, &amp;quot;source&amp;quot;: &amp;quot;tmpfs&amp;quot;, &amp;quot;options&amp;quot;: [ &amp;quot;nosuid&amp;quot;, &amp;quot;strictatime&amp;quot;, &amp;quot;mode=755&amp;quot;, &amp;quot;size=65536k&amp;quot; ] }, { &amp;quot;destination&amp;quot;: &amp;quot;/dev/pts&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;devpts&amp;quot;, &amp;quot;source&amp;quot;: &amp;quot;devpts&amp;quot;, &amp;quot;options&amp;quot;: [ &amp;quot;nosuid&amp;quot;, &amp;quot;noexec&amp;quot;, &amp;quot;newinstance&amp;quot;, &amp;quot;ptmxmode=0666&amp;quot;, &amp;quot;mode=0620&amp;quot;, &amp;quot;gid=5&amp;quot; ] }, { &amp;quot;destination&amp;quot;: &amp;quot;/dev/shm&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;tmpfs&amp;quot;, &amp;quot;source&amp;quot;: &amp;quot;shm&amp;quot;, &amp;quot;options&amp;quot;: [ &amp;quot;nosuid&amp;quot;, &amp;quot;noexec&amp;quot;, &amp;quot;nodev&amp;quot;, &amp;quot;mode=1777&amp;quot;, &amp;quot;size=65536k&amp;quot; ] }, { &amp;quot;destination&amp;quot;: &amp;quot;/dev/mqueue&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;mqueue&amp;quot;, &amp;quot;source&amp;quot;: &amp;quot;mqueue&amp;quot;, &amp;quot;options&amp;quot;: [ &amp;quot;nosuid&amp;quot;, &amp;quot;noexec&amp;quot;, &amp;quot;nodev&amp;quot; ] }, { &amp;quot;destination&amp;quot;: &amp;quot;/sys&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;sysfs&amp;quot;, &amp;quot;source&amp;quot;: &amp;quot;sysfs&amp;quot;, &amp;quot;options&amp;quot;: [ &amp;quot;nosuid&amp;quot;, &amp;quot;noexec&amp;quot;, &amp;quot;nodev&amp;quot;, &amp;quot;ro&amp;quot; ] }, { &amp;quot;destination&amp;quot;: &amp;quot;/sys/fs/cgroup&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;cgroup&amp;quot;, &amp;quot;source&amp;quot;: &amp;quot;cgroup&amp;quot;, &amp;quot;options&amp;quot;: [ &amp;quot;nosuid&amp;quot;, &amp;quot;noexec&amp;quot;, &amp;quot;nodev&amp;quot;, &amp;quot;relatime&amp;quot;, &amp;quot;ro&amp;quot; ] } ], &amp;quot;annotations&amp;quot;: { &amp;quot;module.wasm.image/variant&amp;quot;: &amp;quot;compat&amp;quot; }, &amp;quot;linux&amp;quot;: { &amp;quot;resources&amp;quot;: { &amp;quot;devices&amp;quot;: [ { &amp;quot;allow&amp;quot;: false, &amp;quot;access&amp;quot;: &amp;quot;rwm&amp;quot; } ] }, &amp;quot;namespaces&amp;quot;: [ { &amp;quot;type&amp;quot;: &amp;quot;pid&amp;quot; }, { &amp;quot;type&amp;quot;: &amp;quot;network&amp;quot;, &amp;quot;path&amp;quot;: &amp;quot;/proc/1/ns/net&amp;quot; }, { &amp;quot;type&amp;quot;: &amp;quot;ipc&amp;quot; }, { &amp;quot;type&amp;quot;: &amp;quot;uts&amp;quot; }, { &amp;quot;type&amp;quot;: &amp;quot;cgroup&amp;quot; }, { &amp;quot;type&amp;quot;: &amp;quot;mount&amp;quot; } ], &amp;quot;maskedPaths&amp;quot;: [ &amp;quot;/proc/acpi&amp;quot;, &amp;quot;/proc/asound&amp;quot;, &amp;quot;/proc/kcore&amp;quot;, &amp;quot;/proc/keys&amp;quot;, &amp;quot;/proc/latency_stats&amp;quot;, &amp;quot;/proc/timer_list&amp;quot;, &amp;quot;/proc/timer_stats&amp;quot;, &amp;quot;/proc/sched_debug&amp;quot;, &amp;quot;/sys/firmware&amp;quot;, &amp;quot;/proc/scsi&amp;quot; ], &amp;quot;readonlyPaths&amp;quot;: [ &amp;quot;/proc/bus&amp;quot;, &amp;quot;/proc/fs&amp;quot;, &amp;quot;/proc/irq&amp;quot;, &amp;quot;/proc/sys&amp;quot;, &amp;quot;/proc/sysrq-trigger&amp;quot; ] } }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用 crun 启动容器：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;crun run wasm-demo-app&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;向该容器中的演示服务发送请求：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;curl http://localhost:8080&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出是：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;Hello, World!&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要删除容器，可以执行以下命令：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;crun kill wasm-demo-app SIGKILL&lt;/code&gt;&lt;/pre&gt;&lt;h3 class="wp-block-heading"&gt;通过高级容器运行时运行 Wasm 模块&lt;/h3&gt;&lt;p&gt;&lt;em&gt;容器填充程序&lt;/em&gt;充当高级和低级容器运行时之间的桥梁。其主要目的是抽象低层运行时细节，实现高层运行时对各种低层运行时的统一管理。在本节中，我将使用&lt;a href="https://github.com/containerd/containerd"&gt;&lt;em&gt;containerd&lt;/em&gt;&lt;/a&gt;作为示例。 Containerd 是一个行业标准的容器运行时，强调简单性、稳健性和可移植性。&lt;/p&gt;&lt;p&gt; Containerd 可以通过两种方式管理 Wasm 模块：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;通过 crun 和 youki 等支持使用 Wasm 运行时库构建的容器运行时来管理 Wasm 模块。这两个运行时也可以运行常规 Linux 容器。 Containerd 使用containerd-shim-runc-v2 与低级容器运行时交互。&lt;/li&gt;&lt;li&gt;直接通过 Wasm 运行时管理 Wasm 模块，例如 Slight、Spin、WasmEdge 和 Wasmtime。 Containerd 使用 containerd-wasm-shim(runwasi) 与 Wasm 运行时交互。&lt;/li&gt;&lt;/ol&gt;&lt;h4 class="wp-block-heading"&gt;容器+Crun&lt;/h4&gt;&lt;p&gt;在本节中，我将演示如何将 crun 配置为 containerd 中的运行时，从而支持运行 Wasm 模块。&lt;/p&gt;&lt;p&gt; 💡 确保已按照以下部分中的说明安装了支持 Wasm 的 crun 二进制文件： &lt;a href="https://docs.google.com/document/d/1eM-iK_0s-Z7daLe1w_8TKujj5cxHl4S6/edit#bookmark=id.30j0zll"&gt;通过低级容器运行时运行 Wasm 模块&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;运行以下命令安装containerd：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;export VERSION=&amp;quot;1.7.3&amp;quot;&lt;br /&gt; sudo apt install -y libseccomp2&lt;br /&gt; sudo apt install -y wget&lt;br /&gt;&lt;br /&gt; wget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz&lt;br /&gt; wget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum&lt;br /&gt; # expected checksum: ea70faeb6c5d656fa0787dfc7d88a48daf961482c46bb22953cb5396289fd5b8&lt;br /&gt; sha256sum --check cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum&lt;br /&gt;&lt;br /&gt; sudo tar --no-overwrite-dir -C / -xzf cri-containerd-cni-${VERSION}-linux-amd64.tar.gz&lt;br /&gt; sudo systemctl daemon-reload&lt;br /&gt; sudo systemctl enable containerd --now&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;您可以通过containerd运行Wasm模块：&lt;/p&gt;&lt;ul&gt;&lt;li&gt; –runc-binary：指定使用crun作为低级运行时来启动容器。&lt;/li&gt;&lt;li&gt; –runtime：指定shim的版本和名称，由containerd转换为shim的二进制名称。例如：io.containerd.runc.v2→containerd-shim-runc-v2。 Containerd 通过运行 containerd-shim-runc-v2 二进制文件来启动 shim，该文件随后调用 crun 来启动容器。&lt;/li&gt;&lt;li&gt; –label：添加“module.wasm.image/variant”：“compat”以指示这是一个没有客户操作系统的 Wasm 应用程序。&lt;/li&gt;&lt;/ul&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;# Pull the image&lt;br /&gt; ctr i pull docker.io/cr7258/wasm-demo-app:v1&lt;br /&gt;&lt;br /&gt; # Run the container&lt;br /&gt; ctr run --rm --net-host \&lt;br /&gt; --runc-binary crun \&lt;br /&gt; --runtime io.containerd.runc.v2 \&lt;br /&gt; --label module.wasm.image/variant=compat \&lt;br /&gt; docker.io/cr7258/wasm-demo-app:v1 \&lt;br /&gt; wasm-demo-app&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;向该容器中的演示服务发送请求：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;curl http://localhost:8080&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出是：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;Hello, World!&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要删除容器，可以执行以下命令。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;ctr task kill wasm-demo-app --signal SIGKILL&lt;/code&gt;&lt;/pre&gt;&lt;h4 class="wp-block-heading"&gt; Containerd + Runwasi&lt;/h4&gt;&lt;p&gt; &lt;a href="https://github.com/containerd/runwasi"&gt;&lt;em&gt;Runwasi&lt;/em&gt;&lt;/a&gt;是一个用Rust编写的库，是containerd的子项目。使用runwasi，您可以编写一个containerd wasm shim来与Wasm运行时集成，这有助于直接运行由containerd管理的Wasm模块。有几种使用 runwasi 开发的 Containerd wasm shim，包括：&lt;/p&gt;&lt;ul&gt;&lt;li&gt; WasmEdge、Wasmtime 和 Wasmer，您可以在&lt;a href="https://github.com/containerd/runwasi/tree/main/crates"&gt;runwasi&lt;/a&gt;存储库中找到它们。&lt;/li&gt;&lt;li&gt; Spin、Slight、Wasm Workers Server 和 Lunatic，您可以在&lt;a href="https://github.com/deislabs/containerd-wasm-shims"&gt;containerd-wasm-shims&lt;/a&gt;存储库中找到它们。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在本文中，我使用 WasmEdge containerd shim 来运行 Wasm 模块。&lt;/p&gt;&lt;p&gt;克隆 runwasi 存储库。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;git clone https://github.com/containerd/runwasi.git&lt;br /&gt; cd runwasi&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装编译所需的依赖项。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;sudo apt-get -y install    \&lt;br /&gt;      pkg-config          \&lt;br /&gt;      libsystemd-dev      \&lt;br /&gt;      libdbus-glib-1-dev  \&lt;br /&gt;      build-essential     \&lt;br /&gt;      libelf-dev          \&lt;br /&gt;      libseccomp-dev      \&lt;br /&gt;      libclang-dev        \&lt;br /&gt;      libssl-dev&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;构建并安装垫片。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;make build&lt;br /&gt; sudo make install&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;指定 –runtime=io.containerd.wasmedge.v1 通过 WasmEdge shim 运行 Wasm 模块。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;ctr run --rm --net-host \&lt;br /&gt; --runtime=io.containerd.wasmedge.v1 \&lt;br /&gt; docker.io/cr7258/wasm-demo-app:v1 \&lt;br /&gt; wasm-demo-app&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;向该容器中的演示服务发送请求：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;curl http://localhost:8080&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出是：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;Hello, World!&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要删除容器，可以执行以下命令。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;ctr task kill wasm-demo-app --signal SIGKILL&lt;/code&gt;&lt;/pre&gt;&lt;h2 class="wp-block-heading"&gt;在容器管理平台上运行 Wasm 模块&lt;/h2&gt;&lt;h3 class="wp-block-heading"&gt;在 Docker Desktop 上运行 Wasm 模块&lt;/h3&gt;&lt;p&gt;当您开发软件时，您希望在本地和云端进行尝试。我将使用 Docker Desktop 作为可用于在容器内本地运行代码的工具示例。&lt;/p&gt;&lt;p&gt; Docker Desktop 还使用 runwasi 来支持 Wasm 模块。按照&lt;a href="https://docs.docker.com/desktop/wasm/#turn-on-wasm-workloads"&gt;Docker Wasm 文档&lt;/a&gt;中的说明在 Docker Desktop 上启用 Wasm 支持。&lt;/p&gt;&lt;p&gt;使用以下 docker run 命令在系统上启动 Wasm 容器。 –runtime=io.containerd.wasmedge.v1 通知 Docker 引擎您想要使用 Wasm containerd shim 而不是标准的 Linux 容器运行时。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;docker run -d -p 8080:8080 \&lt;br /&gt; --name=wasm-demo-app \&lt;br /&gt; --runtime=io.containerd.wasmedge.v1 \&lt;br /&gt; docker.io/cr7258/wasm-demo-app:v1&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;向该容器中的演示服务发送请求：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;curl http://localhost:8080&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出是：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;Hello, World!&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要删除容器，可以执行以下命令：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;docker rm -f wasm-demo-app&lt;/code&gt;&lt;/pre&gt;&lt;h3 class="wp-block-heading"&gt;在 Kubernetes 上运行 Wasm 模块&lt;/h3&gt;&lt;p&gt;要在 Kubernetes 上运行 Wasm 工作负载，工作节点需要使用 Wasm 运行时进行引导，并且 RuntimeClass 对象用于将工作负载分配给支持 Wasm 的节点。&lt;/p&gt;&lt;p&gt; &lt;a href="https://kind.sigs.k8s.io/"&gt;&lt;em&gt;Kind&lt;/em&gt;&lt;/a&gt; （Docker 中的 Kubernetes）是一种使用本地容器作为“节点”运行本地 Kubernetes 集群的工具，通常在 Docker 中。为了方便实验，我们使用kind创建一个Kubernetes集群，以供后续章节使用。运行以下命令来安装 kind：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;[ $(uname -m) = x86_64 ] &amp;amp;&amp;amp; curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64&lt;br /&gt; chmod +x ./kind&lt;br /&gt; sudo mv ./kind /usr/local/bin/kind&lt;/code&gt;&lt;/pre&gt;&lt;h4 class="wp-block-heading"&gt;手动为 Wasm 设置集群，然后在 pod 内运行应用程序&lt;/h4&gt;&lt;p&gt;在本节中，我将演示使用 WasmEdge 运行时库手动安装 crun，并调整 containerd 配置以使用 crun 作为运行时，从而在 Kubernetes 节点上启用 Wasm 支持。&lt;/p&gt;&lt;p&gt;使用kind创建单节点Kubernetes集群。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;kind create cluster --name wasm-demo&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;按种类创建的每个 Kubernetes 节点都是一个容器，通常在 Docker 中运行。您可以使用 docker exec 命令进入该节点。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;docker exec -it wasm-demo-control-plane bash&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 💡 在节点上输入 shell 后，按照以下部分中的说明进行操作： &lt;a href="https://docs.google.com/document/d/1eM-iK_0s-Z7daLe1w_8TKujj5cxHl4S6/edit#bookmark=id.30j0zll"&gt;通过低级容器运行时运行 Wasm 模块&lt;/a&gt;，以在节点上安装支持 Wasm 的 crun 二进制文件。&lt;/p&gt;&lt;p&gt;修改containerd配置文件/etc/containerd/config.toml，在最后添加以下内容：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;将 crun 配置为 containerd 的运行时处理程序。格式为 [plugins.”io.containerd.grpc.v1.cri”.containerd.runtimes.${HANDLER_NAME}]。&lt;/li&gt;&lt;li&gt; pod_annotations 允许将注释 module.wasm.image/variant 传递给 crun，该注释在 Pod 元数据中设置以识别 Wasm 工作负载。&lt;/li&gt;&lt;/ul&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;cat &amp;gt;&amp;gt; /etc/containerd/config.toml &amp;lt;&amp;lt; EOF&lt;br /&gt; [plugins.&amp;quot;io.containerd.grpc.v1.cri&amp;quot;.containerd.runtimes.crun]&lt;br /&gt;    runtime_type = &amp;quot;io.containerd.runc.v2&amp;quot;&lt;br /&gt;    pod_annotations = [&amp;quot;module.wasm.image/variant&amp;quot;]&lt;br /&gt; [plugins.&amp;quot;io.containerd.grpc.v1.cri&amp;quot;.containerd.runtimes.crun.options]&lt;br /&gt;    BinaryName = &amp;quot;crun&amp;quot;&lt;br /&gt; EOF&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;重新启动容器：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;systemctl restart containerd&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在节点上设置标签runtime=crun：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;kubectl label nodes wasm-demo-control-plane runtime=crun&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建一个名为 crun 的 RuntimeClass 资源，以使用 containerd 中预先配置的 crun 处理程序，scheduling.nodeSelector 属性将 pod 发送到带有 runtime=crun 标签的节点。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;apiVersion: node.k8s.io/v1&lt;br /&gt; kind: RuntimeClass&lt;br /&gt; metadata:&lt;br /&gt;  name: crun&lt;br /&gt; scheduling:&lt;br /&gt;  nodeSelector:&lt;br /&gt;    runtime: crun&lt;br /&gt; handler: crun&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下来，在 Kubernetes Pod 中运行 Wasm 应用程序。为 pod 设置 .spec.runtimeClassName 以将 pod 定位到 crun RuntimeClass。这将确保 pod 被分配到 crun RuntimeClass 中指定的节点和运行时。此外，设置注释 module.wasm.image/variant: compat 以通知 crun 这是一个 Wasm 工作负载。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;apiVersion: v1&lt;br /&gt; kind: Pod&lt;br /&gt; metadata:&lt;br /&gt;  name: wasm-demo-app&lt;br /&gt;  annotations:&lt;br /&gt;    module.wasm.image/variant: compat&lt;br /&gt; spec:&lt;br /&gt;  runtimeClassName: crun&lt;br /&gt;  containers:&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;名称：wasm-演示应用程序&lt;br /&gt;图片：docker.io/cr7258/wasm-demo-app:v1&lt;/li&gt;&lt;/ul&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;&lt;br /&gt;You can use `kubectl port-forward` to forward traffic from your local machine into the Kubernetes cluster:&lt;br /&gt;&lt;br /&gt; ```bash&lt;br /&gt; kubectl port-forward pod/wasm-demo-app 8080:8080&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;打开一个新终端，向服务发送请求。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;curl http://localhost:8080&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出是：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;Hello, World!&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;测试完成后，您可以通过运行以下命令来销毁集群：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;kind delete cluster --name wasm-demo&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在本文中， module.wasm.image/variant: compat 注解用于向容器运行时指示该工作负载是 Wasm 工作负载。在此&lt;a href="https://github.com/containers/crun/pull/886"&gt;PR&lt;/a&gt;中，crun 引入了一个新的注释：module.wasm.image/variant: compat-smart。&lt;/p&gt;&lt;p&gt;当使用compat-smart注解时，crun可以根据是Wasm工作负载还是OCI容器智能判断如何启动容器。这使得使用 sidecar 运行 WASM 容器成为可能。以下是包含 Wasm 容器和 Linux 容器的 Pod YAML 文件示例：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;apiVersion: v1&lt;br /&gt; kind: Pod&lt;br /&gt; metadata:&lt;br /&gt;  name: wasm-demo-app&lt;br /&gt;  annotations:&lt;br /&gt;    module.wasm.image/variant: compat-smart # Kubernetes copies Pod annotations to container runtime labels, which is why this works.&lt;br /&gt; spec:&lt;br /&gt;  runtimeClassName: crun&lt;br /&gt;  containers:&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;名称：wasm-演示应用程序&lt;br /&gt;图片：docker.io/cr7258/wasm-demo-app:v1&lt;/li&gt;&lt;li&gt;名称：linux-demo-app&lt;br /&gt;图片：nginx：1.20&lt;/li&gt;&lt;/ul&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;&lt;br /&gt;#### Set up your cluster for Wasm automatically using Kwasm, then run the app inside a pod&lt;br /&gt;&lt;br /&gt; _[Kwasm](https://kwasm.sh/)_ is a Kubernetes Operator that automatically adds WebAssembly support to your Kubernetes nodes. In this section, I will demostrate how to use Kwasm Operator to add Wasm support to Kubernetes nodes automatically.&lt;br /&gt;&lt;br /&gt; To enable Wasm support on a particular node, simply add the annotation `kwasm.sh/kwasm-node=true` on that node. This will trigger Kwasm to create a Job to deploy the necessary binary files needed to run Wasm on the node. Additionally, containerd&amp;#39;s configuration will be modified accordingly.&lt;br /&gt;&lt;br /&gt; ![02-kwasm-operator](https://hackmd.io/_uploads/HyYbqsF2p.svg)&lt;br /&gt;&lt;br /&gt;&lt;br /&gt; Create a single-node Kubernetes cluster using kind.&lt;br /&gt;&lt;br /&gt; ```bash&lt;br /&gt; kind create cluster --name kwasm-demo&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; Helm 图表可用于轻松安装 Kwasm 操作器。使用 helm 安装 Kwasm Operator，并通过添加注释 kwasm.sh/kwasm-node=true 启用对节点 kwasm-demo-control-plane 的 Wasm 支持。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;# Add Helm repository if not already done&lt;br /&gt; helm repo add kwasm http://kwasm.sh/kwasm-operator/&lt;br /&gt; # Install KWasm operator&lt;br /&gt; helm install -n kwasm --create-namespace kwasm-operator kwasm/kwasm-operator&lt;br /&gt; # Provision Nodes&lt;br /&gt; kubectl annotate node kwasm-demo-control-plane kwasm.sh/kwasm-node=true&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在节点上添加标签runtime=wasmedge。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;kubectl label nodes kwasm-demo-control-plane runtime=wasmedge&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; kwasm-node-installer 版本 v0.3.0 已删除 crun 以支持 WasmEdge shim。 WasmEdge shim 与 module.wasm.image/variant 具有相同的行为：crun + Wasmedge 的 compat-smart 注释，但不需要注释。&lt;/p&gt;&lt;p&gt;创建一个名为 wasmedge 的 RuntimeClass 资源，以使用 kwasm 在 containerd 中自动设置的 wasmedge 处理程序，scheduling.nodeSelector 属性将 pod 发送到带有 runtime=wasmedge 标签的节点。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;apiVersion: node.k8s.io/v1&lt;br /&gt; kind: RuntimeClass&lt;br /&gt; metadata:&lt;br /&gt;  name: wasmedge&lt;br /&gt; scheduling:&lt;br /&gt;  nodeSelector:&lt;br /&gt;    runtime: wasmedge&lt;br /&gt; handler: wasmedge&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下来，在 Kubernetes Pod 中运行 Wasm 应用程序。为 pod 设置 .spec.runtimeClassName 以将 pod 定位到 wasmedge RuntimeClass。这将确保 pod 被分配到 wasmedge RuntimeClass 中指定的节点和运行时。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;apiVersion: v1&lt;br /&gt; kind: Pod&lt;br /&gt; metadata:&lt;br /&gt;  name: wasm-demo-app&lt;br /&gt; spec:&lt;br /&gt;  runtimeClassName: wasmedge&lt;br /&gt;  containers:&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;名称：wasm-演示应用程序&lt;br /&gt;图片：docker.io/cr7258/wasm-demo-app:v1&lt;/li&gt;&lt;/ul&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;&lt;br /&gt;You can use `kubectl port-forward` to forward traffic from your local machine into the Kubernetes cluster:&lt;br /&gt;&lt;br /&gt; ```bash&lt;br /&gt; kubectl port-forward pod/wasm-demo-app 8080:8080&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;打开一个新终端，向服务发送请求。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;curl http://localhost:8080&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出是：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;Hello, World!&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;测试完成后，您可以通过运行以下命令来销毁集群：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;kind delete cluster --name kwasm-demo&lt;/code&gt;&lt;/pre&gt;&lt;h2 class="wp-block-heading"&gt;结论&lt;/h2&gt;&lt;p&gt;随着 WebAssembly 的不断发展，它在 Kubernetes 中的采用标志着云原生应用程序开发向前迈出了重要一步。&lt;/p&gt;&lt;p&gt;感谢您阅读这篇文章。我希望它有助于了解 WebAssembly 的潜力以及它如何与容器生态系统配合使用。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;致谢&lt;/h2&gt;&lt;p&gt;本文包含 Kubernetes 项目的贡献和反馈，版权所有 © 2024 Linux 基金会。 &lt;/p&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;</description><pubDate>Wed, 27 Mar 2024 16:00:00 GMT</pubDate><guid isPermaLink="true">https://www.cncf.io/blog/2024/03/28/webassembly-on-kubernetes-the-practice-guide-part-02/</guid></item><item><title>通过 AI 驱动的 DevEx 实现工作流程自动化和管道可移植性</title><link>https://www.cncf.io/blog/2024/03/27/workflow-automation-pipeline-portability-with-ai-driven-devex/</link><description>&lt;p&gt;&lt;em&gt;会员帖子最初由 Amina Reshma 在&lt;a href="https://ozone.one/workflow-automation-&amp;amp;-pipeline-portability-with-ai-driven-devex"&gt;Ozone 博客&lt;/a&gt;上发布&lt;/em&gt;&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;与 DevEx 有什么关系？&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;破解代码：&lt;/strong&gt;曾经想过开发者体验，又名.a。开发执行？好吧，这就是整个东西——氛围、工具、仪式——基本上，是软件开发人员成功或失败的秘密武器。&lt;/p&gt;&lt;p&gt;那么，为什么衡量开发人员的生产力如此困难呢？首先，DevEx 很难描述。关于开发人员生产力的定义，存在着众多不同的观点。此外，必须考虑过程（定量）和感知（定性）指标。评估开发人员的成就感水平与衡量他们的生产力同样重要。&lt;/p&gt;&lt;p&gt;满意的开发人员更有可能留在您的组织中，并花更多时间编码和交付高质量的产品。由于 DevEx 是多方面的，没有任何一种数据能够完全捕捉到其本质。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;为什么要炒作？&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;人才磁铁：&lt;/strong&gt; DevEx 是您吸引和留住顶尖技术人才的后台通行证。这就像开发商的VIP休息室。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;有钱能使鬼推磨：&lt;/strong&gt;这不仅仅关系到快乐的程序员；还关系到快乐的程序员。这是关于钱的。 DevEx 直接影响您的开发团队的生产力，您猜对了，这会影响您的利润。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;文化俱乐部：&lt;/strong&gt; DevEx 不仅仅是一个工具箱；这是一种氛围。这是为了培育一种文化，让编码感觉就像一场精心策划的即兴演奏会。&lt;/li&gt;&lt;/ul&gt;&lt;h3 class="wp-block-heading"&gt;何必呢？&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;创新或死亡：DevEx 是创新的燃料。想要保持领先吗？更好地保持您的 DevEx 游戏的强大。&lt;/li&gt;&lt;li&gt;战略棋步：投资 DevEx 就像下棋，而不是跳棋。这是一项长期战略，为快乐、高效且极具创造力的开发团队奠定了基础。&lt;/li&gt;&lt;/ul&gt;&lt;h2 class="wp-block-heading"&gt;增强 DevEx 游戏的 6 大举措&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;标准化和容器化&lt;/strong&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;想象一下 Docker 和 Kubernetes 作为您的可靠性助手，标准化您的开发传奇。&lt;/li&gt;&lt;li&gt;不再是“它可以在我的机器上运行”——现在是“它可以在任何地方、普遍运行！”&lt;/li&gt;&lt;/ul&gt;&lt;ol start="2"&gt;&lt;li&gt;&lt;strong&gt;文档和入职培训&lt;/strong&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;让您的代码库文档保持最佳状态，并使入职流程比丝绸之路更加顺畅。&lt;/li&gt;&lt;li&gt;文档可以作为您的文化指南针 - 让它们变得全面，让它们变得像夏洛克那样聪明。&lt;/li&gt;&lt;/ul&gt;&lt;ol start="3"&gt;&lt;li&gt;&lt;strong&gt;工具链&lt;/strong&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;从 IDE 到版本控制，保持工具的完善，就像工匠最喜欢的工具包一样。&lt;/li&gt;&lt;li&gt;使用的工具应该与开发人员门户完美匹配，即使您没有，也不应该妨碍您拥有良好的 DevEx。&lt;/li&gt;&lt;/ul&gt;&lt;ol start="4"&gt;&lt;li&gt;&lt;strong&gt;代码质量&lt;/strong&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;让静态代码分析器和 linter 为您的开发人员进行质量检查探戈。&lt;/li&gt;&lt;li&gt;更少的手动审查，更少的麻烦——保持代码环境无可挑剔的干净。&lt;/li&gt;&lt;/ul&gt;&lt;ol start="5"&gt;&lt;li&gt;&lt;strong&gt;开发者自主权&lt;/strong&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;让您的开发人员在决策中拥有发言权——让他们成为主角。&lt;/li&gt;&lt;li&gt;开发人员正在修复他们的故障吗？这不是混乱；而是混乱。这就是赋权的奥秘。&lt;/li&gt;&lt;/ul&gt;&lt;ol start="6"&gt;&lt;li&gt;&lt;strong&gt;人工智能：您在发展领域的新朋友&lt;/strong&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我们已经看到人工智能 (AI) 在各个领域发挥其魔力。对于提升 DevEx 也是如此！以下是人工智能如何重塑多个行业的用户体验的快速浏览：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;医疗保健：&lt;/strong&gt;通过预测分析、个性化治疗计划和高效的患者护理系统来改变医疗保健。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;金融：&lt;/strong&gt;简化欺诈检测、自动化重复任务并提供数据驱动的见解，以改善金融领域的决策。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;制造：&lt;/strong&gt;通过预测性维护、质量控制和自主系统增强制造流程。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;客户服务：&lt;/strong&gt;人工智能驱动的聊天机器人和虚拟助理正在通过提供即时帮助和增强用户体验来改变客户服务。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;人工智能在 DevEx 中的潜力&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;提高灵活性：&lt;/strong&gt;生成式人工智能正在慢慢缩小框架之间的界限，使它们之间的转换变得轻而易举。 &lt;a href="https://ozone.one/the-role-of-large-language-models-(llms)-in-automating-pipeline-conversions-from-legacy-to-tekton"&gt;这是一篇关于如何通过使用户能够通过自动化在新时代框架和旧框架之间进行切换来重新定义用户体验的文章&lt;/a&gt;。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;简化流程：&lt;/strong&gt; Picture AI 可以自动执行重复性任务，使开发人员能够专注于工作中更复杂和更具创造性的方面。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;改进文档：&lt;/strong&gt;人工智能驱动的工具有助于创建强大的、用户友好的文档，使开发人员更容易理解和为项目做出贡献。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;我们看到的一个流行用例是 Github Copilot。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt; GitHub Copilot 是一款由 GitHub 和 OpenAI 开发的人工智能驱动的代码完成工具，处于重塑开发者体验 (DevEx) 的最前沿。 GitHub Copilot 基于 OpenAI 的 Codex 构建，显着提高了工作效率，调查显示用户的工作效率提高了 55%。这种自动代码完成工具与 Visual Studio Code 和其他 IDE 无缝集成，可根据所编写代码的上下文建议巧妙的代码片段、完整功能和常见模式。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt; GitHub Copilot 的优势&lt;/h3&gt;&lt;p&gt;GitHub Copilot 通过最大限度地减少手动编码时间、改进样板代码创建以及快速解决 IDE 中的问题，从而显着提高开发速度，从而提高部署频率。此外，它还通过快速生成测试用例和数据来提高代码质量和测试覆盖率，从而改善开发人员体验 (DevEx)。作为虚拟的第二开发人员，Copilot Chat 可以加快代码审查时间，帮助创建高质量代码，并通过解释促进彻底理解。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt; GitHub Copilot 的缺点&lt;/h3&gt;&lt;p&gt;尽管有其优势，GitHub Copilot 也遇到了挑战，特别是由于其广泛的知识库而导致潜在的许可和版权问题。该工具的局限性包括可能缺乏特定领域的知识，从而阻碍了专业领域的精确建议。 GitHub Copilot 可能会面临不太常见的语言、框架或不可定制的库的困难，造成与公共存储库或闭源数据中易受攻击的代码相关的安全问题，可能导致版权问题。此外，该工具还引发了人们对完成代码会阻碍开发人员的担忧，这些代码可能看起来正确，但可能容易受到攻击或充满安全问题，从而破坏学习过程。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;超越 GitHub Copilot 的人工智能&lt;/h2&gt;&lt;p&gt;DevOps 的一项主要挑战是新技术的无缝过渡和采用，尤其是在迁移管道方面。新技术迁移历来都是采用的瓶颈。对于拥有大量管道的团队来说，从 Jenkins、GitLab 或 Azure Pipelines 过渡到 Tekton Pipelines 具有战略意义，因为它植根于 Kubernetes 和云原生方法。 Tekton Pipelines 提供优化的工作流程，加速云原生 DevOps 并通过动态集群管理确保性能和可扩展性。 Kubernetes 原生设计符合最佳实践，提高资源效率，并简化采用云原生方法的组织的管道管理。&lt;/p&gt;&lt;p&gt; Ozone 在使管道可移植性成为人工智能的无缝用户体验方面迈出了重要一步。通过利用先进的自动化，Ozone 使用人工智能来促进管道的顺利技术转型。这解决了与新技术采用相关的历史瓶颈，为希望通过多种管道拥抱 DevOps 的团队提供了解决方案。管道转换的自动化确保了无麻烦的转变，使团队更有吸引力地采用新技术，而不会遇到通常的复杂性和挑战。通过这种方式，Ozone 结合了人工智能和 DevOps 的力量，提供了一种解决方案，彻底改变了管道迁移过程，并使团队能够无缝地采用新技术。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;为什么需要管道可移植性&lt;/h2&gt;&lt;p&gt;对于深深植根于 Kubernetes 和云原生方法的组织来说，从 Jenkins、GitLab 或 Azure Pipelines 过渡到 Tekton Pipelines 具有战略意义。 Tekton Pipelines 为以 Kubernetes 为中心的项目提供优化的工作流程，加速云原生 DevOps，并通过动态集群管理实现性能和可扩展性。通过 Kubernetes 原生设计，Tekton 与容器化和声明式配置等云原生最佳实践无缝结合。此迁移提高了资源效率并简化了采用云原生方法的组织的管道管理。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;它是如何完成的&lt;/h2&gt;&lt;h3 class="wp-block-heading"&gt;大规模自动化管道转换的工作流程&lt;/h3&gt;&lt;figure class="wp-block-image size-full"&gt;&lt;img alt="显示自动管道转换的流程图" class="wp-image-104797" height="1678" src="https://www.cncf.io/wp-content/uploads/2024/03/devex_ai_7ad3041f49.jpg" width="1999" /&gt;&lt;/figure&gt;&lt;p&gt;该工作流程的主要目标是通过利用 Prompt Engineering 使用大型语言模型 (LLM) 简化转换过程。这涉及利用聊天上下文和基于角色的提示为 LLM 模型建立上下文，使用各种平台的示例管道训练模型以定义相应的 YAML。&lt;/p&gt;&lt;p&gt;正如本博客所强调的，为了吸引顶尖技术人才、影响团队生产力并最终影响利润，必须理解和改善开发人员体验 (DevEx)。随着 Kubernetes 和云原生方法与 Tekton Pipelines 保持一致，Ozone 理解管道可移植性的战略重要性，特别是从 Jenkins、GitLab 或 Azure Pipelines 传输时。&lt;/p&gt;&lt;p&gt;将现有管道转换为可重复使用的 Tekton 管道的功能终身免费向每个用户开放，用户、构建、项目和管道不受限制。&lt;a href="https://cd.ozone.one/emailsignup"&gt;立即注册以转换您的管道！&lt;/a&gt;&lt;/p&gt;&lt;p&gt; &lt;a href="https://www.ozone.one/"&gt;Ozone&lt;/a&gt;专注于消除 DevOps 团队的各种复杂性。它简化并自动化了跨混合云和多样化区块链网络的容器化和去中心化应用程序部署。 Ozone 与 CI、CD、分析和自动化领域的主要工具无缝集成，以支持您端到端的软件交付，即使是最复杂的场景也是如此。&lt;/p&gt;&lt;p&gt;请写信给我们： &lt;a href="mailto:info@ozone.one"&gt;info@ozone.one&lt;/a&gt; &lt;/p&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;</description><pubDate>Tue, 26 Mar 2024 16:00:00 GMT</pubDate><guid isPermaLink="true">https://www.cncf.io/blog/2024/03/27/workflow-automation-pipeline-portability-with-ai-driven-devex/</guid></item></channel></rss>