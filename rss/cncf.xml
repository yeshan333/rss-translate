<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>CNCF - 博客</title><link>https://www.cncf.io/blog/</link><description>CNCF - 博客 - RSSHub 用爱制作(https://github.com/DIYgod/RSSHub)</description><lastBuildDate>Tue, 02 Apr 2024 16:04:07 GMT</lastBuildDate><generator>rfeed v1.1.1</generator><docs>https://github.com/svpino/rfeed/blob/master/README.md</docs><item><title>Gödel Scheduler 开源：在线和离线工作负载的统一调度程序</title><link>https://www.cncf.io/blog/2024/04/02/godel-scheduler-open-sourced-a-unified-scheduler-for-online-and-offline-workloads/</link><description>&lt;p&gt;&lt;em&gt;字节跳动的会员帖子&lt;/em&gt;&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;自 2014 年开源以来，Kubernetes 已迅速成为容器编排事实上的标准。字节跳动的基础设施团队很早就采用了 Kubernetes 来构建我们的私有云平台。多年来，字节跳动在微服务、推荐/广告/搜索服务、机器学习与大数据、存储等各业务线的快速增长，导致对计算资源的需求大幅增长。 &lt;/p&gt;&lt;figure class="wp-block-image"&gt;&lt;img alt="图像" src="https://lh7-us.googleusercontent.com/aiyjHAn71MVHGmgoDMYMdkguB-XqRGdLk_hmyAjuBXsqBzZcbTkKYY4oWUbNe-INqe_bV08otBKPJPTKXAg30qYxS6PFP9Wywucy15bC8xmowgex102r9rZXYYjMteIKhYlMwS3vktDCcY72pFjOow" /&gt;&lt;/figure&gt;&lt;p&gt;最初，字节跳动使用单独的资源池来管理其在线和离线工作负载，每个资源池专用于不同的业务部门。为了适应重大节假日和重大活动期间在线业务需求的激增，基础设施团队通常需要提前规划，将线下资源重新分配到线上池，以增强处理在线活动增加的能力。虽然这一临时解决方案满足了即时需求，但池间资源借用过程被证明非常耗时、操作繁重且效率低下。此外，为在线和离线工作负载维护单独的资源池会导致大量的主机托管成本，几乎没有提高资源利用率的空间。因此，基础设施团队寻求实现一个统一的系统来调度和管理在线和离线工作负载。该举措旨在促进资源池化，提高资源利用率和弹性，优化成本和用户体验，减轻运营负担。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;strong&gt;统一调度实践&lt;/strong&gt;&lt;/h2&gt;&lt;h3 class="wp-block-heading"&gt;&lt;strong&gt;Kubernetes 默认调度程序之外的增强功能：&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;自2018年广泛使用Kubernetes以来，字节跳动不断优化Kubernetes的各个组件的功能和性能。但随着2019年推荐/广告/搜索服务的容器化，原生的Kubernetes调度器无论是功能还是性能都距离满足字节跳动的业务需求越来越远。在功能上，需要更细粒度的资源调度能力和灵活的抢占策略。在性能方面，原生 Kubernetes 默认调度器在 5000 个节点的集群中只能实现每秒 10 个 Pod 左右的调度吞吐量，往往会导致业务升级遇到瓶颈，远远不能满足要求。因此，团队对 Kubernetes 默认调度器引入了多项关键优化，包括：&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;&lt;strong&gt;功能&lt;/strong&gt;：&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;扩展了调度功能以支持非本地资源，例如内存带宽和网络带宽。&lt;/li&gt;&lt;li&gt;支持微拓扑调度。&lt;/li&gt;&lt;li&gt;通过提供可插拔的抢占框架来支持扩展抢占功能，重构了抢占实现。&lt;/li&gt;&lt;/ul&gt;&lt;h3 class="wp-block-heading"&gt;&lt;strong&gt;表现&lt;/strong&gt;：&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;通过重构数据结构，进一步强化快照间增量更新的理念，优化Scheduler缓存与Snapshot之间的数据同步机制。&lt;/li&gt;&lt;li&gt;对同构调度单元的调度结果进行缓存，减少冗余计算，提高效率。&lt;/li&gt;&lt;li&gt;通过重新组织抢占相关的数据结构，及时进行剪枝，减少不必要的计算，优化抢占实现。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;通过上述优化，我们成功增强了容器化能力，满足了字节跳动快速扩张的需求。这使得调度吞吐量显着增加了 30 倍。也就是说，在包含 10,000 个节点的集群中，我们始终实现每秒 300 个 Pod 的调度速率。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;strong&gt;哥德尔调度器&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;2020年，字节跳动启动了线上线下业务运营的统一调度和资源管理项目。目标是提高整体资源利用率、提高运营效率并减少维护费用。最初，该计划涉及通过单一调度系统管理在线和离线任务。然而，这种方法提出了挑战，主要是由于离线调度的复杂性，它与在线流程明显不同，尤其是对高吞吐量的需求。&lt;/p&gt;&lt;p&gt;原生的 Kubernetes 调度器主要是为 Pod 级别的调度而设计的，它对更复杂的“Job”调度语义的支持有些有限，并且在处理这些更高级别的需求时遇到了性能限制。为了有效满足这些独特的需求，并更好地满足字节跳动多样化的运营需求，决定开发一个定制的内部分布式调度器。这导致了 Gödel Scheduler 的创建，专门用于与 Kubernetes 系统集成，并处理字节跳动广阔且不断发展的业务环境中苛刻且多样化的调度需求。&lt;/p&gt;&lt;p&gt; Gödel Scheduler 是一个分布式系统，旨在整合在线和离线工作负载的调度。该调度程序是 Kubernetes (K8s) 调度程序的增强版，旨在增强可扩展性并提高调度质量。善于满足字节跳动线上线下运营多样化的功能和性能需求。哥德尔调度程序的主要功能包括：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;乐观并发&lt;/strong&gt;：它结合了乐观并发概念，将最耗时的单元到节点匹配（过滤和评分）移至调度程序组件。这允许并发执行并提高大规模集群中的调度吞吐量。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;两层调度抽象&lt;/strong&gt;（Unit和Pod）&lt;strong&gt;和框架&lt;/strong&gt;：提供更灵活的批量调度能力，更好地支持离线操作，同时提高调度吞吐量和系统可扩展性。扩展框架更有效地处理特殊场景。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;功能丰富、性能卓越&lt;/strong&gt;：满足线上、线下（批、流）、训练任务等多种作业需求，实现真正的统一调度。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;与 Kubernetes 生态系统的兼容性&lt;/strong&gt;：可以作为 K8s Scheduler 的替代方案，但由于性能和架构优化，其框架接口与 K8s Scheduler 并不完全相同。但它的扩展性不受影响，可以实现类似 Kubernetes 的调度插件。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;下图是Gödel Scheduler的架构图。 &lt;/p&gt;&lt;figure class="wp-block-image"&gt;&lt;img alt="图像" src="https://lh7-us.googleusercontent.com/UWj3cxod92AL8B8NbCxJHEyxANnpd4jtUcovpzjaHK-HME0PuNw7NWiXxj4_yBOuPb5RsrpjSwBF6t61Xiy05W4wza2wt4bZEK6d3qAz9PtVvfSbWs0gwC4m-aglyyQDyTsfC7dFiOLPVcXmpYAX_A" /&gt;&lt;/figure&gt;&lt;p&gt;如上所述，Gödel Scheduler 由三个主要组件组成：Dispatcher、Scheduler 和 Binder。其架构的关键是 Scheduler 组件，该组件通常部署在多个分片中以促进乐观并发调度。这种多分片部署提高了其效率和可扩展性。另一方面，Dispatcher 和 Binder 均部署为单个实例，这种配置适合它们在 Gödel Scheduler 系统中的特定角色和职责。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;&lt;strong&gt;调度员&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;调度程序在管理应用程序排队、分发和节点分区方面发挥着关键作用。它由几个关键组件组成：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;排序策略管理器&lt;/strong&gt;：该模块处理应用程序的排队。目前，它实现了 FIFO 和 DRF/FairShare 排队策略，后者仍有待生产使用。未来的增强功能将引入更复杂的排队策略，包括基于优先级值的策略。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;调度策略管理器&lt;/strong&gt;：其主要功能是跨各种调度程序实例分配应用程序。目前默认采用LoadBalance策略。未来的更新旨在使此功能更加通用且基于插件。&lt;/li&gt;&lt;li&gt; &lt;strong&gt;Node Shuffler&lt;/strong&gt; ：该组件的任务是根据 Scheduler 实例的数量组织集群节点。它将每个节点分配给特定的节点分区，每个调度程序实例监督一个分区。在调度过程中，调度程序首先考虑其分区内的节点，然后再探索其他分区中的节点。这种安排是动态调整的，以响应节点可用性或调度程序计数的变化。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;分区规则&lt;/strong&gt;：目前，系统力求节点在 Scheduler 实例之间均匀分布。目前正在计划扩展这些分区策略，增强其可配置性。&lt;/li&gt;&lt;li&gt; &lt;strong&gt;Scheduler Maintenanceer&lt;/strong&gt; ：该元素负责监控 Scheduler 实例的状态。它跟踪健康状态、工作负载和每个分区内的节点计数等方面。&lt;/li&gt;&lt;li&gt; &lt;strong&gt;Reconciler&lt;/strong&gt; ：定期运行，Reconciler 监督 Pod、节点、调度程序和 SchedulingUnit 等各种元素的状态。它可以解决任何错误、差异或缺陷，确保系统完整性和性能。&lt;/li&gt;&lt;/ol&gt;&lt;h3 class="wp-block-heading"&gt;&lt;strong&gt;调度程序&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;Scheduler 在调度和抢占应用程序的决策过程中发挥着关键作用，尽管它本身并不执行这些决策（该任务由 Binder 处理）。它在两层框架上运行：Unit Scheduling Framework 和 Pod Scheduling Framework。整个调度过程分为三个主要阶段：节点组织、单元调度和单元抢占。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;节点组织&lt;/strong&gt;：此阶段涉及对节点进行过滤和排序，以简化调度过程并提高其质量。它由两种类型的插件组成：&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;定位插件：这些过滤器节点基于特定的应用程序信息。&lt;/li&gt;&lt;li&gt;分组插件：这些插件根据可用资源或作业级别关联性对节点进行分组。&lt;/li&gt;&lt;/ul&gt;&lt;ol start="2"&gt;&lt;li&gt;&lt;strong&gt;单元调度&lt;/strong&gt;：在此阶段，节点将根据已通过节点组织插件过滤的应用程序请求进行匹配和评分。此过程类似于 Kubernetes (K8s) 调度程序框架，包括：&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;过滤插件：这些过滤器节点基于应用程序请求的要求。&lt;/li&gt;&lt;li&gt;评分插件：这些插件将分数分配给上一步中已过滤的节点。&lt;/li&gt;&lt;/ul&gt;&lt;ol start="3"&gt;&lt;li&gt; &lt;strong&gt;Unit Preempting&lt;/strong&gt; ：如果在Unit Scheduling阶段没有找到合适的节点，Scheduler就会进入抢占阶段。在这里，它尝试通过抢占正在运行的应用程序实例来释放资源，为新的应用程序实例腾出空间。这一阶段包括：&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;受害者搜索：识别可被抢占的潜在受害者应用程序。&lt;/li&gt;&lt;li&gt;候选者排序：对节点和潜在受害者进行排序，以确定最合适的抢占选择。&lt;/li&gt;&lt;/ul&gt;&lt;h3 class="wp-block-heading"&gt;&lt;strong&gt;活页夹&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;Binder 在调度过程的最后阶段起着至关重要的作用，重点是冲突检测、抢占操作以及执行应用程序与资源的绑定。它由三个主要组件组成：ConflictResolver、PreemptionOperator 和 UnitBinder。&lt;/p&gt;&lt;ol&gt;&lt;li&gt; &lt;strong&gt;ConflictResolver&lt;/strong&gt; ：该组件的任务是检测调度过程中的并发冲突。它以两种模式运行：&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;跨节点冲突解决程序：检查不同节点之间可能发生的冲突。&lt;/li&gt;&lt;li&gt;单节点冲突解决程序：识别单个节点内的冲突。&lt;br /&gt;如果检测到任何冲突，申请将立即被拒绝并重新安排。&lt;/li&gt;&lt;/ul&gt;&lt;ol start="2"&gt;&lt;li&gt; &lt;strong&gt;PreemptionOperator&lt;/strong&gt; ：在不存在冲突但需要抢占的场景下，由该算子负责。它通过删除受害者（需要终止以释放资源的应用程序或进程）来执行抢占，然后等待最终的调度。&lt;/li&gt;&lt;li&gt; &lt;strong&gt;UnitBinder&lt;/strong&gt; ：这部分Binder负责绑定之前所需的准备工作，比如动态创建存储卷，然后进行实际的绑定操作，将应用程序链接到指定的资源。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;值得注意的是，当前版本的 Binder 集成了 PodGroup 控制器。该控制器负责管理 PodGroup 的状态和生命周期。然而，值得注意的是，在未来的版本中，我们计划从 Binder 中删除此功能，将其转换为独立的控制器。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;strong&gt;经验&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;在过去的两年里，Gödel Scheduler 一直是字节跳动的基石，提供了丰富的调度功能和语义。高效可靠地支撑了字节跳动多样化、复杂业务负载的运行。&lt;/p&gt;&lt;p&gt;在架构增强的基础上，字节跳动借鉴 Kubernetes 原生调度器的经验，实现了深刻的性能优化。与字节跳动内部完善的 Kubernetes 系统集成后，Gödel Scheduler 现在拥有令人印象深刻的吞吐量：单个分片中 2000+ pod/s，跨多个分片 5000+ pod/s。字节跳动不断努力扩大单集群容量，其最大的产品集群已达到超过 20,000 个节点和超过 1,000,000 个 Pod。&lt;/p&gt;&lt;p&gt;经过字节跳动内部多年的深入实践和增强，Gödel Scheduler已经达到了相对稳定的状态。 2023年，顶级云计算会议SoCC接受了我们关于Gödel Scheduler的论文，凸显了字节跳动大规模资源管理和调度的统一方法。研发团队还受邀在会议上展示了他们的工作。对于感兴趣的人，可以在 https://dl.acm.org/doi/10.1145/3620678.3624663 上获取 Gödel Scheduler 论文。&lt;/p&gt;&lt;p&gt;出于对开源社区的贡献，字节跳动团队决定开源Gödel Scheduler，提供全新的调度解决方案，通过出色的性能和全面的调度能力，增强线上线下服务的云原生体验。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;strong&gt;未来的工作&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;展望未来，字节跳动致力于Gödel Scheduler的持续开发，重点丰富其功能并增强其可扩展性。一个重要的关注领域是优化特定挑战性场景中的调度吞吐量，例如涉及高部署率和频繁抢占的场景。通过创新的重新调度策略，字节跳动旨在解决维持调度性能和提高调度质量之间的复杂平衡。首要目标不仅是保持当前的调度吞吐量，而且还大幅提高调度质量。&lt;/p&gt;&lt;p&gt;此外，字节跳动高度重视生态系统的发展。我们将努力确保 Gödel Scheduler 与各种业务应用程序中使用的领先系统和框架的兼容性。该计划将包括与著名的大数据和机器学习框架的集成，并附有实际使用示例和全面的文档。&lt;/p&gt;&lt;p&gt;为了保持社区的参与和知情，将有条不紊地制定 Gödel Scheduler 的详细路线图，并在 Gödel Scheduler Repository 上提供。这将为感兴趣的各方提供跟踪进度、做出贡献并成为项目积极参与者的机会。&lt;/p&gt;&lt;p&gt;虽然哥德尔调度器在字节跳动内部经历了多次迭代，在各种场景下经过了严格的测试，并证明了其有效性，但字节跳动承认，在通用性和标准化方面仍然有很大的进步潜力。字节跳动热忱邀请并鼓励社区成员参与哥德尔调度器的开发，相信共同努力将带来更大的改进和创新。&lt;/p&gt;&lt;p&gt;哥德尔调度程序项目存储库： &lt;a href="https://github.com/kubewharf/godel-scheduler"&gt;https&lt;/a&gt; ://github.com/kubewharf/godel-scheduler &lt;/p&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;</description><pubDate>Mon, 01 Apr 2024 16:00:00 GMT</pubDate><guid isPermaLink="true">https://www.cncf.io/blog/2024/04/02/godel-scheduler-open-sourced-a-unified-scheduler-for-online-and-offline-workloads/</guid></item><item><title>提升系统弹性：利用 LitmusChaos 和 Backstage 集成</title><link>https://www.cncf.io/blog/2024/04/01/elevating-system-resilience-leveraging-litmuschaos-and-backstage-integration/</link><description>&lt;p&gt;&lt;em&gt;项目发布者：Namkyu Park&lt;/em&gt; ， &lt;em&gt;LitmusChaos 维护者 ( &lt;a href="https://www.linkedin.com/in/namkyupark1999/?locale=en_US"&gt;LinkedIn&lt;/a&gt; | &lt;a href="https://github.com/namkyu1999"&gt;GitHub&lt;/a&gt; )&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;em&gt;这篇博文提供了使用 LitmusChaos 注入混沌并使用 Backstage 进行管理的分步说明。&lt;/em&gt; &lt;/p&gt;&lt;hr class="wp-block-separator has-alpha-channel-opacity" /&gt;&lt;h2 class="wp-block-heading"&gt;&lt;a href="https://dev.to/namkyu1999/a-beginners-guide-to-litmus-and-backstage-4p18-temp-slug-9264283?preview=1ab316fd623b5144a4102e4057db0744e32cd289a39a2ffc04e5bdaca4caf5f173faa3b2c345da6204b570a6cf4896c8000346f60706789e13f405d5#table-of-contents"&gt;&lt;/a&gt;目录&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;混沌工程、LitmusChaos 和 Backstage&lt;/li&gt;&lt;li&gt;先决条件&lt;/li&gt;&lt;li&gt;我们的演示由什么组成？&lt;/li&gt;&lt;li&gt;演示环境&lt;/li&gt;&lt;li&gt;使用 LitmusChaos 注入混沌&lt;/li&gt;&lt;li&gt;在后台管理 LitmusChaos 内容&lt;/li&gt;&lt;li&gt;概括&lt;/li&gt;&lt;/ul&gt;&lt;hr class="wp-block-separator has-alpha-channel-opacity" /&gt;&lt;h2 class="wp-block-heading"&gt;&lt;a href="https://dev.to/namkyu1999/a-beginners-guide-to-litmus-and-backstage-4p18-temp-slug-9264283?preview=1ab316fd623b5144a4102e4057db0744e32cd289a39a2ffc04e5bdaca4caf5f173faa3b2c345da6204b570a6cf4896c8000346f60706789e13f405d5#chaos-engineering-litmuschaos-and-backstage"&gt;&lt;/a&gt;混沌工程、LitmusChaos 和 Backstage&lt;/h2&gt;&lt;p&gt;随着包括 Kubernetes 在内的云原生技术变得越来越复杂，应用程序由更多组件组成。您的系统有弹性吗？例如，如果您的一个容器由于 OOM 而宕机，它是否会自动重新创建并做好准备？&lt;a href="https://principlesofchaos.org/"&gt;混沌工程&lt;/a&gt;是一门对系统进行实验的学科，目的是建立对系统承受生产中湍流条件的能力的信心。 &lt;a href="https://docs.litmuschaos.io/docs/introduction/what-is-litmus"&gt;LitmusChaos&lt;/a&gt; （CNCF孵化项目）是一个具有跨云支持的云原生混沌工程框架。您可以使用 LitmusChaos 将混乱注入不同的基础设施层。&lt;/p&gt;&lt;figure class="wp-block-image"&gt; &lt;a href="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F52ajvswmhak5nuu0oced.png"&gt;&lt;img alt="下层" src="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F52ajvswmhak5nuu0oced.png" /&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt; &lt;a href="https://backstage.io/"&gt;Backstage&lt;/a&gt;是一个用于构建开发者门户的开放平台，是最受欢迎的 CNCF 项目之一。它允许开发人员从一个点管理云原生应用程序的众多服务和代码。&lt;/p&gt;&lt;p&gt; LitmusChaos 可以通过&lt;a href="https://github.com/litmuschaos/backstage-plugin"&gt;backstage-plugin&lt;/a&gt;与 Backstage 集成。在本教程中，我们将通过 minikube 构建本地 Kubernetes 集群并安装演示应用程序和 LitmusChaos。之后，我们将使用 LitmusChaos 进行混沌实验，并使用 Backstage 轻松查看 LitmusChaos 中的内容。 &lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;a href="https://dev.to/namkyu1999/a-beginners-guide-to-litmus-and-backstage-4p18-temp-slug-9264283?preview=1ab316fd623b5144a4102e4057db0744e32cd289a39a2ffc04e5bdaca4caf5f173faa3b2c345da6204b570a6cf4896c8000346f60706789e13f405d5#prerequisites"&gt;&lt;/a&gt;先决条件&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;&lt;a href="https://docs.docker.com/engine/install/"&gt;Docker&lt;/a&gt; 、 &lt;a href="https://minikube.sigs.k8s.io/docs/start/"&gt;minikube&lt;/a&gt; （如果你使用 k8s 集群，请跳过此部分）&lt;/li&gt;&lt;li&gt; &lt;a href="https://docs.litmuschaos.io/docs/getting-started/installation/#prerequisites"&gt;LitmusChaos 先决条件&lt;/a&gt;&lt;/li&gt;&lt;li&gt;&lt;a href="https://backstage.io/docs/getting-started/#prerequisites"&gt;后台先决条件&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;h2 class="wp-block-heading"&gt;&lt;a href="https://dev.to/namkyu1999/a-beginners-guide-to-litmus-and-backstage-4p18-temp-slug-9264283?preview=1ab316fd623b5144a4102e4057db0744e32cd289a39a2ffc04e5bdaca4caf5f173faa3b2c345da6204b570a6cf4896c8000346f60706789e13f405d5#what-does-our-deployment-consist-of"&gt;&lt;/a&gt;我们的部署包括什么？&lt;/h2&gt;&lt;p&gt;幸运的是，我们不必制作基于 k8s 的服务。 &lt;a href="https://github.com/GoogleCloudPlatform/microservices-demo"&gt;microservice-demo&lt;/a&gt;是我们可以使用的一个很棒的微服务。下图显示了我们将要构建的演示的架构。&lt;/p&gt;&lt;figure class="wp-block-image"&gt; &lt;a href="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F3bjyi3qw7btsfwrnf0wz.png"&gt;&lt;img alt="演示环境" src="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F3bjyi3qw7btsfwrnf0wz.png" /&gt;&lt;/a&gt; &lt;/figure&gt;&lt;h2 class="wp-block-heading"&gt;&lt;a href="https://dev.to/namkyu1999/a-beginners-guide-to-litmus-and-backstage-4p18-temp-slug-9264283?preview=1ab316fd623b5144a4102e4057db0744e32cd289a39a2ffc04e5bdaca4caf5f173faa3b2c345da6204b570a6cf4896c8000346f60706789e13f405d5#demo-environment"&gt;&lt;/a&gt;演示环境&lt;/h2&gt;&lt;p&gt;让我们安装本地 k8s 集群和演示应用程序，然后安装 LitmusChaos。 &lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;&lt;a href="https://dev.to/namkyu1999/a-beginners-guide-to-litmus-and-backstage-4p18-temp-slug-9264283?preview=1ab316fd623b5144a4102e4057db0744e32cd289a39a2ffc04e5bdaca4caf5f173faa3b2c345da6204b570a6cf4896c8000346f60706789e13f405d5#minikube-local-k8s-cluster"&gt;&lt;/a&gt; minikube（本地 k8s 集群）&lt;/h3&gt;&lt;p&gt;在本教程中，我们使用本地 k8s 集群 minikube。如果您尚未安装 minikube，请按照&lt;a href="https://minikube.sigs.k8s.io/docs/start/"&gt;本指南&lt;/a&gt;进行操作。一旦&lt;code&gt;minikube start&lt;/code&gt;执行，您就可以使用&lt;code&gt;kubectl&lt;/code&gt;命令访问本地 k8s 集群。&lt;/p&gt;&lt;figure class="wp-block-image"&gt; &lt;a href="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fxbfz9a2p9svsl0ggifjp.png"&gt;&lt;img alt="kubectl_get_node" src="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fxbfz9a2p9svsl0ggifjp.png" /&gt;&lt;/a&gt; &lt;/figure&gt;&lt;h3 class="wp-block-heading"&gt;&lt;a href="https://dev.to/namkyu1999/a-beginners-guide-to-litmus-and-backstage-4p18-temp-slug-9264283?preview=1ab316fd623b5144a4102e4057db0744e32cd289a39a2ffc04e5bdaca4caf5f173faa3b2c345da6204b570a6cf4896c8000346f60706789e13f405d5#online-boutique-microservicesdemo"&gt;&lt;/a&gt;在线精品店（微服务演示）&lt;/h3&gt;&lt;p&gt;安装 microservices-demo 更加简单。您所要做的就是执行以下代码。这是更&lt;a href="https://github.com/GoogleCloudPlatform/microservices-demo"&gt;详细的指南&lt;/a&gt;。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;// clone the repo git clone https://github.com/GoogleCloudPlatform/microservices-demo cd microservices-demo/ // move dir cd microservices-demo/ // install using a manifest file kubectl apply -f ./release/kubernetes-manifests.yaml&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;我们需要使用&lt;a href="https://minikube.sigs.k8s.io/docs/commands/service/"&gt;以下命令&lt;/a&gt;生成的 URL 来访问演示。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;minikube service frontend-external --url&lt;/code&gt;&lt;/pre&gt;&lt;figure class="wp-block-image"&gt; &lt;a href="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F79baavrjibu24mrevztq.png"&gt;&lt;img alt="minikube_service_ generated_1" src="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F79baavrjibu24mrevztq.png" /&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;现在我们可以通过&lt;code&gt;http://&amp;lt;&amp;lt;generated_url&amp;gt;&amp;gt;&lt;/code&gt; .GIF 访问该服务&lt;/p&gt;&lt;figure class="wp-block-image size-full"&gt;&lt;img alt="" src="https://i.giphy.com/media/v1.Y2lkPTc5MGI3NjExdzZ1cTh2YTEybGIzc3VtdmRzM2o3c3JyZTMzbW1ubWk2eTd6Y2k0YiZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/L8LfnvJPsdDToA5msX/giphy.gif" /&gt;&lt;/figure&gt;&lt;h3 class="wp-block-heading"&gt;&lt;a href="https://dev.to/namkyu1999/a-beginners-guide-to-litmus-and-backstage-4p18-temp-slug-9264283?preview=1ab316fd623b5144a4102e4057db0744e32cd289a39a2ffc04e5bdaca4caf5f173faa3b2c345da6204b570a6cf4896c8000346f60706789e13f405d5#litmuschaos"&gt;&lt;/a&gt;石蕊混沌&lt;/h3&gt;&lt;p&gt;让我们打开一个新 shell 并安装 LitmusChaos。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;// Add LitmusChaos Helm repo helm repo add litmuschaos https://litmuschaos.github.io/litmus-helm/ // Create the namespace kubectl create ns litmus // Install the chart helm install chaos litmuschaos/litmus --namespace=litmus --set portal.frontend.service.type=NodePort&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;和之前一样，我们需要创建一个 URL 来访问 litmuschaos（混沌中心）的前端。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;minikube service chaos-litmus-frontend-service -n litmus --url&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fc34o9u39m7578cs25qmw.png"&gt;&lt;/a&gt;&lt;br /&gt;以&lt;code&gt;admin / litmus&lt;/code&gt;登录&lt;/p&gt;&lt;figure class="wp-block-image"&gt;&lt;a href="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fghkkwhwz31qhqzxetpg1.png"&gt;&lt;img alt="litmus_login_page" src="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fghkkwhwz31qhqzxetpg1.png" /&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;第一次登录 LitmusChaos 时，您会看到一个弹出窗口，要求您启用这样的混沌基础设施&lt;/p&gt;&lt;figure class="wp-block-image"&gt;&lt;a href="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fapjyjjf9w24q4336izxy.png"&gt;&lt;img alt="石蕊弹出窗口" src="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fapjyjjf9w24q4336izxy.png" /&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;完成创建环境的所有步骤后，您将看到混沌基础设施已连接，如下所示。&lt;/p&gt;&lt;figure class="wp-block-image"&gt; &lt;a href="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fd2l0mup1w0h0sm48w3tu.png"&gt;&lt;img alt="混沌基础设施" src="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fd2l0mup1w0h0sm48w3tu.png" /&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;如果您对 LitmusChaos 的架构感到好奇，请查看&lt;a href="https://docs.litmuschaos.io/docs/architecture/architecture-summary"&gt;此文档&lt;/a&gt;。 &lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;a href="https://dev.to/namkyu1999/a-beginners-guide-to-litmus-and-backstage-4p18-temp-slug-9264283?preview=1ab316fd623b5144a4102e4057db0744e32cd289a39a2ffc04e5bdaca4caf5f173faa3b2c345da6204b570a6cf4896c8000346f60706789e13f405d5#injecting-chaos-using-litmuschaos"&gt;&lt;/a&gt;使用 LitmusChaos 注入混沌&lt;/h2&gt;&lt;p&gt;我们已经完成了执行混沌工程的所有准备工作。我们来讨论一个场景。假设您是一家在线精品服务的经理，并且您想要运行一个实验，看看当您删除其 pod 时&lt;code&gt;cartservice&lt;/code&gt;组件是否会恢复。要检查 pod 是否存在，请使用以下命令。 &lt;code&gt;kubectl get pods -n default | grep cartservice | grep Running | wc -l&lt;/code&gt; 。&lt;/p&gt;&lt;figure class="wp-block-image"&gt; &lt;a href="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F467s6egncebaudn78bf2.png"&gt;&lt;img alt="命令执行" src="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F467s6egncebaudn78bf2.png" /&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt; LitmusChaos 支持各种类型的探针。&lt;a href="https://docs.litmuschaos.io/docs/concepts/probes"&gt;在这里&lt;/a&gt;了解有关探针的更多信息，这里有一个很棒的&lt;a href="https://youtu.be/_nvpNdvqfvk?feature=shared"&gt;教程视频&lt;/a&gt;。 &lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;&lt;a href="https://dev.to/namkyu1999/a-beginners-guide-to-litmus-and-backstage-4p18-temp-slug-9264283?preview=1ab316fd623b5144a4102e4057db0744e32cd289a39a2ffc04e5bdaca4caf5f173faa3b2c345da6204b570a6cf4896c8000346f60706789e13f405d5#setup-probe"&gt;&lt;/a&gt;设置探针&lt;/h3&gt;&lt;p&gt;您可以在&lt;code&gt;Resilience Probes&lt;/code&gt;选项卡中创建新探针。在本教程中，我们将创建一个&lt;code&gt;Command Probe&lt;/code&gt; 。输入如下所示的值。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;// Command kubectl get pods -n default | grep cartservice | grep Running | wc -l // Type Int // Comparison Criteria &amp;gt; // Value 0&lt;/code&gt; &lt;/pre&gt;&lt;figure class="wp-block-image size-full"&gt;&lt;img alt="" class="wp-image-104897" height="250" src="https://www.cncf.io/wp-content/uploads/2024/04/giphy.gif" width="480" /&gt;&lt;/figure&gt;&lt;p&gt;另一件事，因为&lt;code&gt;cartservice&lt;/code&gt;部署没有标签，我们添加了如下标签&lt;/p&gt;&lt;pre class="wp-block-code"&gt;&lt;code class=""&gt;kubectl label deployment cartservice app=cartservice&lt;/code&gt; &lt;/pre&gt;&lt;h3 class="wp-block-heading"&gt;&lt;a href="https://dev.to/namkyu1999/a-beginners-guide-to-litmus-and-backstage-4p18-temp-slug-9264283?preview=1ab316fd623b5144a4102e4057db0744e32cd289a39a2ffc04e5bdaca4caf5f173faa3b2c345da6204b570a6cf4896c8000346f60706789e13f405d5#lets-inject-chaos"&gt;&lt;/a&gt;让我们注入混乱&lt;/h3&gt;&lt;p&gt;我们所要做的就是创建一个混沌实验。正如我们之前讨论的，我们删除&lt;code&gt;cartservice&lt;/code&gt; pod 并检查该 pod 是否重新生成。下面是&lt;a href="https://docs.litmuschaos.io/docs/user-guides/schedule-experiment"&gt;详细教程&lt;/a&gt;和 gif。我只想指出一些重要的特征。 &lt;/p&gt;&lt;figure class="wp-block-image size-full"&gt;&lt;img alt="" src="https://i.giphy.com/media/v1.Y2lkPTc5MGI3NjExbTl0NXZraDhmMTR5YzMwaHB5bGtsM25tdWU2dWFyczlzdDFkM3hiMCZlcD12MV9pbnRlcm5hbF9naWZfYnlfaWQmY3Q9Zw/34mlMp0MFwtowZAPoA/giphy.gif" /&gt;&lt;/figure&gt;&lt;p&gt;首先，我们在本次实验中选择了&lt;code&gt;pod-delete&lt;/code&gt;混沌故障。 &lt;/p&gt;&lt;figure class="wp-block-image size-full"&gt;&lt;img alt="图像" src="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F29y2k3dvffis209pewul.png" /&gt;&lt;/figure&gt;&lt;p&gt;其次，我们提供有关目标应用程序的信息，如下所示。 &lt;/p&gt;&lt;figure class="wp-block-image size-full"&gt;&lt;img alt="图像" class="wp-image-104899" height="364" src="https://www.cncf.io/wp-content/uploads/2024/04/image-1.png" width="1360" /&gt;&lt;/figure&gt;&lt;p&gt;最后，我们使用之前制作的探针。 &lt;/p&gt;&lt;figure class="wp-block-image size-full"&gt;&lt;img alt="图像" class="wp-image-104900" height="302" src="https://www.cncf.io/wp-content/uploads/2024/04/image-2.png" width="1364" /&gt;&lt;/figure&gt;&lt;p&gt;当您设置并运行混沌实验时，混沌会被注入到目标应用程序中，并且探测器会检查应用程序是否具有弹性。如果是，那么您现在已经掌握了混沌工程。恭喜你🎉&lt;/p&gt;&lt;figure class="wp-block-image"&gt; &lt;a href="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fsk3ne4rdxjeejtt68mni.png"&gt;&lt;img alt="成功" src="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fsk3ne4rdxjeejtt68mni.png" /&gt;&lt;/a&gt; &lt;/figure&gt;&lt;h2 class="wp-block-heading"&gt;&lt;a href="https://dev.to/namkyu1999/a-beginners-guide-to-litmus-and-backstage-4p18-temp-slug-9264283?preview=1ab316fd623b5144a4102e4057db0744e32cd289a39a2ffc04e5bdaca4caf5f173faa3b2c345da6204b570a6cf4896c8000346f60706789e13f405d5#manage-litmuschaos-stuff-in-backstage"&gt;&lt;/a&gt;在后台管理 LitmusChaos 内容&lt;/h2&gt;&lt;p&gt;您可以按照本&lt;a href="https://backstage.io/docs/getting-started/#create-your-backstage-app"&gt;入门指南&lt;/a&gt;开始构建 Backstage 应用程序并使用yarn dev 运行它。&lt;/p&gt;&lt;figure class="wp-block-image"&gt; &lt;a href="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fo481g3qmrhlxjycy8pr5.png"&gt;&lt;img alt="后台主程序" src="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fo481g3qmrhlxjycy8pr5.png" /&gt;&lt;/a&gt; &lt;/figure&gt;&lt;h3 class="wp-block-heading"&gt;&lt;a href="https://dev.to/namkyu1999/a-beginners-guide-to-litmus-and-backstage-4p18-temp-slug-9264283?preview=1ab316fd623b5144a4102e4057db0744e32cd289a39a2ffc04e5bdaca4caf5f173faa3b2c345da6204b570a6cf4896c8000346f60706789e13f405d5#litmuschaos-plugin-for-backstage"&gt;&lt;/a&gt;用于 Backstage 的 LitmusChaos 插件&lt;/h3&gt;&lt;p&gt;让我们向 Backstage 添加一个 LitmusChaos 插件&lt;/p&gt;&lt;figure class="wp-block-image size-full"&gt;&lt;img alt="" class="wp-image-104901" height="229" src="https://www.cncf.io/wp-content/uploads/2024/04/giphy-2.gif" width="480" /&gt;&lt;/figure&gt;&lt;ul&gt;&lt;li&gt;在&lt;code&gt;./packages/app&lt;/code&gt;项目中添加插件。&lt;/li&gt;&lt;/ul&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;yarn add backstage-plugin-litmus&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;通过 LitmusChaos UI 获取 LitmusChaos API 令牌&lt;ol&gt;&lt;li&gt;单击侧栏中的“设置”。&lt;/li&gt;&lt;li&gt;单击“API 令牌”部分中的“+ 新令牌”按钮。 &lt;img alt="创建令牌" height="408" src="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fl04ndjz91tjklz4lqieg.png" width="800" /&gt;&lt;/li&gt;&lt;li&gt;输入您的信息并点击“确认”。&lt;/li&gt;&lt;li&gt;获取“VALUE”列中的令牌。&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;li&gt;在&lt;code&gt;app-config.yaml&lt;/code&gt;文件根目录中，添加 litmus 代理和信息，如下所示&lt;/li&gt;&lt;/ul&gt;&lt;pre class="wp-block-code"&gt;&lt;code class=""&gt; proxy: &amp;#39;/litmus&amp;#39;: target: &amp;#39;your-own-litmus-ui-url&amp;#39; changeOrigin: true headers: Authorization: &amp;#39;Bearer ${LITMUS_AUTH_TOKEN}&amp;#39; litmus: baseUrl: &amp;#39;your-own-litmus-ui-url&amp;#39; apiToken: ${LITMUS_AUTH_TOKEN}&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;将您的身份验证密钥添加到环境变量中&lt;/li&gt;&lt;/ul&gt;&lt;pre class="wp-block-code"&gt;&lt;code class=""&gt; export LITMUS_AUTH_TOKEN=&amp;quot;your-own-token&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;要获取项目 ID，请直接从门户 URL 中的“/project/”之后复制它&lt;img alt="项目ID" height="334" src="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fzdv8f1hkyyl4gt7fgrh4.png" width="800" /&gt;&lt;/li&gt;&lt;li&gt;将新组件附加到&lt;code&gt;./examples/entities.yaml&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;# ... --- apiVersion: backstage.io/v1alpha1 kind: Component metadata: name: backstage-litmus-demo description: An example of a Backstage application. ## append here annotations: litmuschaos.io/project-id: your-own-project-id ## spec: type: service owner: john@example.com lifecycle: experimental&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;要启用前端，我们需要编辑&lt;code&gt;./packages/app/src/components/catalog/EntityPage.tsx&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;&lt;pre class="wp-block-code"&gt;&lt;code class=""&gt; // packages/app/src/components/catalog/EntityPage.tsx import { isLitmusAvailable, EntityLitmusCard, EntityLitmusContent } from &amp;#39;backstage-plugin-litmus&amp;#39; // ... const overviewContent = ( &amp;lt;Grid container spacing={6} alignItems=&amp;quot;stretch&amp;quot;&amp;gt; // ... &amp;lt;EntitySwitch&amp;gt; &amp;lt;EntitySwitch.Case if={isLitmusAvailable}&amp;gt; &amp;lt;Grid item md={4} xs={12}&amp;gt; &amp;lt;EntityLitmusCard /&amp;gt; &amp;lt;/Grid&amp;gt; &amp;lt;/EntitySwitch.Case&amp;gt; &amp;lt;/EntitySwitch&amp;gt; // ... &amp;lt;/Grid&amp;gt; ) // ... const serviceEntityPage = ( &amp;lt;EntityLayout&amp;gt; // ... &amp;lt;EntityLayout.Route path=&amp;quot;/litmus&amp;quot; title=&amp;quot;Litmus&amp;quot;&amp;gt; &amp;lt;EntityLitmusContent /&amp;gt; &amp;lt;/EntityLayout.Route&amp;gt; // ... &amp;lt;/EntityLayout&amp;gt; )&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;再次&lt;code&gt;yarn dev&lt;/code&gt; ，现在您可以在一个地方（后台）管理有关LitmusChaos 的所有内容。&lt;a href="https://docs.litmuschaos.io/docs/integrations/backstage#entitylitmuscard"&gt;概述选项卡&lt;/a&gt;提供了 LitmusChaos 中一些重要指标的概览视图。&lt;/p&gt;&lt;figure class="wp-block-image"&gt; &lt;a href="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F6uywsu7of0wo5xjmlro7.png"&gt;&lt;img alt="概述" src="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F6uywsu7of0wo5xjmlro7.png" /&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;在&lt;a href="https://docs.litmuschaos.io/docs/integrations/backstage#entitylitmuscontent"&gt;LitmusChaos 选项卡&lt;/a&gt;中，您可以在一个页面上查看有关 LitmusChaos 的所有信息，包括混沌实验、混沌基础设施等。&lt;/p&gt;&lt;figure class="wp-block-image"&gt; &lt;a href="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fb43x6wx3cwhf1mbvpc3d.png"&gt;&lt;img alt="石蕊试片" src="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fb43x6wx3cwhf1mbvpc3d.png" /&gt;&lt;/a&gt;&lt;/figure&gt;&lt;p&gt;我想强调的是，我们可以重新运行现有的混沌实验。我们所要做的就是点击“运行实验”按钮🚀&lt;/p&gt;&lt;figure class="wp-block-image"&gt; &lt;a href="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fqjwwemtiu98uyhsevg37.png"&gt;&lt;img alt="运行实验按钮" src="https://media.dev.to/cdn-cgi/image/width=800%2Cheight=%2Cfit=scale-down%2Cgravity=auto%2Cformat=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fqjwwemtiu98uyhsevg37.png" /&gt;&lt;/a&gt; &lt;/figure&gt;&lt;h2 class="wp-block-heading"&gt;&lt;a href="https://dev.to/namkyu1999/a-beginners-guide-to-litmus-and-backstage-4p18-temp-slug-9264283?preview=1ab316fd623b5144a4102e4057db0744e32cd289a39a2ffc04e5bdaca4caf5f173faa3b2c345da6204b570a6cf4896c8000346f60706789e13f405d5#summary"&gt;&lt;/a&gt;概括&lt;/h2&gt;&lt;p&gt;在本教程中，我们探索了如何利用 LitmusChaos 和 Backstage 集成将混乱注入 Kubernetes 环境并对其进行有效管理。&lt;/p&gt;&lt;p&gt; LitmusChaos 和 Backstage 的集成提供了一个统一的平台来管理混沌工程的各个方面，从注入混沌到监控影响和分析结果。&lt;/p&gt;&lt;p&gt;如果您对 LitmusChaos 感兴趣，请加入社区！您可以加入&lt;a href="https://github.com/litmuschaos/litmus"&gt;GitHub&lt;/a&gt;和&lt;a href="https://kubernetes.slack.com/?redir=%2Farchives%2FCNXNB0ZTN"&gt;Slack&lt;/a&gt;上的 LitmusChaos 社区。&lt;/p&gt;&lt;p&gt;感谢您的阅读🙏&lt;/p&gt;&lt;p&gt;南久公园&lt;br /&gt;LitmusChaos 的维护者&lt;br /&gt;&lt;a href="https://www.linkedin.com/in/namkyupark1999/?locale=en_US"&gt;领英&lt;/a&gt;| &lt;a href="https://github.com/namkyu1999"&gt;GitHub&lt;/a&gt; &lt;/p&gt;&lt;p&gt;&lt;a href="https://dev.to/t/chaosengineering"&gt;&lt;/a&gt;&lt;/p&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;</description><pubDate>Sun, 31 Mar 2024 16:00:00 GMT</pubDate><guid isPermaLink="true">https://www.cncf.io/blog/2024/04/01/elevating-system-resilience-leveraging-litmuschaos-and-backstage-integration/</guid></item><item><title>从 Kyverno 策略生成 Kubernetes ValidatingAdmissionPolicies</title><link>https://www.cncf.io/blog/2024/03/29/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/</link><description>&lt;p&gt;&lt;em&gt;项目帖子最初由 Mariam Fahmy 发布在&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;Kyverno 的博客&lt;/a&gt;上&lt;/em&gt;&lt;/p&gt;&lt;p&gt;在&lt;a href="https://kyverno.io/blog/2023/11/13/using-cel-expressions-in-kyverno-policies/"&gt;上一篇博文&lt;/a&gt;中，我们讨论了在 Kyverno 策略中编写&lt;a href="https://github.com/google/cel-spec"&gt;通用表达式语言 (CEL)&lt;/a&gt;表达式以进行资源验证。 CEL 最初被引入 Kubernetes，用于 CustomResourceDefinitions 的验证规则，然后在 1.26 中被 Kubernetes ValidatingAdmissionPolicies 使用。&lt;/p&gt;&lt;p&gt; ValidatingAdmissionPolicies 提供了一种声明式的进程内替代方案来验证准入 Webhook。&lt;/p&gt;&lt;p&gt; ValidatingAdmissionPolicies 使用通用表达式语言 (CEL) 来声明策略的验证规则。验证准入策略是高度可配置的，使策略作者能够定义可以根据集群管理员的需要进行参数化和限定资源范围的策略。&lt;/p&gt;&lt;p&gt;这篇文章将向您展示如何从 Kyverno 策略生成 Kubernetes ValidatingAdmissionPolicies 及其绑定。&lt;/p&gt;&lt;h2 class="wp-block-heading" id="prerequisite"&gt;先决条件&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/#prerequisite"&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;生成 Kubernetes ValidatingAdmissionPolicies 需要以下内容：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;具有 Kubernetes 1.26 或更高版本的集群。&lt;/li&gt;&lt;li&gt;启用&lt;code&gt;ValidatingAdmissionPolicy&lt;/code&gt;&lt;a href="https://kubernetes.io/docs/reference/command-line-tools-reference/feature-gates/"&gt;功能门&lt;/a&gt;。&lt;/li&gt;&lt;li&gt;为v1.28和v1.29启用&lt;code&gt;admissionregistration.k8s.io/v1beta1&lt;/code&gt; API。或者 为 v1.26 和 v1.27 启用&lt;code&gt;admissionregistration.k8s.io/v1alpha1&lt;/code&gt; API。&lt;/li&gt;&lt;li&gt;在 Kyverno 准入控制器中设置&lt;code&gt;--generateValidatingAdmissionPolicy&lt;/code&gt;标志。&lt;/li&gt;&lt;li&gt;授予准入控制器服务帐户生成 ValidatingAdmissionPolicies 及其绑定所需的权限。&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;在这篇文章中，我们将使用 Kubernetes 1.29 的测试版。&lt;/p&gt;&lt;h2 class="wp-block-heading" id="installation--setup"&gt;安装与设置&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/#installation--setup"&gt;&lt;/a&gt;&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;创建本地集群&lt;/li&gt;&lt;/ol&gt;&lt;pre class="wp-block-code"&gt;&lt;code class=""&gt;kind create cluster --image &amp;quot;kindest/node:v1.28.0&amp;quot; --config - &amp;lt;&amp;lt;EOF kind: Cluster apiVersion: kind.x-k8s.io/v1alpha4 featureGates: ValidatingAdmissionPolicy: true runtimeConfig: admissionregistration.k8s.io/v1beta1: true admissionregistration.k8s.io/v1alpha1: true nodes: - role: control-plane - role: worker EOF&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;巴什&lt;/p&gt;&lt;ol start="2"&gt;&lt;li&gt;添加 Kyverno Helm 存储库。&lt;/li&gt;&lt;/ol&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;helm repo add kyverno https://kyverno.github.io/kyverno/ helm repo update&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;巴什&lt;/p&gt;&lt;ol start="3"&gt;&lt;li&gt;创建一个新文件来覆盖图表中的值。&lt;/li&gt;&lt;/ol&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;cat &amp;lt;&amp;lt; EOF &amp;gt; new-values.yaml features: generateValidatingAdmissionPolicy: enabled: true admissionController: rbac: clusterRole: extraResources: - apiGroups: - admissionregistration.k8s.io resources: - validatingadmissionpolicies - validatingadmissionpolicybindings verbs: - create - update - delete - list EOF&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;巴什&lt;/p&gt;&lt;ol start="4"&gt;&lt;li&gt;部署 Kyverno&lt;/li&gt;&lt;/ol&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;helm install kyverno kyverno/kyverno -n kyverno --create-namespace --version v3.1.4 --values new-values.yaml&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;巴什&lt;/p&gt;&lt;p&gt;我们现在准备从 Kyverno 策略生成 Kubernetes ValidatingAdmissionPolicies。&lt;/p&gt;&lt;h2 class="wp-block-heading" id="generating-kubernetes-validatingadmissionpolicies"&gt;生成 Kubernetes ValidatingAdmissionPolicies &lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/#generating-kubernetes-validatingadmissionpolicies"&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;在本节中，我们将创建一个 Kyverno 策略，确保没有主机路径卷用于部署，然后我们将查看生成的 ValidatingAdmissionPolicy 及其绑定。最后，我们将创建一个违反策略的 Deployment。&lt;/p&gt;&lt;p&gt;让我们从创建 Kyverno 策略开始。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;kubectl apply -f - &amp;lt;&amp;lt;EOF apiVersion: kyverno.io/v1 kind: ClusterPolicy metadata: name: disallow-host-path spec: validationFailureAction: Enforce background: false rules: - name: host-path match: any: - resources: kinds: - Deployment validate: cel: expressions: - expression: &amp;quot;!has(object.spec.template.spec.volumes) || object.spec.template.spec.volumes.all(volume, !has(volume.hostPath))&amp;quot; message: &amp;quot;HostPath volumes are forbidden. The field spec.template.spec.volumes[*].hostPath must be unset.&amp;quot; EOF&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;巴什&lt;/p&gt;&lt;p&gt;您可以从 Kyverno 策略状态检查是否生成了 ValidatingAdmissionPolicy。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;$ kubectl get cpol disallow-host-path -o jsonpath=&amp;#39;{.status}&amp;#39; { &amp;quot;autogen&amp;quot;:{ }, &amp;quot;conditions&amp;quot;:[ { &amp;quot;lastTransitionTime&amp;quot;:&amp;quot;2023-09-12T11:42:13Z&amp;quot;, &amp;quot;message&amp;quot;:&amp;quot;Ready&amp;quot;, &amp;quot;reason&amp;quot;:&amp;quot;Succeeded&amp;quot;, &amp;quot;status&amp;quot;:&amp;quot;True&amp;quot;, &amp;quot;type&amp;quot;:&amp;quot;Ready&amp;quot; } ], &amp;quot;ready&amp;quot;:true, &amp;quot;rulecount&amp;quot;:{ &amp;quot;generate&amp;quot;:0, &amp;quot;mutate&amp;quot;:0, &amp;quot;validate&amp;quot;:1, &amp;quot;verifyimages&amp;quot;:0 }, &amp;quot;validatingadmissionpolicy&amp;quot;:{ &amp;quot;generated&amp;quot;:true, &amp;quot;message&amp;quot;:&amp;quot;&amp;quot; } }&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;巴什&lt;/p&gt;&lt;p&gt;让我们尝试获取 ValidatingAdmissionPolicy 及其绑定。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;$ kubectl get validatingadmissionpolicy NAME VALIDATIONS PARAMKIND AGE disallow-host-path 1 &amp;lt;unset&amp;gt; 8m12s $ kubectl get validatingadmissionpolicybindings NAME POLICYNAME PARAMREF AGE disallow-host-path-binding disallow-host-path &amp;lt;unset&amp;gt; 8m30s&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;巴什&lt;/p&gt;&lt;p&gt;您可能会注意到，ValidatingAdmissionPolicy 和 ValidatingAdmissionPolicyBinding 与它们源自的 Kyverno 策略共享相同的名称，并且绑定具有“-binding”后缀。&lt;/p&gt;&lt;p&gt;让我们详细了解一下 ValidatingAdmissionPolicy 及其绑定。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;$ kubectl get validatingadmissionpolicy disallow-host-path -o yaml apiVersion: admissionregistration.k8s.io/v1beta1 kind: ValidatingAdmissionPolicy metadata: creationTimestamp: &amp;quot;2023-09-12T11:42:13Z&amp;quot; generation: 1 labels: app.kubernetes.io/managed-by: kyverno name: disallow-host-path ownerReferences: - apiVersion: kyverno.io/v1 kind: ClusterPolicy name: disallow-host-path uid: e540d96b-c683-4380-a84f-13411384241a resourceVersion: &amp;quot;11294&amp;quot; uid: 9f3e0161-d010-4a6f-bd28-bf9c87151795 spec: failurePolicy: Fail matchConstraints: matchPolicy: Equivalent namespaceSelector: {} objectSelector: {} resourceRules: - apiGroups: - apps apiVersions: - v1 operations: - CREATE - UPDATE resources: - deployments scope: &amp;#39;*&amp;#39; validations: - expression: &amp;#39;!has(object.spec.template.spec.volumes) || object.spec.template.spec.volumes.all(volume, !has(volume.hostPath))&amp;#39; message: HostPath volumes are forbidden. The field spec.template.spec.volumes[*].hostPath must be unset. variables: null status: observedGeneration: 1 typeChecking: {}&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;巴什&lt;/p&gt;&lt;pre class="wp-block-code"&gt;&lt;code class=""&gt;$ kubectl get validatingadmissionpolicybindings disallow-host-path-binding -o yaml apiVersion: admissionregistration.k8s.io/v1beta1 kind: ValidatingAdmissionPolicyBinding metadata: creationTimestamp: &amp;quot;2023-09-12T11:42:13Z&amp;quot; generation: 1 labels: app.kubernetes.io/managed-by: kyverno name: disallow-host-path-binding ownerReferences: - apiVersion: kyverno.io/v1 kind: ClusterPolicy name: disallow-host-path uid: e540d96b-c683-4380-a84f-13411384241a resourceVersion: &amp;quot;11292&amp;quot; uid: 2fec35c3-8a8c-42a7-8a02-a75e8882a01e spec: policyName: disallow-host-path validationActions: - Deny&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;巴什&lt;/p&gt;&lt;p&gt;现在，让我们尝试部署一个使用 hostPath 的应用程序：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;kubectl apply -f - &amp;lt;&amp;lt;EOF apiVersion: apps/v1 kind: Deployment metadata: name: nginx spec: replicas: 2 selector: matchLabels: app: nginx template: metadata: labels: app: nginx spec: containers: - name: nginx-server image: nginx volumeMounts: - name: udev mountPath: /data volumes: - name: udev hostPath: path: /etc/udev EOF&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;巴什&lt;/p&gt;&lt;p&gt;正如预期的那样，部署创建被 API 服务器拒绝，而不是被 Kyverno 准入控制器拒绝。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;The deployments &amp;quot;nginx&amp;quot; is invalid: ValidatingAdmissionPolicy &amp;#39;disallow-host-path&amp;#39; with binding &amp;#39;disallow-host-path-binding&amp;#39; denied request: HostPath volumes are forbidden. The field spec.template.spec.volumes[*].hostPath must be unset.&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;巴什&lt;/p&gt;&lt;p&gt;如果 ValidatingAdmissionPolicy 或绑定由于某种原因被删除/更新，则控制器负责恢复它。&lt;/p&gt;&lt;p&gt;让我们尝试删除 ValidatingAdmissionPolicy。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;$ kubectl delete validatingadmissionpolicy disallow-host-path validatingadmissionpolicy.admissionregistration.k8s.io &amp;quot;disallow-host-path&amp;quot; deleted $ kubectl get validatingadmissionpolicy NAME VALIDATIONS PARAMKIND AGE disallow-host-path 1 &amp;lt;unset&amp;gt; 11s&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;巴什&lt;/p&gt;&lt;p&gt;此外，您可以更新Kyverno策略，控制器将相应地重新生成ValidatingAdmissionPolicy。例如，您也可以更改 Kyverno 策略以匹配有状态集。&lt;/p&gt;&lt;p&gt;补丁.yaml：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;spec: rules: - name: host-path match: any: - resources: kinds: - Deployment - StatefulSet validate: cel: expressions: - expression: &amp;quot;!has(object.spec.template.spec.volumes) || object.spec.template.spec.volumes.all(volume, !has(volume.hostPath))&amp;quot; message: &amp;quot;HostPath volumes are forbidden. The field spec.template.spec.volumes[*].hostPath must be unset.&amp;quot;&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt; YAML&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;kubectl patch cpol disallow-host-path --type merge --patch-file patch.yaml&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt;巴什&lt;/p&gt;&lt;p&gt;ValidatingAdmissionPolicy 也将更新以匹配 StatefulSet。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;apiVersion: admissionregistration.k8s.io/v1beta1 kind: ValidatingAdmissionPolicy metadata: creationTimestamp: &amp;quot;2023-09-12T12:54:48Z&amp;quot; generation: 2 labels: app.kubernetes.io/managed-by: kyverno name: disallow-host-path ownerReferences: - apiVersion: kyverno.io/v1 kind: ClusterPolicy name: disallow-host-path uid: e540d96b-c683-4380-a84f-13411384241a resourceVersion: &amp;quot;29208&amp;quot; uid: 9325e2b7-9131-4ff4-9e56-244129cb625e spec: failurePolicy: Fail matchConstraints: matchPolicy: Equivalent namespaceSelector: {} objectSelector: {} resourceRules: - apiGroups: - apps apiVersions: - v1 operations: - CREATE - UPDATE resources: - deployments - statefulsets scope: &amp;#39;*&amp;#39; validations: - expression: &amp;#39;!has(object.spec.template.spec.volumes) || object.spec.template.spec.volumes.all(volume, !has(volume.hostPath))&amp;#39; message: HostPath volumes are forbidden. The field spec.template.spec.volumes[*].hostPath must be unset. variables: null status: observedGeneration: 2 typeChecking: {}&lt;/code&gt; &lt;/pre&gt;&lt;p&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/"&gt;&lt;/a&gt;&lt;/p&gt;&lt;p&gt; YAML&lt;/p&gt;&lt;h2 class="wp-block-heading" id="conclusion"&gt;结论&lt;a href="https://kyverno.io/blog/2024/02/26/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/#conclusion"&gt;&lt;/a&gt;&lt;/h2&gt;&lt;p&gt;在本博客中，我们讨论了如何从 Kyverno 策略生成 Kubernetes ValidatingAdmissionPolicies。您可以在 Kyverno 策略中使用 CEL 表达式通过 Kyverno 引擎或 API 服务器验证资源。在下一篇博客中，我们将讨论如何为 ValidatingAdmissionPolicies 生成后台扫描报告。 &lt;/p&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;</description><pubDate>Thu, 28 Mar 2024 16:00:00 GMT</pubDate><guid isPermaLink="true">https://www.cncf.io/blog/2024/03/29/generating-kubernetes-validatingadmissionpolicies-from-kyverno-policies/</guid></item><item><title>Kelsey Hightower 和 Alex Saroyan 的 2024 年云计算趋势</title><link>https://www.cncf.io/blog/2024/03/28/the-2024-trends-on-cloud-computing-by-kelsey-hightower-and-alex-saroyan/</link><description>&lt;p&gt;&lt;em&gt;会员帖子最初发布在&lt;a href="https://www.netris.io/the-2024-trends-on-cloud-computing-by-kelsey-hightower-and-alex-saroyan/"&gt;Netris 的博客&lt;/a&gt;上&lt;/em&gt;&lt;/p&gt;&lt;p&gt;公共云基本上变得相同。大多数公司为&lt;strong&gt;云基础设施&lt;/strong&gt;支付的费用远远高于应有的费用。简而言之，这些陈述总结了&lt;strong&gt;&lt;a href="https://www.netris.io/recap-of-tech-trends-in-2023-and-predictions-for-2024-virtual-roundtable/"&gt;Kelsey Hightower 最近主持的 Netris 圆桌讨论&lt;/a&gt;&lt;/strong&gt;中有关云计算现状的关键要点。&lt;/p&gt;&lt;p&gt;但简洁的总结很难准确反映 Hightower 和其他与会者在活动期间分享的见解 - 因此，为了那些无法现场参加的人，我们想解开我们探索的云计算趋势以及他们对云的未来发展提出了重要观点。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;趋势一：公有云平台差异缩小&lt;/h3&gt;&lt;p&gt;在讨论初期，Hightower 发表了一个听起来可能很直白，但却很难反驳的声明：“截至 2024 年，大多数云提供商的核心产品看起来都是一样的。”&lt;/p&gt;&lt;p&gt;他指的是这样一个事实：所有主要的公共云平台——&lt;strong&gt;亚马逊网络服务、微软Azure和谷歌云平台&lt;/strong&gt;——现在都提供或多或少相同的核心服务集。诚然，他们实施这些服务的方式存在差异。例如， &lt;strong&gt;Amazon EC2&lt;/strong&gt;提供的特定云服务器实例配置与&lt;strong&gt;Azure 虚拟机&lt;/strong&gt;上的配置不同。但抛开细微的差异不谈，大型公共云竞争对手如今都提供几乎相同的服务。&lt;/p&gt;&lt;p&gt;活动参与者一致认为，公共云之间界限的模糊并不是一件坏事。相反，这意味着企业可以不再专注于选择适合自己需求的公有云，同时使用多个云将成为未来的常态&lt;/p&gt;&lt;p&gt;然而，Hightower 和其他人指出的一个症结是，每个公共云供应商提供的本机工具之间仍然存在重要差异。例如，成为 AWS IAM 专家并不一定意味着您有资格在 Azure 上管理 IAM，因为每个云的 IAM 框架涉及不同的概念和工具。&lt;/p&gt;&lt;p&gt;因此，对于想要跨云工作的无缝体验的团队来说，寻找简化工具集和管理流程的方法非常重要，尽管云本身现在都做几乎相同的事情。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;趋势 2：本地云和公有云的界限已经模糊&lt;/h3&gt;&lt;p&gt;Hightower 又做出了一项大胆的声明，他宣称，到 2024 年，本地环境和公共云环境之间的差异基本上不再重要。&lt;/p&gt;&lt;p&gt;他表示，如今企业应该“&lt;strong&gt;减少对云计算和本地部署的关注，而更多地关注这两个世界如何融合&lt;/strong&gt;。”&lt;/p&gt;&lt;p&gt;这是一个大胆的声明，因为在很多方面，本地云和公共云之间确实仍然存在重要差异。例如，与在云中运行的服务器相比，裸机本地服务器为您提供了更多的控制权。从基础设施管理和安全性等角度来看，每种类型的环境也有很大不同。&lt;/p&gt;&lt;p&gt;但 Hightower 并不意味着本地云和公共云实际上已经变得相同。相反，他指的是这样一个事实：现代工具（例如&lt;strong&gt;Netris&lt;/strong&gt; ，它将&lt;strong&gt;公共云网络管理的简单性带入任何环境&lt;/strong&gt;，包括本地）已经使您的工作负载实现非常相似的管理体验，无论它们运行本地或云端。&lt;/p&gt;&lt;p&gt;为了让大家明白这一点，Hightower 还指出，“我讨厌混合云这个词，因为它只会造成混乱。没有任何混合体。只有数据中心。”&lt;/p&gt;&lt;p&gt;这听起来可能有点奇怪，因为混合云（将公共云服务与私有基础设施结合在一起）和其他类型的云平台之间存在架构差异。但 Hightower 并不是说​​混合云实际上不存在。他的意思是，使用现代工具，管理混合云环境与管理本地或公共云环境实际上没有任何不同。&lt;/p&gt;&lt;p&gt;底线：组织应该少担心谁拥有托管给定工作负载的数据中心，而更多地关注确保他们能够有效管理该工作负载。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;趋势三：云成本管理的大胆想法&lt;/h3&gt;&lt;p&gt;随着越来越多的企业寻找控制云支出的方法，FinOps 意味着云成本优化的实践，多年来一直是一个热门话题。优化 AWS 成本、GCP 成本和其他云支出长期以来一直是一个优先事项。&lt;/p&gt;&lt;p&gt;通常，FinOps 建议归结为一些策略，例如选择能够在成本和性能之间实现最佳权衡的云服务器实例。但 Netris 圆桌会议上的人们就如何减少云中的负担提出了一些其他更大胆的想法。&lt;/p&gt;&lt;p&gt; Hightower 走得更远，他建议数据出口（企业为将数据移出云环境而支付的费用）应该免费。 “出口正在杀死公司，”他说，并补充说，想要吸引更多客户的云提供商应该取消出口费用。&lt;/p&gt;&lt;p&gt;我们并不是说您应该要求云提供商为您提供免费出口。他们可能会说不，因为到目前为止，出口收费仍然是标准且普遍存在的。但我们喜欢 Hightower 雄心勃勃的想法，即通过消除云客户早已接受的一些费用，使云从根本上更具成本效益。&lt;/p&gt;&lt;p&gt; Hightower 还指出，在许多情况下，具有可预测工作负载的企业最好通过将其保留在本地来获得最佳服务，这一指导意见违背了“立即将所有内容迁移到云端！”的原则。过去十年或更长时间主导 IT 行业的建议。他指出，虽然云在您不知道需要多少容量的情况下很有用，但“大多数企业确实知道他们必须支持多少客户以及他们需要什么”——因此，他们无法从云的内置可扩展性中获得太多好处。&lt;/p&gt;&lt;p&gt;我们还将提到，这也是当今使用一致工具管理任何环境的能力如此重要的另一个原因。当您的工具集和管理流程在所有环境中都相同时，您可以将工作负载放置在最有意义的地方，而无需为您支持的每个环境投资不同的管理策略。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;趋势4：VPC正在成为常态&lt;/h3&gt;&lt;p&gt;尽管所有讨论都涉及云平台和架构之间的模糊界限，但圆桌会议与会者确实同意，在云环境中仍然存在一种非常重要的独特环境类型：虚拟私有云或 VPC。&lt;/p&gt;&lt;p&gt; &lt;strong&gt;VPC 是云中的网络结构&lt;/strong&gt;，可创建隔离环境，换句话说，就是虚拟私有云。每个云用户可以创建至少一个VPC。&lt;/p&gt;&lt;p&gt;除了隔离之外，VPC 还包括设计和管理网络所需的基本结构（例如 DHCP、IP 子网、路由、NAT、负载均衡器、访问组和网络访问控制）。因此，当工程师谈论 VPC 时，他们通常不仅指隔离技术，还指 VPC 提供的一套基本网络构造。&lt;/p&gt;&lt;p&gt; VPC 已在主要公共云平台上存在多年，但 Hightower 认为现在是本地、边缘和裸机环境也利用 VPC 的时候了。 “&lt;strong&gt;让世界规范 VPC 的概念非常重要，&lt;/strong&gt;这样我们就可以对网络进行抽象 - 类似于容器对计算的作用，”他说。换句话说，Hightower 认为更多的企业应该利用 VPC 来简化和标准化其公共云和私有云工作负载的网络。&lt;/p&gt;&lt;p&gt; Netris 首席执行官兼联合创始人 Alex Saroyan 补充说，借助 Netris 等工具，管理 VPC 网络变得比以往更加容易。 “我们为他们提供了与云非常相似的 API 和用户体验，而在后端我们会自动处理详细的网络配置，”他解释道。&lt;/p&gt;&lt;p&gt; Hightower 表示同意，并指出 Netris 等工具可用于将公共云中的 VPC 网络与私有云和其他环境中的 VPC 网络统一起来。 &lt;strong&gt;Netris 自动处理大部分复杂的网络工程&lt;/strong&gt;。&lt;/p&gt;&lt;p&gt;简而言之，我们期望看到越来越多的组织采用 VPC 作为其私有和公共云战略的一部分。我们还希望他们能够利用 Netris 等工具在其环境的各个方面提供一致的网络管理体验。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;结论：重新思考云战略&lt;/h3&gt;&lt;p&gt;底线是：多年来一直处于云计算中心的许多争论感觉越来越无关紧要。如今，企业需要回答的最重要问题不再是选择哪个公共云平台或将哪些工作负载保留在本地。现代云工具和网络抽象使各种环境更加相似，这意味着将工作负载从一个环境转移到另一个环境已更多地成为业务驱动的决策，而不再是工程麻烦。&lt;/p&gt;&lt;p&gt;因此， &lt;strong&gt;2024 年云战略的首要任务是确保企业能够有效管理其工作负载，无论其托管在何处&lt;/strong&gt;。团队不应再担心他们在云架构或环境上贴上哪些标签，而应该更多地担心他们是否尽可能高效、可靠地管理云的所有组件。 &lt;/p&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;</description><pubDate>Wed, 27 Mar 2024 16:00:00 GMT</pubDate><guid isPermaLink="true">https://www.cncf.io/blog/2024/03/28/the-2024-trends-on-cloud-computing-by-kelsey-hightower-and-alex-saroyan/</guid></item><item><title>错过了 KubeCon + CloudNativeCon Europe 2024？这是您需要了解的一切</title><link>https://www.cncf.io/blog/2024/03/28/missed-kubecon-cloudnativecon-europe-2024-heres-everything-you-need-to-know/</link><description>&lt;p&gt;超过 12,000 人参加了我们在巴黎举行的&lt;a href="https://events.linuxfoundation.org/kubecon-cloudnativecon-europe/"&gt;KubeCon + CloudNativeCon Europe 2024&lt;/a&gt; ，虽然我们讨论了从人工智能到可持续计算的所有内容，但最大的收获是社区令人难以置信的力量。该社区推动了 Kubernetes 和云原生运动的发生，而该社区现在正在推动人工智能、平台工程甚至“绿色”计算计划的采用。&lt;/p&gt;&lt;p&gt;请继续阅读每日精彩内容（如果您想观看演示，可以在我们的&lt;a href="https://www.youtube.com/@cncf/videos"&gt;YouTube 频道&lt;/a&gt;上观看视频。）&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;同期举办活动&lt;/h2&gt;&lt;p&gt;KubeCon + CloudNativeCon Europe 2024 的同期活动始终是非常受欢迎的演示，可以深入探讨特定项目、技术或流程。今年，同一地点举行的活动继续吸引了众多参加者，对于那些新参加会议的人来说，这是与同行会面和建立联系的快速而简单的方式。&lt;a href="https://www.youtube.com/@cncf/playlists"&gt;所有同地举办的活动&lt;/a&gt;均可在 YouTube 上观看（此链接将带您前往每个同地举办的活动的播放列表……点击“查看完整播放列表”即可享受！）。或者， &lt;a href="https://www.cncf.io/blog/2024/03/19/kubecon-cloudnativecon-europe-2024-day-one-co-located-events-and-announcements-recap/"&gt;快速浏览一下&lt;/a&gt;欧洲云原生人工智能日、欧洲平台工程日、欧洲 AppDeveloperCon、云原生创业节等等。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;第一天：云原生如何推动人工智能运动&lt;/h2&gt;&lt;p&gt;毫不奇怪，在 KubeCon + CloudNativeCon Europe 2024 的第一天，人工智能“无处不在”。从人工智能中心的主题演讲到无数的操作演示，以及如何利用云原生充分利用人工智能的讨论– 反之亦然 – 速度又快又激烈，更不用说非常令人兴奋了。深入了解&lt;a href="https://www.youtube.com/@cncf/search?query=AI"&gt;YouTube 上的所有 AI 内容&lt;/a&gt;或&lt;a href="https://www.cncf.io/blog/2024/03/20/kubecon-cloudnativecon-europe-2024-day-two-how-cloud-native-is-powering-the-ai-movement-and-other-news/"&gt;探索精选的精彩内容&lt;/a&gt;。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;第二天：可持续计算的力量&lt;/h2&gt;&lt;p&gt;云原生能够并且将会帮助改善我们的环境足迹，这就是 KubeCon + CloudNativeCon Europe 2024 当天的主题。从负责任的创新到绿色 IT 和彻底变革云原生架构，全天的主题演讲和其他演讲都讨论了这一重要主题。&lt;a href="https://www.youtube.com/@cncf/search?query=sustainability%202024"&gt;通过视频探索我们所有的可持续发展演示&lt;/a&gt;，或深入&lt;a href="https://www.cncf.io/blog/2024/03/21/kubecon-cloudnativecon-europe-2024-day-three-the-power-of-sustainable-computing/"&gt;阅读当天的内容&lt;/a&gt;。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;第三天：Kubernetes 和云原生的过去与未来&lt;/h2&gt;&lt;p&gt;要结束一场令人难以置信的会议，还有什么比回顾云原生和 Kubernetes 已经取得的进展并展望即将发生的事情更好的方式呢？我们取得了如此多的进展，我们将努力实现更多目标——从日益增长的多样性和包容性到应用程序开发的未来——所有演讲者都发人深省，也令人放心。查看&lt;a href="https://www.youtube.com/@cncf/search?query=cloud%20native%20future%202024"&gt;面向未来的视频演示&lt;/a&gt;，或阅读&lt;a href="https://www.cncf.io/blog/2024/03/22/kubecon-cloudnativecon-europe-2024-day-four-how-cloud-native-is-powering-the-ai-movement-and-other-news/"&gt;当天的亮点&lt;/a&gt;。 &lt;/p&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;</description><pubDate>Wed, 27 Mar 2024 16:00:00 GMT</pubDate><guid isPermaLink="true">https://www.cncf.io/blog/2024/03/28/missed-kubecon-cloudnativecon-europe-2024-heres-everything-you-need-to-know/</guid></item><item><title>Kubernetes 上的 WebAssembly：实践指南（第 02 部分）</title><link>https://www.cncf.io/blog/2024/03/28/webassembly-on-kubernetes-the-practice-guide-part-02/</link><description>&lt;p&gt;&lt;em&gt;&lt;a href="https://github.com/cr7258"&gt;七成&lt;/a&gt;的社区帖子&lt;/em&gt;| &lt;a href="https://www.cncf.io/blog/2024/03/12/webassembly-on-kubernetes-from-containers-to-wasm-part-01/"&gt;在这里查看第一部分&lt;/a&gt;&lt;/p&gt;&lt;p&gt;在上一篇文章中，我概述了 Wasm 的特性和优势。我还解释了如何在容器环境中运行 Wasm 模块。在本文中，我将指导您在云原生生态系统中构建和部署 Wasm 应用程序。你需要：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;登录 Docker Hub（您还可以调整演练以使用不同的容器映像注册表。&lt;/li&gt;&lt;li&gt; Rust 开发环境（本文告诉您如何查找安装说明）。&lt;/li&gt;&lt;li&gt;运行 Debian、Ubuntu 或基于 Debian 的类似 Linux 发行版的 PC。&lt;br /&gt; PC 应具有 AMD64 或兼容的 CPU。&lt;br /&gt;同样，如果您使用不同风格的 Linux 或不同类型的 CPU，您可以调整建议。如果您使用不同的操作系统（不是 Linux），请在虚拟机内设置本地 Linux 环境。&lt;/li&gt;&lt;/ul&gt;&lt;h2 class="wp-block-heading"&gt;使用 Rust 和 WebAssembly 编写示例应用程序&lt;/h2&gt;&lt;p&gt;应用程序是否可以编译为 Wasm 在很大程度上取决于所使用的编程语言。 Rust、C、C++等语言对 Wasm 提供了很好的支持，Go 从 1.21 版本开始对 WASI 提供了初步支持。在此之前，需要使用tinygo等第三方工具进行编译。由于 Rust 对 Wasm 的一流支持，我在本文中使用 Rust 来开发 Wasm 应用程序。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;安装 Rust&lt;/h3&gt;&lt;p&gt;请参考&lt;a href="https://www.rust-lang.org/tools/install"&gt;Rust 安装说明&lt;/a&gt;来安装 Rust。&lt;br /&gt;确保安装 Cargo（Rust 的包管理器）以及 Rust 本身。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;为 Rust 添加 wasm32-wasi 目标&lt;/h3&gt;&lt;p&gt;前面提到，WASI 是 WebAssembly 的系统级接口，旨在促进各种环境下 WebAssembly 与主机系统之间的交互。它提供了一种标准化方法，使 WebAssembly 能够访问文件 I/O、网络和系统调用等系统级功能。&lt;/p&gt;&lt;p&gt; Rustc 是一个跨平台编译器，具有许多编译目标，包括&lt;em&gt;wasm32-wasi&lt;/em&gt; 。该目标将 Rust 代码编译成遵循 WASI 标准的 Wasm 模块。将 Rust 代码编译到 wasm32-wasi 目标可以将 Rust 的功能和安全性集成到 WebAssembly 环境中，同时利用 wasm32-wasi 提供的标准化系统接口与主机系统进行交互。&lt;/p&gt;&lt;p&gt;将 wasm32-wasi 目标添加到 Rust 编译器。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-cpp" lang="cpp"&gt;rustup target add wasm32-wasi&lt;/code&gt;&lt;/pre&gt;&lt;h3 class="wp-block-heading"&gt;编写 Rust 程序&lt;/h3&gt;&lt;p&gt;使用 Cargo new 命令创建一个名为 http-server 的新 Rust 项目：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-cpp" lang="cpp"&gt;cargo new http-server&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;编辑 Cargo.toml 文件以添加下面列出的依赖项。 &lt;a href="https://crates.io/crates/warp_wasi"&gt;&lt;em&gt;warp_wasi&lt;/em&gt;&lt;/a&gt;是专门为 WASI 设计的，构建在&lt;a href="https://docs.rs/warp/latest/warp/"&gt;&lt;em&gt;Warp&lt;/em&gt;&lt;/a&gt;框架之上，Warp 框架是一个轻量级 Web 服务器框架，用于开发高性能异步 Web 应用程序。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-csharp" lang="csharp"&gt;[dependencies]&lt;br /&gt; tokio_wasi = { version = &amp;quot;1&amp;quot;, features = [&amp;quot;rt&amp;quot;, &amp;quot;macros&amp;quot;, &amp;quot;net&amp;quot;, &amp;quot;time&amp;quot;, &amp;quot;io-util&amp;quot;]}&lt;br /&gt; warp_wasi = &amp;quot;0.3&amp;quot;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建一个简单的 HTTP 服务器，在端口 8080 上公开服务并返回“Hello, World!”当收到请求时。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class="language-csharp" lang="csharp"&gt;use warp::Filter;&lt;br /&gt;&lt;br /&gt; #[tokio::main(flavor = &amp;quot;current_thread&amp;quot;)]&lt;br /&gt; async fn main() {&lt;br /&gt;    let hello = warp::get()&lt;br /&gt;        .and(warp::path::end())&lt;br /&gt;        .map(|| &amp;quot;Hello, World!&amp;quot;);&lt;br /&gt;&lt;br /&gt;    println!(&amp;quot;Listening on http://0.0.0.0:8080&amp;quot;);&lt;br /&gt;    warp::serve(hello).run(([0, 0, 0, 0], 8080)).await;&lt;br /&gt; }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;将该文件作为 main.rs 保存到您的 PC 上。&lt;br /&gt;将程序编译成Wasm模块，会写入项目的target/wasm32-wasi/release目录下。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;cargo build --target wasm32-wasi --release&lt;/code&gt;&lt;/pre&gt;&lt;h3 class="wp-block-heading"&gt;安装 WasmEdge&lt;/h3&gt;&lt;p&gt;编译后的 Wasm 模块需要适当的 Wasm 运行时才能执行。流行的选择包括 WasmEdge、Wasmtime 和 Wasmer 等。&lt;/p&gt;&lt;p&gt;在本文中，我使用&lt;a href="https://wasmedge.org/docs/"&gt;&lt;em&gt;WasmEdge&lt;/em&gt;&lt;/a&gt; ，这是一个轻量级、高性能且可扩展的 WebAssembly 运行时。&lt;/p&gt;&lt;p&gt;通过运行以下命令安装 WasmEdge：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;# Running scripts directly via curl | bash has security implications.&lt;br /&gt; # Carefully examine the script content and only execute if you completely understand and trust the source.&lt;br /&gt; curl -sSf https://raw.githubusercontent.com/WasmEdge/WasmEdge/master/utils/install.sh | bash&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使已安装的二进制文件在当前会话中可用：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;source $HOME/.wasmedge/env&lt;/code&gt;&lt;/pre&gt;&lt;h3 class="wp-block-heading"&gt;运行 Wasm 模块&lt;/h3&gt;&lt;p&gt;您可以使用 wasmedge 命令来运行 Wasm 模块：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;wasmedge target/wasm32-wasi/release/http-server.wasm&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;向本地运行的服务发送请求：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;curl http://localhost:8080&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出是：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;Hello, World!&lt;/code&gt;&lt;/pre&gt;&lt;h2 class="wp-block-heading"&gt;在 Linux 容器中运行 Wasm 模块&lt;/h2&gt;&lt;p&gt;在当前容器生态系统中无缝运行 Wasm 模块的最简单方法是将 Wasm 模块嵌入到 Linux 容器镜像中。接下来，我将演示如何实现这一点。&lt;/p&gt;&lt;p&gt;使用编译的 Wasm 模块构建 Linux 容器映像。我将解释如何使用 Docker 来实现这一点，这是制作容器映像的一种非常常见的方法。在 http-server 项目的根目录中创建一个名为 Dockerfile-wasmedge-slim 的&lt;em&gt;Dockerfile&lt;/em&gt; 。在 Dockerfile 中，将 Wasm 模块包含在安装了 wasmedge 的 slim Linux 映像中，并使用 wasmedge 命令执行 Wasm 模块。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;FROM wasmedge/slim-runtime:0.10.1&lt;br /&gt; COPY target/wasm32-wasi/release/http-server.wasm /&lt;br /&gt; CMD [&amp;quot;wasmedge&amp;quot;, &amp;quot;--dir&amp;quot;, &amp;quot;.:/&amp;quot;, &amp;quot;/http-server.wasm&amp;quot;]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;构建容器镜像：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;# replace cr7258 with your own Docker Hub repository name&lt;br /&gt; docker build -f Dockerfile-wasmedge-slim -t cr7258/wasm-demo-app:slim .&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了在本地测试代码，我将使用 Docker 运行容器：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;docker run -itd -p 8080:8080 \&lt;br /&gt; --name wasm-demo-app \&lt;br /&gt; docker.io/cr7258/wasm-demo-app:slim&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;向本地测试容器中运行的服务发送请求：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;curl http://localhost:8080&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出是：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;Hello, World!&lt;/code&gt;&lt;/pre&gt;&lt;h2 class="wp-block-heading"&gt;在支持 Wasm 的容器运行时中运行 Wasm 模块&lt;/h2&gt;&lt;p&gt;在上一节中，我展示了如何将 Wasm 模块嵌入到 Linux 容器中来运行 Wasm 模块。接下来，我将从低级和高级容器运行时的角度演示如何使用支持 Wasm 的容器运行时直接运行 Wasm 模块。这种方法提供了更好的安全性和性能。&lt;/p&gt;&lt;p&gt;在运行 Wasm 模块之前，请将其构建到没有 Linux 操作系统的映像中。 &lt;em&gt;scrap&lt;/em&gt;是 Docker 中保留的最小基础镜像。 Dockerfile 如下所示：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;FROM scratch&lt;br /&gt; COPY target/wasm32-wasi/release/http-server.wasm /&lt;br /&gt; CMD [&amp;quot;/http-server.wasm&amp;quot;]&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;构建容器镜像。这次创建的镜像大约只有之前构建的 wasm-demo-app:slim 镜像大小的 1/4。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;# replace cr7258 with your own Docker Hub repository name&lt;br /&gt; docker build -t docker.io/cr7258/wasm-demo-app:v1 .&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了方便后面的demo使用，请将镜像推送到Docker Hub。将存储库替换为您自己的存储库。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;# replace cr7258 with your own Docker Hub repository name&lt;br /&gt; docker push docker.io/cr7258/wasm-demo-app:v1&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下来，我将单独演示如何通过低级和高级容器运行时运行 Wasm 模块。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;通过低级容器运行时运行 Wasm 模块&lt;/h3&gt;&lt;p&gt;&lt;a href="https://github.com/containers/crun"&gt;&lt;em&gt;Crun&lt;/em&gt;&lt;/a&gt;是一个用 C 语言编写的快速且轻量级的 OCI 容器运行时，它内置了对 WasmEdge 的支持。在本节中，我将演示如何利用 crun 使用提供的 config.json 和 rootfs 文件直接启动 Wasm 模块，而不依赖于高级容器运行时。&lt;/p&gt;&lt;p&gt; 💡 确保您已按照“安装 WasmEdge”部分中的说明&lt;a href="https://docs.google.com/document/d/1eM-iK_0s-Z7daLe1w_8TKujj5cxHl4S6/edit#bookmark=id.gjdgxs"&gt;安装了 WasmEdge&lt;/a&gt; 。&lt;/p&gt;&lt;p&gt;安装编译所需的依赖项。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;apt update&lt;br /&gt; apt install -y make git gcc build-essential pkgconf libtool \&lt;br /&gt;    libsystemd-dev libprotobuf-c-dev libcap-dev libseccomp-dev libyajl-dev \&lt;br /&gt;    go-md2man libtool autoconf python3 automake&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;配置、构建和安装包含 WasmEdge 支持的 crun 二进制文件：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;git clone https://github.com/containers/crun&lt;br /&gt; cd crun&lt;br /&gt; ./autogen.sh&lt;br /&gt; ./configure --with-wasmedge&lt;br /&gt; make&lt;br /&gt; make install&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行crun -v 检查安装是否成功。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;crun -v&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;看到+WASM:wasmedge表示crun中已经安装了WasmEdge。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;crun version 1.8.5.0.0.0.23-3856&lt;br /&gt; commit: 385654125154075544e83a6227557bfa5b1f8cc5&lt;br /&gt; rundir: /run/crun&lt;br /&gt; spec: 1.0.0&lt;br /&gt; +SYSTEMD +SELINUX +APPARMOR +CAP +SECCOMP +EBPF +WASM:wasmedge +YAJL&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建一个目录，用于存放运行容器所需的文件和目录（config.json和rootfs），&lt;br /&gt;然后复制到根文件系统：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;mkdir test-crun&lt;br /&gt; cd test-crun&lt;br /&gt; mkdir rootfs&lt;br /&gt; # Copy the compiled Wasm module to the rootfs directory, replace it with the appropriate directory path for your system.&lt;br /&gt; cp ~/hands-on-lab/wasm/runtime/http-server/target/wasm32-wasi/release/http-server.wasm rootfs&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;运行 crun spec 命令生成默认的 config.json 配置文件，然后进行以下修改：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;将 args 字段中的 sh 替换为 /http-server.wasm。&lt;/li&gt;&lt;li&gt;在注释字段中添加“module.wasm.image/variant”:“compat”以表明这是一个没有客户操作系统的 Wasm 应用程序。&lt;/li&gt;&lt;li&gt;在网络命名空间中添加“path”：“/proc/1/ns/net”，以允许程序与宿主机共享网络命名空间。这将使我们能够在本地访问容器。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;修改后的配置文件应如下所示：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;{ &amp;quot;ociVersion&amp;quot;: &amp;quot;1.0.0&amp;quot;, &amp;quot;process&amp;quot;: { &amp;quot;terminal&amp;quot;: true, &amp;quot;user&amp;quot;: { &amp;quot;uid&amp;quot;: 0, &amp;quot;gid&amp;quot;: 0 }, &amp;quot;args&amp;quot;: [ &amp;quot;/http-server.wasm&amp;quot; ], &amp;quot;env&amp;quot;: [ &amp;quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&amp;quot;, &amp;quot;TERM=xterm&amp;quot; ], &amp;quot;cwd&amp;quot;: &amp;quot;/&amp;quot;, &amp;quot;capabilities&amp;quot;: { &amp;quot;bounding&amp;quot;: [ &amp;quot;CAP_AUDIT_WRITE&amp;quot;, &amp;quot;CAP_KILL&amp;quot;, &amp;quot;CAP_NET_BIND_SERVICE&amp;quot; ], &amp;quot;effective&amp;quot;: [ &amp;quot;CAP_AUDIT_WRITE&amp;quot;, &amp;quot;CAP_KILL&amp;quot;, &amp;quot;CAP_NET_BIND_SERVICE&amp;quot; ], &amp;quot;inheritable&amp;quot;: [ ], &amp;quot;permitted&amp;quot;: [ &amp;quot;CAP_AUDIT_WRITE&amp;quot;, &amp;quot;CAP_KILL&amp;quot;, &amp;quot;CAP_NET_BIND_SERVICE&amp;quot; ], &amp;quot;ambient&amp;quot;: [ &amp;quot;CAP_AUDIT_WRITE&amp;quot;, &amp;quot;CAP_KILL&amp;quot;, &amp;quot;CAP_NET_BIND_SERVICE&amp;quot; ] }, &amp;quot;rlimits&amp;quot;: [ { &amp;quot;type&amp;quot;: &amp;quot;RLIMIT_NOFILE&amp;quot;, &amp;quot;hard&amp;quot;: 1024, &amp;quot;soft&amp;quot;: 1024 } ], &amp;quot;noNewPrivileges&amp;quot;: true }, &amp;quot;root&amp;quot;: { &amp;quot;path&amp;quot;: &amp;quot;rootfs&amp;quot;, &amp;quot;readonly&amp;quot;: true }, &amp;quot;hostname&amp;quot;: &amp;quot;crun&amp;quot;, &amp;quot;mounts&amp;quot;: [ { &amp;quot;destination&amp;quot;: &amp;quot;/proc&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;proc&amp;quot;, &amp;quot;source&amp;quot;: &amp;quot;proc&amp;quot; }, { &amp;quot;destination&amp;quot;: &amp;quot;/dev&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;tmpfs&amp;quot;, &amp;quot;source&amp;quot;: &amp;quot;tmpfs&amp;quot;, &amp;quot;options&amp;quot;: [ &amp;quot;nosuid&amp;quot;, &amp;quot;strictatime&amp;quot;, &amp;quot;mode=755&amp;quot;, &amp;quot;size=65536k&amp;quot; ] }, { &amp;quot;destination&amp;quot;: &amp;quot;/dev/pts&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;devpts&amp;quot;, &amp;quot;source&amp;quot;: &amp;quot;devpts&amp;quot;, &amp;quot;options&amp;quot;: [ &amp;quot;nosuid&amp;quot;, &amp;quot;noexec&amp;quot;, &amp;quot;newinstance&amp;quot;, &amp;quot;ptmxmode=0666&amp;quot;, &amp;quot;mode=0620&amp;quot;, &amp;quot;gid=5&amp;quot; ] }, { &amp;quot;destination&amp;quot;: &amp;quot;/dev/shm&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;tmpfs&amp;quot;, &amp;quot;source&amp;quot;: &amp;quot;shm&amp;quot;, &amp;quot;options&amp;quot;: [ &amp;quot;nosuid&amp;quot;, &amp;quot;noexec&amp;quot;, &amp;quot;nodev&amp;quot;, &amp;quot;mode=1777&amp;quot;, &amp;quot;size=65536k&amp;quot; ] }, { &amp;quot;destination&amp;quot;: &amp;quot;/dev/mqueue&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;mqueue&amp;quot;, &amp;quot;source&amp;quot;: &amp;quot;mqueue&amp;quot;, &amp;quot;options&amp;quot;: [ &amp;quot;nosuid&amp;quot;, &amp;quot;noexec&amp;quot;, &amp;quot;nodev&amp;quot; ] }, { &amp;quot;destination&amp;quot;: &amp;quot;/sys&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;sysfs&amp;quot;, &amp;quot;source&amp;quot;: &amp;quot;sysfs&amp;quot;, &amp;quot;options&amp;quot;: [ &amp;quot;nosuid&amp;quot;, &amp;quot;noexec&amp;quot;, &amp;quot;nodev&amp;quot;, &amp;quot;ro&amp;quot; ] }, { &amp;quot;destination&amp;quot;: &amp;quot;/sys/fs/cgroup&amp;quot;, &amp;quot;type&amp;quot;: &amp;quot;cgroup&amp;quot;, &amp;quot;source&amp;quot;: &amp;quot;cgroup&amp;quot;, &amp;quot;options&amp;quot;: [ &amp;quot;nosuid&amp;quot;, &amp;quot;noexec&amp;quot;, &amp;quot;nodev&amp;quot;, &amp;quot;relatime&amp;quot;, &amp;quot;ro&amp;quot; ] } ], &amp;quot;annotations&amp;quot;: { &amp;quot;module.wasm.image/variant&amp;quot;: &amp;quot;compat&amp;quot; }, &amp;quot;linux&amp;quot;: { &amp;quot;resources&amp;quot;: { &amp;quot;devices&amp;quot;: [ { &amp;quot;allow&amp;quot;: false, &amp;quot;access&amp;quot;: &amp;quot;rwm&amp;quot; } ] }, &amp;quot;namespaces&amp;quot;: [ { &amp;quot;type&amp;quot;: &amp;quot;pid&amp;quot; }, { &amp;quot;type&amp;quot;: &amp;quot;network&amp;quot;, &amp;quot;path&amp;quot;: &amp;quot;/proc/1/ns/net&amp;quot; }, { &amp;quot;type&amp;quot;: &amp;quot;ipc&amp;quot; }, { &amp;quot;type&amp;quot;: &amp;quot;uts&amp;quot; }, { &amp;quot;type&amp;quot;: &amp;quot;cgroup&amp;quot; }, { &amp;quot;type&amp;quot;: &amp;quot;mount&amp;quot; } ], &amp;quot;maskedPaths&amp;quot;: [ &amp;quot;/proc/acpi&amp;quot;, &amp;quot;/proc/asound&amp;quot;, &amp;quot;/proc/kcore&amp;quot;, &amp;quot;/proc/keys&amp;quot;, &amp;quot;/proc/latency_stats&amp;quot;, &amp;quot;/proc/timer_list&amp;quot;, &amp;quot;/proc/timer_stats&amp;quot;, &amp;quot;/proc/sched_debug&amp;quot;, &amp;quot;/sys/firmware&amp;quot;, &amp;quot;/proc/scsi&amp;quot; ], &amp;quot;readonlyPaths&amp;quot;: [ &amp;quot;/proc/bus&amp;quot;, &amp;quot;/proc/fs&amp;quot;, &amp;quot;/proc/irq&amp;quot;, &amp;quot;/proc/sys&amp;quot;, &amp;quot;/proc/sysrq-trigger&amp;quot; ] } }&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用 crun 启动容器：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;crun run wasm-demo-app&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;向该容器中的演示服务发送请求：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;curl http://localhost:8080&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出是：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;Hello, World!&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要删除容器，可以执行以下命令：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;crun kill wasm-demo-app SIGKILL&lt;/code&gt;&lt;/pre&gt;&lt;h3 class="wp-block-heading"&gt;通过高级容器运行时运行 Wasm 模块&lt;/h3&gt;&lt;p&gt;&lt;em&gt;容器 shim&lt;/em&gt;充当高级和低级容器运行时之间的桥梁。其主要目的是抽象低层运行时细节，实现高层运行时对各种低层运行时的统一管理。在本节中，我将使用&lt;a href="https://github.com/containerd/containerd"&gt;&lt;em&gt;containerd&lt;/em&gt;&lt;/a&gt;作为示例。 Containerd 是一个行业标准的容器运行时，强调简单性、稳健性和可移植性。&lt;/p&gt;&lt;p&gt; Containerd 可以通过两种方式管理 Wasm 模块：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;通过 crun 和 youki 等支持使用 Wasm 运行时库构建的容器运行时来管理 Wasm 模块。这两个运行时也可以运行常规 Linux 容器。 Containerd 使用containerd-shim-runc-v2 与低级容器运行时交互。&lt;/li&gt;&lt;li&gt;直接通过 Wasm 运行时管理 Wasm 模块，例如 Slight、Spin、WasmEdge 和 Wasmtime。 Containerd 使用 containerd-wasm-shim(runwasi) 与 Wasm 运行时交互。&lt;/li&gt;&lt;/ol&gt;&lt;h4 class="wp-block-heading"&gt;容器+Crun&lt;/h4&gt;&lt;p&gt;在本节中，我将演示如何将 crun 配置为 containerd 中的运行时，从而支持运行 Wasm 模块。&lt;/p&gt;&lt;p&gt; 💡 确保已按照以下部分中的说明安装了支持 Wasm 的 crun 二进制文件： &lt;a href="https://docs.google.com/document/d/1eM-iK_0s-Z7daLe1w_8TKujj5cxHl4S6/edit#bookmark=id.30j0zll"&gt;通过低级容器运行时运行 Wasm 模块&lt;/a&gt;。&lt;/p&gt;&lt;p&gt;运行以下命令安装containerd：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;export VERSION=&amp;quot;1.7.3&amp;quot;&lt;br /&gt; sudo apt install -y libseccomp2&lt;br /&gt; sudo apt install -y wget&lt;br /&gt;&lt;br /&gt; wget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz&lt;br /&gt; wget https://github.com/containerd/containerd/releases/download/v${VERSION}/cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum&lt;br /&gt; # expected checksum: ea70faeb6c5d656fa0787dfc7d88a48daf961482c46bb22953cb5396289fd5b8&lt;br /&gt; sha256sum --check cri-containerd-cni-${VERSION}-linux-amd64.tar.gz.sha256sum&lt;br /&gt;&lt;br /&gt; sudo tar --no-overwrite-dir -C / -xzf cri-containerd-cni-${VERSION}-linux-amd64.tar.gz&lt;br /&gt; sudo systemctl daemon-reload&lt;br /&gt; sudo systemctl enable containerd --now&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;您可以通过containerd运行Wasm模块：&lt;/p&gt;&lt;ul&gt;&lt;li&gt; –runc-binary：指定使用crun作为低级运行时来启动容器。&lt;/li&gt;&lt;li&gt; –runtime：指定shim的版本和名称，由containerd转换为shim的二进制名称。例如：io.containerd.runc.v2→containerd-shim-runc-v2。 Containerd 通过运行 containerd-shim-runc-v2 二进制文件来启动 shim，该文件随后调用 crun 来启动容器。&lt;/li&gt;&lt;li&gt; –label：添加“module.wasm.image/variant”：“compat”以指示这是一个没有客户操作系统的 Wasm 应用程序。&lt;/li&gt;&lt;/ul&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;# Pull the image&lt;br /&gt; ctr i pull docker.io/cr7258/wasm-demo-app:v1&lt;br /&gt;&lt;br /&gt; # Run the container&lt;br /&gt; ctr run --rm --net-host \&lt;br /&gt; --runc-binary crun \&lt;br /&gt; --runtime io.containerd.runc.v2 \&lt;br /&gt; --label module.wasm.image/variant=compat \&lt;br /&gt; docker.io/cr7258/wasm-demo-app:v1 \&lt;br /&gt; wasm-demo-app&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;向该容器中的演示服务发送请求：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;curl http://localhost:8080&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出是：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;Hello, World!&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要删除容器，可以执行以下命令。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;ctr task kill wasm-demo-app --signal SIGKILL&lt;/code&gt;&lt;/pre&gt;&lt;h4 class="wp-block-heading"&gt; Containerd + Runwasi&lt;/h4&gt;&lt;p&gt; &lt;a href="https://github.com/containerd/runwasi"&gt;&lt;em&gt;Runwasi&lt;/em&gt;&lt;/a&gt;是一个用Rust编写的库，是containerd的子项目。使用runwasi，您可以编写一个containerd wasm shim来与Wasm运行时集成，这有助于直接运行由containerd管理的Wasm模块。有几种使用 runwasi 开发的 Containerd wasm shim，包括：&lt;/p&gt;&lt;ul&gt;&lt;li&gt; WasmEdge、Wasmtime 和 Wasmer，您可以在&lt;a href="https://github.com/containerd/runwasi/tree/main/crates"&gt;runwasi&lt;/a&gt;存储库中找到它们。&lt;/li&gt;&lt;li&gt; Spin、Slight、Wasm Workers Server 和 Lunatic，您可以在&lt;a href="https://github.com/deislabs/containerd-wasm-shims"&gt;containerd-wasm-shims&lt;/a&gt;存储库中找到它们。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;在本文中，我使用 WasmEdge containerd shim 来运行 Wasm 模块。&lt;/p&gt;&lt;p&gt;克隆 runwasi 存储库。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;git clone https://github.com/containerd/runwasi.git&lt;br /&gt; cd runwasi&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;安装编译所需的依赖项。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;sudo apt-get -y install    \&lt;br /&gt;      pkg-config          \&lt;br /&gt;      libsystemd-dev      \&lt;br /&gt;      libdbus-glib-1-dev  \&lt;br /&gt;      build-essential     \&lt;br /&gt;      libelf-dev          \&lt;br /&gt;      libseccomp-dev      \&lt;br /&gt;      libclang-dev        \&lt;br /&gt;      libssl-dev&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;构建并安装垫片。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;make build&lt;br /&gt; sudo make install&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;指定 –runtime=io.containerd.wasmedge.v1 通过 WasmEdge shim 运行 Wasm 模块。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;ctr run --rm --net-host \&lt;br /&gt; --runtime=io.containerd.wasmedge.v1 \&lt;br /&gt; docker.io/cr7258/wasm-demo-app:v1 \&lt;br /&gt; wasm-demo-app&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;向该容器中的演示服务发送请求：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;curl http://localhost:8080&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出是：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;Hello, World!&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要删除容器，可以执行以下命令。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;ctr task kill wasm-demo-app --signal SIGKILL&lt;/code&gt;&lt;/pre&gt;&lt;h2 class="wp-block-heading"&gt;在容器管理平台上运行 Wasm 模块&lt;/h2&gt;&lt;h3 class="wp-block-heading"&gt;在 Docker Desktop 上运行 Wasm 模块&lt;/h3&gt;&lt;p&gt;当您开发软件时，您希望在本地和云端进行尝试。我将使用 Docker Desktop 作为可用于在容器内本地运行代码的工具示例。&lt;/p&gt;&lt;p&gt; Docker Desktop 还使用 runwasi 来支持 Wasm 模块。按照&lt;a href="https://docs.docker.com/desktop/wasm/#turn-on-wasm-workloads"&gt;Docker Wasm 文档&lt;/a&gt;中的说明在 Docker Desktop 上启用 Wasm 支持。&lt;/p&gt;&lt;p&gt;使用以下 docker run 命令在系统上启动 Wasm 容器。 –runtime=io.containerd.wasmedge.v1 通知 Docker 引擎您想要使用 Wasm containerd shim 而不是标准的 Linux 容器运行时。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;docker run -d -p 8080:8080 \&lt;br /&gt; --name=wasm-demo-app \&lt;br /&gt; --runtime=io.containerd.wasmedge.v1 \&lt;br /&gt; docker.io/cr7258/wasm-demo-app:v1&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;向该容器中的演示服务发送请求：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;curl http://localhost:8080&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出是：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;Hello, World!&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;要删除容器，可以执行以下命令：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;docker rm -f wasm-demo-app&lt;/code&gt;&lt;/pre&gt;&lt;h3 class="wp-block-heading"&gt;在 Kubernetes 上运行 Wasm 模块&lt;/h3&gt;&lt;p&gt;要在 Kubernetes 上运行 Wasm 工作负载，工作节点需要使用 Wasm 运行时进行引导，并且 RuntimeClass 对象用于将工作负载分配给支持 Wasm 的节点。&lt;/p&gt;&lt;p&gt; &lt;a href="https://kind.sigs.k8s.io/"&gt;&lt;em&gt;Kind&lt;/em&gt;&lt;/a&gt; （Docker 中的 Kubernetes）是一种使用本地容器作为“节点”运行本地 Kubernetes 集群的工具，通常在 Docker 中。为了方便实验，我们使用kind创建一个Kubernetes集群，以供后续章节使用。运行以下命令来安装 kind：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;[ $(uname -m) = x86_64 ] &amp;amp;&amp;amp; curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.20.0/kind-linux-amd64&lt;br /&gt; chmod +x ./kind&lt;br /&gt; sudo mv ./kind /usr/local/bin/kind&lt;/code&gt;&lt;/pre&gt;&lt;h4 class="wp-block-heading"&gt;手动为 Wasm 设置集群，然后在 pod 内运行应用程序&lt;/h4&gt;&lt;p&gt;在本节中，我将演示使用 WasmEdge 运行时库手动安装 crun，并调整 containerd 配置以使用 crun 作为运行时，从而在 Kubernetes 节点上启用 Wasm 支持。&lt;/p&gt;&lt;p&gt;使用kind创建单节点Kubernetes集群。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;kind create cluster --name wasm-demo&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;按种类创建的每个 Kubernetes 节点都是一个容器，通常在 Docker 中运行。您可以使用 docker exec 命令进入该节点。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;docker exec -it wasm-demo-control-plane bash&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; 💡 在节点上输入 shell 后，按照以下部分中的说明进行操作： &lt;a href="https://docs.google.com/document/d/1eM-iK_0s-Z7daLe1w_8TKujj5cxHl4S6/edit#bookmark=id.30j0zll"&gt;通过低级容器运行时运行 Wasm 模块&lt;/a&gt;，以在节点上安装支持 Wasm 的 crun 二进制文件。&lt;/p&gt;&lt;p&gt;修改containerd配置文件/etc/containerd/config.toml，在最后添加以下内容：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;将 crun 配置为 containerd 的运行时处理程序。格式为 [plugins.”io.containerd.grpc.v1.cri”.containerd.runtimes.${HANDLER_NAME}]。&lt;/li&gt;&lt;li&gt; pod_annotations 允许将注释 module.wasm.image/variant 传递给 crun，该注释在 Pod 元数据中设置以识别 Wasm 工作负载。&lt;/li&gt;&lt;/ul&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;cat &amp;gt;&amp;gt; /etc/containerd/config.toml &amp;lt;&amp;lt; EOF&lt;br /&gt; [plugins.&amp;quot;io.containerd.grpc.v1.cri&amp;quot;.containerd.runtimes.crun]&lt;br /&gt;    runtime_type = &amp;quot;io.containerd.runc.v2&amp;quot;&lt;br /&gt;    pod_annotations = [&amp;quot;module.wasm.image/variant&amp;quot;]&lt;br /&gt; [plugins.&amp;quot;io.containerd.grpc.v1.cri&amp;quot;.containerd.runtimes.crun.options]&lt;br /&gt;    BinaryName = &amp;quot;crun&amp;quot;&lt;br /&gt; EOF&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;重新启动容器：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;systemctl restart containerd&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在节点上设置标签runtime=crun：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;kubectl label nodes wasm-demo-control-plane runtime=crun&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;创建一个名为 crun 的 RuntimeClass 资源，以使用 containerd 中预先配置的 crun 处理程序，scheduling.nodeSelector 属性将 pod 发送到带有 runtime=crun 标签的节点。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;apiVersion: node.k8s.io/v1&lt;br /&gt; kind: RuntimeClass&lt;br /&gt; metadata:&lt;br /&gt;  name: crun&lt;br /&gt; scheduling:&lt;br /&gt;  nodeSelector:&lt;br /&gt;    runtime: crun&lt;br /&gt; handler: crun&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下来，在 Kubernetes Pod 中运行 Wasm 应用程序。为 pod 设置 .spec.runtimeClassName 以将 pod 定位到 crun RuntimeClass。这将确保 pod 被分配到 crun RuntimeClass 中指定的节点和运行时。此外，设置注释 module.wasm.image/variant: compat 以通知 crun 这是一个 Wasm 工作负载。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;apiVersion: v1&lt;br /&gt; kind: Pod&lt;br /&gt; metadata:&lt;br /&gt;  name: wasm-demo-app&lt;br /&gt;  annotations:&lt;br /&gt;    module.wasm.image/variant: compat&lt;br /&gt; spec:&lt;br /&gt;  runtimeClassName: crun&lt;br /&gt;  containers:&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;名称：wasm-演示应用程序&lt;br /&gt;图片：docker.io/cr7258/wasm-demo-app:v1&lt;/li&gt;&lt;/ul&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;&lt;br /&gt;You can use `kubectl port-forward` to forward traffic from your local machine into the Kubernetes cluster:&lt;br /&gt;&lt;br /&gt; ```bash&lt;br /&gt; kubectl port-forward pod/wasm-demo-app 8080:8080&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;打开一个新终端，向服务发送请求。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;curl http://localhost:8080&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出是：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;Hello, World!&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;测试完成后，您可以通过运行以下命令来销毁集群：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;kind delete cluster --name wasm-demo&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在本文中， module.wasm.image/variant: compat 注解用于向容器运行时指示该工作负载是 Wasm 工作负载。在此&lt;a href="https://github.com/containers/crun/pull/886"&gt;PR&lt;/a&gt;中，crun 引入了一个新的注释：module.wasm.image/variant: compat-smart。&lt;/p&gt;&lt;p&gt;当使用compat-smart注解时，crun可以根据是Wasm工作负载还是OCI容器智能判断如何启动容器。这使得使用 sidecar 运行 WASM 容器成为可能。以下是包含 Wasm 容器和 Linux 容器的 Pod YAML 文件示例：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;apiVersion: v1&lt;br /&gt; kind: Pod&lt;br /&gt; metadata:&lt;br /&gt;  name: wasm-demo-app&lt;br /&gt;  annotations:&lt;br /&gt;    module.wasm.image/variant: compat-smart # Kubernetes copies Pod annotations to container runtime labels, which is why this works.&lt;br /&gt; spec:&lt;br /&gt;  runtimeClassName: crun&lt;br /&gt;  containers:&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;名称：wasm-演示应用程序&lt;br /&gt;图片：docker.io/cr7258/wasm-demo-app:v1&lt;/li&gt;&lt;li&gt;名称：linux-demo-app&lt;br /&gt;图片：nginx：1.20&lt;/li&gt;&lt;/ul&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;&lt;br /&gt;#### Set up your cluster for Wasm automatically using Kwasm, then run the app inside a pod&lt;br /&gt;&lt;br /&gt; _[Kwasm](https://kwasm.sh/)_ is a Kubernetes Operator that automatically adds WebAssembly support to your Kubernetes nodes. In this section, I will demostrate how to use Kwasm Operator to add Wasm support to Kubernetes nodes automatically.&lt;br /&gt;&lt;br /&gt; To enable Wasm support on a particular node, simply add the annotation `kwasm.sh/kwasm-node=true` on that node. This will trigger Kwasm to create a Job to deploy the necessary binary files needed to run Wasm on the node. Additionally, containerd&amp;#39;s configuration will be modified accordingly.&lt;br /&gt;&lt;br /&gt; ![02-kwasm-operator](https://hackmd.io/_uploads/HyYbqsF2p.svg)&lt;br /&gt;&lt;br /&gt;&lt;br /&gt; Create a single-node Kubernetes cluster using kind.&lt;br /&gt;&lt;br /&gt; ```bash&lt;br /&gt; kind create cluster --name kwasm-demo&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; Helm 图表可用于轻松安装 Kwasm 操作器。使用 helm 安装 Kwasm Operator，并通过添加注释 kwasm.sh/kwasm-node=true 启用对节点 kwasm-demo-control-plane 的 Wasm 支持。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;# Add Helm repository if not already done&lt;br /&gt; helm repo add kwasm http://kwasm.sh/kwasm-operator/&lt;br /&gt; # Install KWasm operator&lt;br /&gt; helm install -n kwasm --create-namespace kwasm-operator kwasm/kwasm-operator&lt;br /&gt; # Provision Nodes&lt;br /&gt; kubectl annotate node kwasm-demo-control-plane kwasm.sh/kwasm-node=true&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;在节点上添加标签runtime=wasmedge。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;kubectl label nodes kwasm-demo-control-plane runtime=wasmedge&lt;/code&gt;&lt;/pre&gt;&lt;p&gt; kwasm-node-installer 版本 v0.3.0 已删除 crun 以支持 WasmEdge shim。 WasmEdge shim 与 module.wasm.image/variant 具有相同的行为：crun + Wasmedge 的 compat-smart 注释，但不需要注释。&lt;/p&gt;&lt;p&gt;创建一个名为 wasmedge 的 RuntimeClass 资源，以使用 Kwasm 在 containerd 中自动设置的 wasmedge 处理程序，scheduling.nodeSelector 属性将 pod 发送到带有 runtime=wasmedge 标签的节点。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;apiVersion: node.k8s.io/v1&lt;br /&gt; kind: RuntimeClass&lt;br /&gt; metadata:&lt;br /&gt;  name: wasmedge&lt;br /&gt; scheduling:&lt;br /&gt;  nodeSelector:&lt;br /&gt;    runtime: wasmedge&lt;br /&gt; handler: wasmedge&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;接下来，在 Kubernetes Pod 中运行 Wasm 应用程序。为 pod 设置 .spec.runtimeClassName 以将 pod 定位到 wasmedge RuntimeClass。这将确保 pod 被分配到 wasmedge RuntimeClass 中指定的节点和运行时。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;apiVersion: v1&lt;br /&gt; kind: Pod&lt;br /&gt; metadata:&lt;br /&gt;  name: wasm-demo-app&lt;br /&gt; spec:&lt;br /&gt;  runtimeClassName: wasmedge&lt;br /&gt;  containers:&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;名称：wasm-演示应用程序&lt;br /&gt;图片：docker.io/cr7258/wasm-demo-app:v1&lt;/li&gt;&lt;/ul&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;&lt;br /&gt;You can use `kubectl port-forward` to forward traffic from your local machine into the Kubernetes cluster:&lt;br /&gt;&lt;br /&gt; ```bash&lt;br /&gt; kubectl port-forward pod/wasm-demo-app 8080:8080&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;打开一个新终端，向服务发送请求。&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;curl http://localhost:8080&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出是：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;Hello, World!&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;测试完成后，您可以通过运行以下命令来销毁集群：&lt;/p&gt;&lt;pre class="wp-block-code"&gt; &lt;code class=""&gt;kind delete cluster --name kwasm-demo&lt;/code&gt;&lt;/pre&gt;&lt;h2 class="wp-block-heading"&gt;结论&lt;/h2&gt;&lt;p&gt;随着 WebAssembly 的不断发展，它在 Kubernetes 中的采用标志着云原生应用程序开发向前迈出了重要一步。&lt;/p&gt;&lt;p&gt;感谢您阅读这篇文章。我希望它有助于了解 WebAssembly 的潜力以及它如何与容器生态系统配合使用。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;致谢&lt;/h2&gt;&lt;p&gt;本文包含 Kubernetes 项目的贡献和反馈，版权所有 © 2024 Linux 基金会。 &lt;/p&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;</description><pubDate>Wed, 27 Mar 2024 16:00:00 GMT</pubDate><guid isPermaLink="true">https://www.cncf.io/blog/2024/03/28/webassembly-on-kubernetes-the-practice-guide-part-02/</guid></item><item><title>通过 AI 驱动的 DevEx 实现工作流程自动化和管道可移植性</title><link>https://www.cncf.io/blog/2024/03/27/workflow-automation-pipeline-portability-with-ai-driven-devex/</link><description>&lt;p&gt;&lt;em&gt;会员帖子最初由 Amina Reshma 在&lt;a href="https://ozone.one/workflow-automation-&amp;amp;-pipeline-portability-with-ai-driven-devex"&gt;Ozone 博客&lt;/a&gt;上发布&lt;/em&gt;&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;与 DevEx 有什么关系？&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;破解代码：&lt;/strong&gt;曾经想过开发者体验，又名.a。开发执行？好吧，这就是整个东西——氛围、工具、仪式——基本上，是软件开发人员成功或失败的秘密武器。&lt;/p&gt;&lt;p&gt;那么，为什么衡量开发人员的生产力如此困难呢？首先，DevEx 很难描述。关于开发人员生产力的定义，存在着众多不同的观点。此外，必须考虑过程（定量）和感知（定性）指标。评估开发人员的成就感水平与衡量他们的生产力同样重要。&lt;/p&gt;&lt;p&gt;满意的开发人员更有可能留在您的组织中，并花更多时间编码和交付高质量的产品。由于 DevEx 是多方面的，没有任何一种数据能够完全捕捉到其本质。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt;为什么要炒作？&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;人才磁铁：&lt;/strong&gt; DevEx 是您吸引和留住顶尖技术人才的后台通行证。这就像开发商的VIP休息室。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;有钱能使鬼推磨：&lt;/strong&gt;这不仅仅关系到快乐的程序员；还关系到快乐的程序员。这是关于钱的。 DevEx 直接影响您的开发团队的生产力，您猜对了，这会影响您的利润。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;文化俱乐部：&lt;/strong&gt; DevEx 不仅仅是一个工具箱；这是一种氛围。这是为了培育一种文化，让编码感觉就像一场精心策划的即兴演奏会。&lt;/li&gt;&lt;/ul&gt;&lt;h3 class="wp-block-heading"&gt;何必呢？&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;创新或死亡：DevEx 是创新的燃料。想要保持领先吗？更好地保持 DevEx 游戏的强大。&lt;/li&gt;&lt;li&gt;战略棋步：投资 DevEx 就像下棋，而不是跳棋。这是一项长期战略，为快乐、高效且极具创造力的开发团队奠定了基础。&lt;/li&gt;&lt;/ul&gt;&lt;h2 class="wp-block-heading"&gt;增强 DevEx 游戏的 6 大举措&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;标准化和容器化&lt;/strong&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;想象一下 Docker 和 Kubernetes 作为您的可靠性助手，标准化您的开发传奇。&lt;/li&gt;&lt;li&gt;不再是“它可以在我的机器上运行”——现在是“它可以在任何地方、普遍运行！”&lt;/li&gt;&lt;/ul&gt;&lt;ol start="2"&gt;&lt;li&gt;&lt;strong&gt;文档和入职培训&lt;/strong&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;让您的代码库文档保持最佳状态，并使入职流程比丝绸之路更加顺畅。&lt;/li&gt;&lt;li&gt;文档可以作为您的文化指南针 - 让它们变得全面，让它们变得像夏洛克那样聪明。&lt;/li&gt;&lt;/ul&gt;&lt;ol start="3"&gt;&lt;li&gt;&lt;strong&gt;工具链&lt;/strong&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;从 IDE 到版本控制，保持工具的完善，就像工匠最喜欢的工具包一样。&lt;/li&gt;&lt;li&gt;使用的工具应该与开发人员门户完美匹配，即使您没有，也不应该妨碍您拥有良好的 DevEx。&lt;/li&gt;&lt;/ul&gt;&lt;ol start="4"&gt;&lt;li&gt;&lt;strong&gt;代码质量&lt;/strong&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;让静态代码分析器和 linter 为您的开发人员进行质量检查探戈。&lt;/li&gt;&lt;li&gt;更少的手动审查，更少的麻烦——保持代码环境无可挑剔的干净。&lt;/li&gt;&lt;/ul&gt;&lt;ol start="5"&gt;&lt;li&gt;&lt;strong&gt;开发者自主权&lt;/strong&gt;&lt;/li&gt;&lt;/ol&gt;&lt;ul&gt;&lt;li&gt;让您的开发人员在决策中拥有发言权——让他们成为主角。&lt;/li&gt;&lt;li&gt;开发人员正在修复他们的故障吗？这不是混乱；而是混乱。这就是赋权的奥秘。&lt;/li&gt;&lt;/ul&gt;&lt;ol start="6"&gt;&lt;li&gt;&lt;strong&gt;人工智能：您在发展领域的新朋友&lt;/strong&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;我们已经看到人工智能 (AI) 在各个领域发挥其魔力。对于提升 DevEx 也是如此！以下是人工智能如何重塑多个行业的用户体验的快速浏览：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;医疗保健：&lt;/strong&gt;通过预测分析、个性化治疗计划和高效的患者护理系统来改变医疗保健。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;金融：&lt;/strong&gt;简化欺诈检测、自动化重复任务并提供数据驱动的见解，以改善金融领域的决策。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;制造：&lt;/strong&gt;通过预测性维护、质量控制和自主系统增强制造流程。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;客户服务：&lt;/strong&gt;人工智能驱动的聊天机器人和虚拟助理正在通过提供即时帮助和增强用户体验来改变客户服务。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;人工智能在 DevEx 中的潜力&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;strong&gt;提高灵活性：&lt;/strong&gt;生成式人工智能正在慢慢缩小框架之间的界限，使它们之间的转换变得轻而易举。 &lt;a href="https://ozone.one/the-role-of-large-language-models-(llms)-in-automating-pipeline-conversions-from-legacy-to-tekton"&gt;这是一篇关于如何通过使用户能够通过自动化在新时代和旧框架之间进行切换来重新定义用户体验的文章&lt;/a&gt;。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;简化流程：&lt;/strong&gt; Picture AI 可以自动执行重复性任务，使开发人员能够专注于工作中更复杂和更具创造性的方面。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;改进文档：&lt;/strong&gt;人工智能驱动的工具有助于创建强大的、用户友好的文档，使开发人员更容易理解和为项目做出贡献。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;我们看到的一个流行用例是 Github Copilot。&lt;/strong&gt;&lt;/p&gt;&lt;p&gt; GitHub Copilot 是一款由 GitHub 和 OpenAI 开发的人工智能驱动的代码完成工具，处于重塑开发者体验 (DevEx) 的最前沿。 GitHub Copilot 基于 OpenAI 的 Codex 构建，显着提高了工作效率，调查显示用户的工作效率提高了 55%。这种自动代码完成工具与 Visual Studio Code 和其他 IDE 无缝集成，可根据所编写代码的上下文建议巧妙的代码片段、完整功能和常见模式。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt; GitHub Copilot 的优点&lt;/h3&gt;&lt;p&gt;GitHub Copilot 通过最大限度地减少手动编码时间、改进样板代码创建以及快速解决 IDE 中的问题，从而显着提高开发速度，从而提高部署频率。此外，它还通过快速生成测试用例和数据来提高代码质量和测试覆盖率，从而改善开发人员体验 (DevEx)。作为虚拟的第二开发人员，Copilot Chat 可以加快代码审查时间，帮助创建高质量代码，并通过解释促进彻底理解。&lt;/p&gt;&lt;h3 class="wp-block-heading"&gt; GitHub Copilot 的缺点&lt;/h3&gt;&lt;p&gt;尽管有其优势，GitHub Copilot 也遇到了挑战，特别是由于其广泛的知识库而导致潜在的许可和版权问题。该工具的局限性包括可能缺乏特定领域的知识，从而阻碍了专业领域的精确建议。 GitHub Copilot 可能会面临不太常见的语言、框架或不可定制的库的困难，造成与公共存储库或闭源数据中易受攻击的代码相关的安全问题，可能导致版权问题。此外，该工具还引发了人们对完成代码会阻碍开发人员的担忧，这些代码可能看起来正确，但可能容易受到攻击或充满安全问题，从而破坏学习过程。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;超越 GitHub Copilot 的人工智能&lt;/h2&gt;&lt;p&gt;DevOps 的一项主要挑战是新技术的无缝过渡和采用，尤其是在迁移管道方面。新技术迁移历来都是采用的瓶颈。对于拥有大量管道的团队来说，从 Jenkins、GitLab 或 Azure Pipelines 过渡到 Tekton Pipelines 具有战略意义，因为它植根于 Kubernetes 和云原生方法。 Tekton Pipelines 提供优化的工作流程，加速云原生 DevOps 并通过动态集群管理确保性能和可扩展性。 Kubernetes 原生设计符合最佳实践，提高资源效率，并简化采用云原生方法的组织的管道管理。&lt;/p&gt;&lt;p&gt; Ozone 在使管道可移植性成为人工智能的无缝用户体验方面迈出了重要一步。通过利用先进的自动化，Ozone 使用人工智能来促进管道的顺利技术转型。这解决了与新技术采用相关的历史瓶颈，为希望通过多种管道拥抱 DevOps 的团队提供了解决方案。管道转换的自动化确保了无麻烦的转变，使团队更有吸引力地采用新技术，而不会遇到通常的复杂性和挑战。通过这种方式，Ozone 结合了人工智能和 DevOps 的力量，提供了一种解决方案，彻底改变了管道迁移过程，并使团队能够无缝地采用新技术。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;为什么需要管道可移植性&lt;/h2&gt;&lt;p&gt;对于深深植根于 Kubernetes 和云原生方法论的组织来说，从 Jenkins、GitLab 或 Azure Pipelines 过渡到 Tekton Pipelines 具有战略意义。 Tekton Pipelines 为以 Kubernetes 为中心的项目提供优化的工作流程，加速云原生 DevOps，并通过动态集群管理实现性能和可扩展性。通过 Kubernetes 原生设计，Tekton 与容器化和声明式配置等云原生最佳实践无缝结合。此迁移提高了资源效率并简化了采用云原生方法的组织的管道管理。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;它是如何完成的&lt;/h2&gt;&lt;h3 class="wp-block-heading"&gt;大规模自动化管道转换的工作流程&lt;/h3&gt;&lt;figure class="wp-block-image size-full"&gt;&lt;img alt="显示自动管道转换的流程图" class="wp-image-104797" height="1678" src="https://www.cncf.io/wp-content/uploads/2024/03/devex_ai_7ad3041f49.jpg" width="1999" /&gt;&lt;/figure&gt;&lt;p&gt;该工作流程的主要目标是通过利用 Prompt Engineering 使用大型语言模型 (LLM) 简化转换过程。这涉及利用聊天上下文和基于角色的提示为 LLM 模型建立上下文，使用各种平台的示例管道训练模型以定义相应的 YAML。&lt;/p&gt;&lt;p&gt;正如本博客所强调的，为了吸引顶尖技术人才、影响团队生产力并最终影响利润，必须理解和改善开发人员体验 (DevEx)。随着 Kubernetes 和云原生方法与 Tekton Pipelines 保持一致，Ozone 理解管道可移植性的战略重要性，特别是从 Jenkins、GitLab 或 Azure Pipelines 传输时。&lt;/p&gt;&lt;p&gt;将现有管道转换为可重复使用的 Tekton 管道的功能终身免费向每个用户开放，用户、构建、项目和管道不受限制。&lt;a href="https://cd.ozone.one/emailsignup"&gt;立即注册以转换您的管道！&lt;/a&gt;&lt;/p&gt;&lt;p&gt; &lt;a href="https://www.ozone.one/"&gt;Ozone&lt;/a&gt;专注于消除 DevOps 团队的各种复杂性。它简化并自动化了跨混合云和多样化区块链网络的容器化和去中心化应用程序部署。 Ozone 与 CI、CD、分析和自动化领域的主要工具无缝集成，以支持您端到端的软件交付，即使是最复杂的场景也是如此。&lt;/p&gt;&lt;p&gt;请写信给我们： &lt;a href="mailto:info@ozone.one"&gt;info@ozone.one&lt;/a&gt; &lt;/p&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;</description><pubDate>Tue, 26 Mar 2024 16:00:00 GMT</pubDate><guid isPermaLink="true">https://www.cncf.io/blog/2024/03/27/workflow-automation-pipeline-portability-with-ai-driven-devex/</guid></item><item><title>KCD 意大利 2024 标志：云原生和谐的一部分</title><link>https://www.cncf.io/blog/2024/03/26/the-kcd-italy-2024-logo-a-slice-of-cloud-native-harmony/</link><description>&lt;p&gt;&lt;em&gt;KCD 意大利团队发布的 KCD 帖子&lt;/em&gt;&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;strong&gt;呼吁协调&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;意大利 Kubernetes 社区日 (KCD) 是一项由 CNCF 支持的充满活力的活动，以全新的方式回归。 2024 年，CNCF 和 Linux 基金会要求努力协调全球所有 KCD 徽标。本文旨在讲述这一充满挑战的过程如何实现传统与全球协调的和谐融合。让我们探讨一下这种转变背后的原因、标志的历史，以及为什么保持一致的品牌标识仍然至关重要。 KCD 意大利只是其中之一，只是一个例子（因为我们团队热爱它的历史）。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;strong&gt;原来的标志&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;KCD 意大利徽标始终是社区精神、协作和 Kubernetes 热情的象征。 &lt;a href="https://www.cncf.io/blog/2021/10/04/how-was-a-pizza-chosen-as-the-kcd-italy-2021-logo/"&gt;&lt;strong&gt;2021 年&lt;/strong&gt;，该标志的特色是在擀面杖之间放置了一块俏皮的半披萨片，让人想起 Kubernetes 舵上的转向臂&lt;/a&gt;。这种异想天开的设计抓住了意大利 KCD 的精髓：一个社区就像美味披萨中的原料一样聚集在一起，创造出比各个部分相加更伟大的东西。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;strong&gt;为什么要改变？&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;之前的 KCD Italy 徽标对我们很有帮助，但随着社区的扩大，全球&lt;a href="https://www.cncf.io/kcds/"&gt;Kubernetes 社区日计划&lt;/a&gt;也随之扩大。 CNCF 与 Linux 基金会合作，鼓励我们将我们的视觉形象与全球其他 KCD 活动保持一致。是时候进化了——创建一个能在当地和全球引起共鸣的标志。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;strong&gt;元素背后的故事&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;在无数次讨论和头脑风暴会议中，答案出现了：&lt;strong&gt;披萨&lt;/strong&gt;。还有什么比这道受人喜爱的菜肴更具有意大利特色呢？披萨体现了意大利的精髓，远销世界各地，它象征着社交、分享和简单。它连接了半岛的北部、中部和南部，将意大利人因其对奶酪、松软美味的共同热爱而团结在一起。&lt;/p&gt;&lt;p&gt;但这不仅仅是披萨。 KCD Italy 的标志是一个切片的半比萨饼，放在擀面杖之间。这些擀面杖让人想起 Kubernetes 舵的转向臂，强调了推动云原生社区的热情。这是对科技世界的一种有趣的认可，在科技世界中，工作和热情常常交织在一起。&lt;/p&gt;&lt;p&gt;让我们再次剖析一下这个标志：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;披萨&lt;/strong&gt;：向国际社会致敬。它的配料——代表不同的文化、语言和观点——无缝地融合在一起。&lt;/li&gt;&lt;li&gt; &lt;strong&gt;Slice&lt;/strong&gt; ：我们的传统。因为我们的目标是与社区分享。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;擀面杖&lt;/strong&gt;：引导我们朝着共同的目标前进。 Kubernetes 就像揉好的面团一样，将我们联系在一起。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;花彩&lt;/strong&gt;：一丝奇思妙想和庆祝，强调学生的学习和成长精神。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;锚&lt;/strong&gt;：向云原生中的航海参考致敬——锚让我们在数字海洋中航行时保持脚踏实地。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;番茄红&lt;/strong&gt;：大胆而充满活力，象征着我们对开源的热情。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;浅面团颜色&lt;/strong&gt;：提醒我们，我们的旅程既独特又滋养。&lt;/li&gt;&lt;/ol&gt;&lt;h2 class="wp-block-heading"&gt; &lt;strong&gt;KCD 计划的徽标：颜色和象征意义&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;Kubernetes 社区日 (KCDs)&lt;/strong&gt;徽标是一种视觉表现形式，概括了这一社区驱动的活动的本质。让我们来分解一下它的要素：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;调色板&lt;/strong&gt;：&lt;ul&gt;&lt;li&gt;该标志主要采用蓝色和白色色调。蓝色象征着信任、稳定和技术，这与 Kubernetes 的核心原则是一致的。&lt;/li&gt;&lt;li&gt;白色背景象征着开放、透明和协作。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;图像&lt;/strong&gt;：&lt;ul&gt;&lt;li&gt;徽标中的双手传达了社区协作、知识共享和技术进步的信息。&lt;/li&gt;&lt;li&gt;它邀请参与者聚集在一起，学习并为 Kubernetes 生态系统做出贡献，背景的六边形让人想起。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;&lt;strong&gt;付清：&lt;/strong&gt;&lt;ul&gt;&lt;li&gt;共同成长云原生：很明显，这体现了开源创新的精神，将技术人员、采用者和爱好者聚集在一起，塑造云原生计算的未来&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ol&gt;&lt;p&gt;请注意，此分析基于视觉解释，实际的设计决策可能有创作者提供的其他背景&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;strong&gt;为什么它比以往任何时候都更重要&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;然后合并发生了。但为什么一致的品牌形象至关重要呢？有几个原因：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;&lt;strong&gt;全球认可&lt;/strong&gt;：明确定义的徽标可确保即时认可。当与会者看到 KCD Italy 标志时，他们知道自己是一个大家庭的一部分——一场全球运动。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;跨境信任&lt;/strong&gt;：一致性促进信任。世界各地的与会者会将徽标与质量、真实性和共享体验联系起来。&lt;/li&gt;&lt;li&gt;&lt;strong&gt;统一的切片&lt;/strong&gt;：集成的标志连接了各大洲。它是对话的开始，是跨时区的握手，是与会者联系、协作和享受云原生友情的聚集点&lt;/li&gt;&lt;/ol&gt;&lt;h2 class="wp-block-heading"&gt;&lt;strong&gt;展望未来&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;KCD 徽标的转变体现了协作和适应的力量。通过拥抱变革并尊重传统，所有团队确保其品牌形象在全球范围内引起共鸣。&lt;/p&gt;&lt;p&gt;在我们热切等待 2024 年 KCD 意大利版的同时，我们邀请整个 CNCF 社区加入我们。让我们一起握手、分享故事、品尝虚拟披萨。谁知道呢？也许明年，我们会在我们的标志中添加一些配料——额外的奶酪，有人吗？对了， &lt;a href="https://sessionize.com/kcd-italy-2024/?e=310130"&gt;CFP还开放&lt;/a&gt;，还有&lt;a href="https://drive.google.com/file/d/10iHzmJUoMLYWQxmxtrYuBGsDjSEbPNNC/view?usp=sharing"&gt;赞助机会&lt;/a&gt;！&lt;/p&gt;&lt;p&gt;云原生同胞们，胃口大开！ 🍕&lt;/p&gt;&lt;p&gt;&lt;em&gt;注：KCD Italy 徽标由充满热情的社区成员精心设计，体现了我们对包容性和共享成长的承诺，其象征意义体现了协作和乐趣的精神。&lt;/em&gt; &lt;/p&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;</description><pubDate>Mon, 25 Mar 2024 16:00:00 GMT</pubDate><guid isPermaLink="true">https://www.cncf.io/blog/2024/03/26/the-kcd-italy-2024-logo-a-slice-of-cloud-native-harmony/</guid></item><item><title>为什么您可能会从可观测性解决方案中删除关键移动数据</title><link>https://www.cncf.io/blog/2024/03/25/why-you-may-be-dropping-key-mobile-data-from-your-observability-solution/</link><description>&lt;p&gt;&lt;em&gt;Embrace 首席技术官兼联合创始人&lt;a href="https://www.linkedin.com/in/fredricnewberg/"&gt;Fredric Newberg&lt;/a&gt;的会员帖子&lt;/em&gt;&lt;/p&gt;&lt;p&gt;如果您有一个业务关键型移动应用程序，您可能会惊讶地发现您的可观测性解决方案正在丢弃大部分移动应用程序可观测性数据。这是因为来自移动设备的数据从客户端收集到服务器端摄取经常会出现延迟。但到底为什么会这样，它如何影响您的移动体验的可观察性？&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;a&gt;&lt;/a&gt;从移动设备收集数据的现实&lt;/h2&gt;&lt;p&gt;从移动设备收集数据时，您必须接受这一点——与后端可观察性不同——您无法控制整个系统。您收集数据的设备在人们手中。因此，它们是异构数据源，具有广泛不同的使用模式和网络连接。&lt;/p&gt;&lt;p&gt;后端和网络监控中的假设（即用户与可观测服务有连接）不适用于移动设备，但许多可观测工具都明确期望近乎持续的连接。然而，在移动应用程序中，人们的连接能力差异很大。&lt;/p&gt;&lt;p&gt;这让我们面临移动可观测性的严酷现实之一，即数据经常延迟。在移动设备上收集的数据可能需要数小时甚至数天的时间才能发送到后端系统。&lt;/p&gt;&lt;p&gt;从角度来看，大多数 DevOps 团队都会认为服务器离线一天并且不提供可观察性数据是非常不正常的。对于某些移动应用程序来说，这是常态而不是例外。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;a&gt;&lt;/a&gt;是什么导致了移动应用程序中的数据延迟？&lt;/h2&gt;&lt;p&gt;移动应用程序的数据延迟配置文件变化的一个关键方式是它们的使用模式。考虑在偏远地区使用健康和保健应用程序来导航路径。或者用于仓库、农业区或石油钻井平台的内部生产力应用程序。只要连接紧张，您就会看到更大的数据延迟。&lt;/p&gt;&lt;p&gt;然而，移动应用程序的一个主要好处是它们可以在任何地方使用。因此，即使是购物和手机游戏等与位置无关的应用程序，在连接状况不佳的情况下仍然会大量使用。人们在乘坐地铁或公交车时玩手机游戏。或者，他们在开车去附近的快餐店时下移动食品订单。&lt;/p&gt;&lt;p&gt;再举一个例子，在我们的客户群中（包括各个行业和类别的移动应用程序），我们只看到一小部分应用程序没有任何延迟至少一天的数据实例。&lt;/p&gt;&lt;p&gt;除了使用模式之外，iOS 和 Android 生态系统也会影响数据延迟。当应用程序在 iOS 上崩溃时，只有重新启动应用程序后才会报告崩溃。在 Android 上，情况要好一些，如果有互联网连接，大多数 Java 或 Kotlin 代码中发生的崩溃都可以在有限的延迟内报告，但本机代码中发生的崩溃要等到下一次应用程序启动时才会报告。 。因此，最终用户的行为（尤其是在 iOS 上）会影响您何时实际收到表明应用程序存在稳定性问题的数据。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;a&gt;&lt;/a&gt;为什么这些数据延迟很重要？&lt;/h2&gt;&lt;p&gt;让我们从显而易见的事情开始——您想要全面了解您的移动应用程序正在做什么。如果您的后端系统丢弃在设备上收集 3 小时后到达的任何数据，您将面临很大的可见性差距。在下图中，您可以看到丢弃延迟数据会损失多少可见性。 &lt;/p&gt;&lt;figure class="wp-block-image size-full"&gt;&lt;img alt="图像" class="wp-image-102855" height="624" src="https://www.cncf.io/wp-content/uploads/2024/03/image.png" width="936" /&gt;&lt;/figure&gt;&lt;p&gt;该数据是从数据延迟高于平均水平的客户处提取的。请注意，25% 的数据在移动设备上收集后至少 2 天内不会到达，而 100% 的数据在大约 1 周内不会到达。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;a&gt;&lt;/a&gt;为什么要丢弃延迟的数据？&lt;/h2&gt;&lt;p&gt;因此，如果这是移动应用程序的典型行为，那么这就引出了一个问题——为什么要丢弃延迟的数据？嗯，如上所述，这不是后端可观察性的典型行为。如果您的系统设计为处理来自后端应用程序的数据，那么支持延迟数据可能不是您所关心的问题。虽然在数据量适中时能够处理延迟数据的系统的修改或操作成本可能不那么高，但一旦数据量更大，您将开始遇到严峻的挑战。&lt;/p&gt;&lt;p&gt;在&lt;a href="https://embrace.io/"&gt;Embrace&lt;/a&gt; ，我们只关注移动可观测性，因此我们从第一天起就构建了我们的系统，期望我们能够获得大量延迟的数据。我们选择了能够有效存储延迟数据的构建块，并使用了容纳要存储和查询的延迟数据的数据模式，以便必须考虑的较大时间窗口不会导致查询性能的过度损失。&lt;/p&gt;&lt;p&gt;如果移动在您的组织中日益受到重视，您应该已经在计划如何大规模解决数据延迟问题。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;a&gt;&lt;/a&gt;对于延迟的数据问题，您今天可以采取什么措施？&lt;/h2&gt;&lt;p&gt;一个简单的解决方案是仅使用数据报告给可观测性服务的时间作为事件的时间。然而，这往往会导致更多的混乱而不是有帮助。让我们考虑一下这将如何影响跟踪您刚刚发布的新应用程序版本中的崩溃。&lt;/p&gt;&lt;p&gt;您的团队发现崩溃激增，因此您启动调查以追踪根本原因，然后发布新版本。崩溃率下降了，一切都很好。&lt;/p&gt;&lt;p&gt;但是，当使用先前崩溃版本的用户（他们太沮丧而无法重新启动您的应用程序）最终决定再试一次时，会发生什么呢？他们再次启动应用程序，该应用程序会从设备发送崩溃报告。如果您的可观察性工具将这些崩溃标记为刚刚发生，您可能会认为问题仍然存在，即使您发布了修复程序。&lt;/p&gt;&lt;p&gt;那么为什么不做正确的事情并将数据映射到事件发生的时间呢？您必须在摄取或查询时（有时甚至两者兼而有之）为此付出代价。大多数支持以经济高效的价格进行扩展的常用数据库都需要进行权衡，这使得摄取延迟数据变得非常重要。不过，如果您采用更简单的提取方法，您最终将在查询时付出代价，与正常情况下相比，您可能会查询更多数量级的数据，具体取决于您决定支持的延迟时间对于非延迟数据。&lt;/p&gt;&lt;h2 class="wp-block-heading"&gt;&lt;a&gt;&lt;/a&gt;结束语&lt;/h2&gt;&lt;p&gt;考虑到移动应用程序产生的价值以及它们对当今许多企业的重要性，基于可观测数据子集进行操作并不是一个明智的策略。由于多种原因，传统的可观测性解决方案无法有效监控移动应用程序，其中移动数据的延迟性是一个关键因素。&lt;/p&gt;&lt;p&gt;您并不是唯一一个意识到全面了解移动可观测性数据这一挑战的人。好消息是，今天有一些解决方案，从移动优先方法到配置现有后端系统，以解决移动数据捕获的尖角问题。随着移动技术的加速发展，我们还看到开源社区和管理团体重新思考移动遥测标准应该是什么。看到移动可观测性在不久的将来会是什么样子是令人兴奋的。&lt;/p&gt;&lt;hr class="wp-block-separator has-alpha-channel-opacity" /&gt;&lt;h2 class="wp-block-heading"&gt;&lt;a&gt;&lt;/a&gt; 作者简介&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;弗雷德里克·纽伯格&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Fredric Newberg 是 Embrace 的首席技术官兼联合创始人，该解决方案帮助工程师管理移动的复杂性，以构建更好、更大胆的体验。 Wildlife、TakeTwo、GOAT、Yahoo! 等公司Fantasy Sports 和《纽约时报》使用 Embrace 来识别任何影响用户的问题以及详细的技术背景，以便立即解决这些问题。&lt;/p&gt;&lt;p&gt; Fredric 在构建后端系统来处理移动游戏分析平台所需的大量数据方面拥有丰富的经验。他是 Kontagent（现为 Upsight）的创始工程师，这是一个面向顶级游戏开发商的大型移动分析平台。他设计并构建了后端系统，每月为全球客户处理 1500 个应用程序、2.5 亿月度活跃用户和 150B 起事件。随后，他成为 Rave 的创始工程师，Rave 是面向手机游戏开发者的顶级社交图谱工具包之一。 Rave 负责 2016 年 Pokemon Go 的发布。&lt;/p&gt;&lt;hr class="wp-block-separator has-alpha-channel-opacity" /&gt;&lt;p&gt;伸出手，让我们继续对话：&lt;/p&gt;&lt;p&gt;&lt;a href="mailto:fredric@embrace.io"&gt;弗雷德里克@embrace.io&lt;/a&gt;&lt;/p&gt;&lt;p&gt; &lt;a href="https://www.linkedin.com/in/fredricnewberg/"&gt;https://www.linkedin.com/in/fredricnewberg/&lt;/a&gt; &lt;/p&gt;&lt;figure class="wp-block-embed is-type-rich is-provider-twitter wp-block-embed-twitter"&gt;&lt;div class="wp-block-embed__wrapper"&gt; &lt;a class="twitter-timeline" href="https://twitter.com/fnewberg?ref_src=twsrc%5Etfw"&gt;fnewberg 的推文&lt;/a&gt;&lt;/div&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;</description><pubDate>Sun, 24 Mar 2024 16:00:00 GMT</pubDate><guid isPermaLink="true">https://www.cncf.io/blog/2024/03/25/why-you-may-be-dropping-key-mobile-data-from-your-observability-solution/</guid></item><item><title>KubeCon + CloudNativeCon Europe 2024 第四天：展望 Kubernetes 的过去和未来（以及更多新闻</title><link>https://www.cncf.io/blog/2024/03/22/kubecon-cloudnativecon-europe-2024-day-four-how-cloud-native-is-powering-the-ai-movement-and-other-news/</link><description>&lt;p&gt;今天是最后一天了，已经发生了很多事情！我们已经展示了当我们作为一个社区聚集在一起时可以创造出多么令人惊奇的事物。以下是 KubeCon + CloudNativeCon Europe 2024 第 4 天的亮点。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;开场主旨：十年了！&lt;/strong&gt;&lt;/p&gt;&lt;p&gt; Linux 基金会 (CNCF) 首席技术官 Chris Anisczcyk 在 KubeCon 的最后一天拉开帷幕，谈论 Kubernetes 的历史。从十年前的几个人到今天的 12,000 多人，Kubernetes 现在不仅是 GitHub 上最大的项目之一，也是最大的 Slack 渠道之一。 Anisczcyk 分享了即将举行的 Kubernetes 庆祝派对的详细信息、一个新的 contribcard.dev 网站，您可以在其中看到自己对 Kubernetes 的第一个贡献，以及一个名为&lt;a href="https://github.com/cncf/kubestronaut"&gt;Kubetronaut 计划&lt;/a&gt;的新教育大使计划。接下来我们要去哪里？今年秋天在盐湖城，然后在 2025 年春季在伦敦、2025 年秋季在亚特兰大、2026 年春季在阿姆斯特丹和 2026 年秋季在洛杉矶。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;主题演讲：成功并不能保证&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;Heroku 首席执行官 Bob Wise 谈到了云原生的起源，并指出了我们已经走了多远。云原生之旅走过了&lt;a href="https://kccnceu2024.sched.com/event/1b0NT/keynote-success-not-guaranteed-bob-wise-ceo-heroku?iframe=no&amp;amp;w=100%&amp;amp;sidebar=yes&amp;amp;bg=no"&gt;漫长的成功之路&lt;/a&gt;。最初 Kubernetes 被限制为最多 100 个节点，但在 2016 年启动了 Kubernetes Scaling SIG，因为能够扩展它是关键。此外，他们还需要社区治理，以确保 Google 和其他公司支持开源，当然还需要 CNCF 治理。 Docker 甚至可能已经被分叉了，但幸运的是没有。换句话说，一路上做出了很多很多决定，但他们在 Kubernetes 上下了很大的赌注，10 年后就得到了回报。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;主题演讲：云原生黑客大赛的获奖者是……&lt;/strong&gt;&lt;/p&gt;&lt;p&gt; &lt;a href="https://kccnceu2024.sched.com/event/1YhKH/keynote-cloud-native-hacks-winner-announcement?iframe=yes&amp;amp;w=100%&amp;amp;sidebar=yes&amp;amp;bg=no"&gt;黑客挑战赛&lt;/a&gt;是与联合国合作发起的，目的是引入技术来帮助解决世界上一些最紧迫的问题。该黑客马拉松与 6 个联合国合作者以及来自 8 个不同国家的 22 名参与者建立了合作伙伴关系。总共发生了超过 20 个小时的黑客攻击。&lt;/p&gt;&lt;p&gt;获奖者是：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;第三名——土豆队：Inhwan Hwang、Sungjin Hong、Myoenghun Yu。他们创建了最安全的步行路线，而不仅仅是最快的路线，以支持可持续城市和社区以及性别平等。&lt;/li&gt;&lt;/ul&gt;&lt;ul&gt;&lt;li&gt;第二名 – 林务员团队：Radu-Stegen Zamfir、Alex-Andrei Cioc 和 George-Alexandru Tudurean 创建了一款应用程序来监测森林砍伐以及监测和报告森林火灾，以支持气候行动和陆地生命。&lt;/li&gt;&lt;li&gt;第一名 – 城市团结：Carolina Lindqvist 和 Syed Ali Raza Zaidi 创建了一款用于集体制定城市重新规划决策的应用程序，以帮助建设更加可持续的城市和社区&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;&lt;strong&gt;主题演讲：应用交付的未来&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;当 Docker 在 2013 年推出时，容器革命开始了，它彻底&lt;a href="https://kccnceu2024.sched.com/event/1YhKQ/keynote-a-10-year-detour-the-future-of-application-delivery-in-a-containerized-world-solomon-hykes-ceo-daggerio?iframe=yes&amp;amp;w=100%&amp;amp;sidebar=yes&amp;amp;bg=no"&gt;改变了云基础设施的设计和使用方式&lt;/a&gt;。 Dagger.io 首席执行官 Solomon Hykes 告诉观众，这一切都始于 16 年前的巴黎，当时 Docker 的第一个工作版本诞生了。那时，严肃的人不会在云上运行严肃的应用程序。这个新模型没有工具。但 PaaS 正在美国兴起，而容器是“赢得”平台大战的最佳选择。模块化是关键，最终它流行起来，然后我们转向 Docker。&lt;/p&gt;&lt;p&gt;最终，围绕容器构建的生态系统比平台更重要。但对于开发者来说，体验仍然不完美。我们还没有完成，现在我们需要找到办法，让开发者的生活变得更好。这是下一个目标，工厂模型是最好的模型，将其视为我们拥有工厂的制造模型，它是一个集成的过程。&lt;/p&gt;&lt;p&gt;但现在有了AI，Kubernetes还有用吗？是的，您仍然需要应用程序和平台，而我们正在做这一切。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;主题小组讨论：多元化中的统一：云原生社区包容性增长的十年&lt;/strong&gt;&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Stéphane Este-Gracias，云原生支持催化剂、ITQ、CNCF 大使 | CNCF 法语术语表贡献者 |云原生卢森堡组织者&lt;/li&gt;&lt;li&gt;Andrea Giardini，独立云原生顾问/培训师&lt;/li&gt;&lt;li&gt;Jinhong Brejnholt，盛宝银行首席云架构师&lt;/li&gt;&lt;li&gt;Anastasiia Gubska，BT 集团 SRE/DevOps 工程师&lt;/li&gt;&lt;li&gt;Kasper Borg Nissen，Lunar 首席平台架构师&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;该小组探讨了&lt;a href="https://kccnceu2024.sched.com/event/1YhKV/keynote-panel-discussion-unity-in-diversity-a-decade-of-inclusive-growth-in-the-cloud-native-community-kasper-borg-nissen-lunar-jinhong-brejnholt-saxo-bank-andrea-giardini-independent-anastasiia-gubska-bt-group-stephane-este-gracias-itq?iframe=yes&amp;amp;w=100%&amp;amp;sidebar=yes&amp;amp;bg=no"&gt;超越代码的各种贡献&lt;/a&gt;，认识到本地大使、术语表翻译以及 Kubernetes 社区日 (KCD) 等活动在使云原生体验在全球范围内提供的重要作用。&lt;/p&gt;&lt;p&gt;即使没有代码，每个人都可以做出贡献。例如，词汇表项目只需要翻译能力。无代码贡献的另一个选择是与制图师工作组合作。&lt;/p&gt;&lt;p&gt;对于 CNCF 团体来说，包容性是不容谈判的。我们希望让每个人都能使用云原生技术。我们希望建立一个强大且支持性的社区，尤其是一个拥抱多样性的社区。&lt;/p&gt;&lt;p&gt;另一个例子是我们大约六个月前推出的 KubeTrain，目的是通过火车将尽可能多的人从欧洲不同城市带到 KubeCon。这项倡议后来发展成为一件大事，我们能够吸引来自欧洲各地的人们参加这次活动。&lt;/p&gt;&lt;p&gt;我们如何为 CNCF 社区的人们消除更多障碍？最重要的是确保每个人都可以访问一切。当无法参加活动时，失聪和听力困难的社区通常只是呆在家里。人们可能不知道的是，手语并不是通用的，因此仅仅拥有手语是不够的。但我们创造了一个空间，聋哑人可以用他们需要的任何语言互相交谈、分享和教育，分享知识和技能，并学习新技术。 KubeCon 是极少数可供聋哑人和听力障碍人士参加的活动之一。&lt;/p&gt;&lt;p&gt;&lt;strong&gt;主题演讲：&lt;/strong&gt;&lt;strong&gt;云原生的未来十年&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;AWS 首席工程师 Davanum Srinivas（又名 Dims）和 solo.io 开源负责人 Lin Sun 提供了 CNCF 技术监督委员会 (TOC) 的&lt;a href="https://kccnceu2024.sched.com/event/1YhKq/keynote-cloud-native-in-its-next-decade-davanum-srinivas-principal-engineer-aws-lin-sun-head-of-open-source-soloio?iframe=yes&amp;amp;w=100%&amp;amp;sidebar=yes&amp;amp;bg=no"&gt;历史、概述和最新动态&lt;/a&gt;，该委员会为云原生提供技术领导力社区。斯里尼瓦斯展示了从最小的社区到普罗米修斯，再到我们现在所处的历史。&lt;/p&gt;&lt;p&gt; Sun 根据成员的意见分享了社区未来十年的发展方向。一些预测和愿望清单包括整合、工作负载改进（例如异构工作负载、无服务器 API、可持续性）以及向云原生的转变并成为像过去的虚拟机一样的商品。人工智能愿望清单围绕工作负载的运营以及云支出的优化和可持续性。用户正在寻求人工智能的整合和更多用例。&lt;/p&gt;&lt;p&gt;是非对错，我们将在 KubeCon 2034 上揭晓！&lt;/p&gt;&lt;p&gt;&lt;strong&gt;主题演讲：最新毕业项目！&lt;/strong&gt;&lt;/p&gt;&lt;p&gt;从毕业项目中获取&lt;a href="https://www.cncf.io/blog/2024/03/13/cncf-graduated-projects-have-been-busy-here-are-the-latest-updates/"&gt;所有令人兴奋的细节&lt;/a&gt;。 &lt;/p&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;&lt;div class="wp-block-spacer is-style-80-120" style="height: 80px;"&gt;&lt;/div&gt;</description><pubDate>Thu, 21 Mar 2024 16:00:00 GMT</pubDate><guid isPermaLink="true">https://www.cncf.io/blog/2024/03/22/kubecon-cloudnativecon-europe-2024-day-four-how-cloud-native-is-powering-the-ai-movement-and-other-news/</guid></item></channel></rss>